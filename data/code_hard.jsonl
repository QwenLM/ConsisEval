{"key": 0, "prompt": "from typing import List, Tuple\n\ndef has_maximal_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" \n    Check if in given list of numbers, are any three numbers in which two of them are closer to the third one than\n    given threshold at the same time.\n    >>> has_maximal_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_maximal_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    False\n    >>> has_maximal_close_elements([1.0, 1.2, 1.1, 2.5, 3.5, 1.5, 1.3], 0.3)\n    True\n    \"\"\"\n", "canonical_solution": "    \n    n = len(numbers)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if ((abs(numbers[i] - numbers[j]) < threshold and abs(numbers[i] - numbers[k]) < threshold)\n                   or (abs(numbers[i] - numbers[j]) < threshold and abs(numbers[j] - numbers[k]) < threshold)\n                    or (abs(numbers[i] - numbers[k]) < threshold and abs(numbers[j] - numbers[k]) < threshold)):\n                    return True\n    return False", "test": "def check(candidate):\n    assert candidate([1.0, 1.2, 1.1, 2.5, 3.5, 1.5, 1.3], 0.3) == True\n    assert candidate([1.0, 1.2, 1.1, 2.5, 3.5, 1.5, 1.3], 0.05) == False\n    assert candidate([2.0, 2.2, 2.1, 3.5, 4.5, 2.7, 2.3], 0.3) == True\n    assert candidate([2.0, 2.2, 2.1, 3.5, 4.5, 2.7, 2.3], 0.1) == False\n    assert candidate([3.0, 5.0, 7.0, 4.0, 6.0, 2.0], 2) == True\n    assert candidate([3.0, 5.0, 7.0, 4.0, 6.0, 2.0], 0.5) == False\n    assert candidate([3.0, 3.1, 7.0, 7.2, 6.0, 6.1], 0.5) == False", "entry_point": "has_maximal_close_elements", "question": "Write a function def has_maximal_close_elements(numbers: List[float], threshold: float) -> bool: to solve the following problem:\nCheck if in given list of numbers, are any three numbers in which two of them are closer to the third one than\n    given threshold at the same time.\n    >>> has_maximal_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_maximal_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    False\n    >>> has_maximal_close_elements([1.0, 1.2, 1.1, 2.5, 3.5, 1.5, 1.3], 0.3)\n    True\n", "context": "from typing import List, Tuple\n\ndef has_maximal_close_elements(numbers: List[float], threshold: float) -> bool:"}
{"key": 1, "prompt": "\nfrom typing import List, Tuple\n\ndef separate_paren_groups(paren_string: str, k: int) -> List[str]:\n    \"\"\"\n    Input to this function is a string containing multiple groups of nested parentheses and an integer k.\n    Your goal is to separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n    \n    After separating them, each group of parentheses should be duplicated k times.\n    E.g., group like \"(())\" will be transformed into \"(())(())\" if k = 2 and \"(())(())(())\" if k = 3.\n    \n    Ignore any spaces in the input string.\n    \n    Raise a ValueError if k is negative.\n    \n    >>> separate_paren_groups('( ) (( )) (( )( ))', 2)\n    ['()()', '(())(())', '(()())(()())']\n    \"\"\"\n", "canonical_solution": "\n    if k < 0:\n        raise ValueError(\"K must not be negative\")\n\n    result = []\n    current_string = []\n    current_depth = 0\n   \n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth == 0:\n                result.append(''.join(current_string * k))\n                current_string.clear()\n\n    return result\n", "test": "\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())', 3) == [\n        '(()())(()())(()())', '((()))((()))((()))', '()()()', '((())()())((())()())((())()())'\n    ]\n    assert candidate('() (()) ((())) (((())))', 2) == [\n        '()()', '(())(())', '((()))((()))', '(((())))(((())))'\n    ]\n    assert candidate('(()(())((())))', 1) == [\n        '(()(())((())))'\n    ]\n    try:\n        candidate('( ) (( )) (( )( ))', -2)\n    except ValueError:\n        pass\n    else:\n        assert False, \"Expected ValueError when k is negative\"\n", "entry_point": "separate_paren_groups", "question": "Write a function def separate_paren_groups(paren_string: str, k: int) -> List[str]: to solve the following problem:\nInput to this function is a string containing multiple groups of nested parentheses and an integer k.\n    Your goal is to separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other.\n    \n    After separating them, each group of parentheses should be duplicated k times.\n    E.g., group like \"(())\" will be transformed into \"(())(())\" if k = 2 and \"(())(())(())\" if k = 3.\n    \n    Ignore any spaces in the input string.\n    \n    Raise a ValueError if k is negative.\n    \n    >>> separate_paren_groups('( ) (( )) (( )( ))', 2)\n    ['()()', '(())(())', '(()())(()())']\n", "context": "from typing import List, Tuple\n\ndef separate_paren_groups(paren_string: str, k: int) -> List[str]:"}
{"key": 2, "prompt": "\ndef truncate_number_and_add(number1: float, number2: float) -> float:\n    \"\"\" Given two positive floating point numbers, decompose each into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the sum of the decimal part of both numbers.\n    >>> truncate_number_and_add(3.5, 2.4)\n    0.9\n    \"\"\"\n", "canonical_solution": "\n    return (number1 % 1.0) + (number2 % 1.0)\n", "test": "\ndef check(candidate):\n    assert abs(candidate(3.5, 2.4) - 0.9) < 1e-6\n    assert abs(candidate(1.33, 0.77) - 1.1) < 1e-6\n    assert abs(candidate(123.456, 78.123) - 0.579) < 1e-6\n", "entry_point": "truncate_number_and_add", "question": "Write a function def truncate_number_and_add(number1: float, number2: float) -> float: to solve the following problem:\nGiven two positive floating point numbers, decompose each into\n    an integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the sum of the decimal part of both numbers.\n    >>> truncate_number_and_add(3.5, 2.4)\n    0.9\n", "context": "def truncate_number_and_add(number1: float, number2: float) -> float:"}
{"key": 3, "prompt": "\n\nfrom typing import List\n\n\ndef multiple_checkpoints(operations: List[int]) -> int:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that\n    starts with zero balance. Your task is to detect at how many points the balance of\n    account falls below zero. If the account never\n    falls below zero, the function should return 0.\n    >>> multiple_checkpoints([1, 2, 3])\n    0\n    >>> multiple_checkpoints([1, 2, -4, 5])\n    1\n    >>> multiple_checkpoints([1, -2, 3, -4, 5])\n    2\n    \"\"\"\n", "canonical_solution": "\n\n    balance = 0\n    checkpoints = 0\n\n    for op in operations:\n        balance += op\n        if balance < 0:\n            checkpoints += 1\n            #balance = 0 # Reset balance to 0 to avoid counting same checkpoint multiple times\n\n    return checkpoints", "test": "\n\ndef check(candidate):\n    assert candidate([]) == 0\n    assert candidate([1, 2, -3, 1, 2, -3]) == 0\n    assert candidate([1, 2, -4, 5, 6]) == 1\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == 0\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -5]) == 1\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == 4\n    assert candidate([1, -2, 3, -4, 5, -4, 2, -5]) == 4", "entry_point": "multiple_checkpoints", "question": "Write a function def multiple_checkpoints(operations: List[int]) -> int: to solve the following problem:\nYou're given a list of deposit and withdrawal operations on a bank account that\n    starts with zero balance. Your task is to detect at how many points the balance of\n    account falls below zero. If the account never\n    falls below zero, the function should return 0.\n    >>> multiple_checkpoints([1, 2, 3])\n    0\n    >>> multiple_checkpoints([1, 2, -4, 5])\n    1\n    >>> multiple_checkpoints([1, -2, 3, -4, 5])\n    2\n", "context": "from typing import List\n\n\ndef multiple_checkpoints(operations: List[int]) -> int:"}
{"key": 4, "prompt": "\n\nfrom typing import List, Tuple\n\ndef mean_and_mean_absolute_deviation(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" For a given list of input numbers, calculate Mean and Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean is the sum of the numbers in the dataset divided by the count of numbers in the dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    The function should return a tuple where the first element is the mean and the second element is the MAD.\n    \n    >>> mean_and_mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    (2.5, 1.0)\n    \"\"\"\n", "canonical_solution": "\n\n    mean = sum(numbers) / len(numbers)\n    mad = sum(abs(x - mean) for x in numbers) / len(numbers)\n    return mean, mad\n\n", "test": "\n\ndef check(candidate):\n    mean, mad = candidate([1.0, 2.0, 3.0])\n    assert abs(mean - 2.0) < 1e-6\n    assert abs(mad - 2.0/3.0) < 1e-6\n    \n    mean, mad = candidate([1.0, 2.0, 3.0, 4.0])\n    assert abs(mean - 2.5) < 1e-6\n    assert abs(mad - 1.0) < 1e-6\n    \n    mean, mad = candidate([1.0, 2.0, 3.0, 4.0, 5.0])\n    assert abs(mean - 3.0) < 1e-6\n    assert abs(mad - 6.0/5.0) < 1e-6\n\n\n", "entry_point": "mean_and_mean_absolute_deviation", "question": "Write a function def mean_and_mean_absolute_deviation(numbers: List[float]) -> Tuple[float, float]: to solve the following problem:\nFor a given list of input numbers, calculate Mean and Mean Absolute Deviation\n    around the mean of this dataset.\n    \n    Mean is the sum of the numbers in the dataset divided by the count of numbers in the dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    \n    The function should return a tuple where the first element is the mean and the second element is the MAD.\n    \n    >>> mean_and_mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    (2.5, 1.0)\n", "context": "from typing import List, Tuple\n\ndef mean_and_mean_absolute_deviation(numbers: List[float]) -> Tuple[float, float]:"}
{"key": 5, "prompt": "\nfrom typing import List, Tuple\n\ndef intersperse_with_modified_delimeters(numbers: List[int], delimeters: Tuple[int, int]) -> List[int]:\n    \"\"\" Insert numbers 'delimeters' between every two consecutive elements of input list `numbers'. \n    The first delimeter is inserted between the first pair, the second delimeter between the second pair, and then repeats.\n    >>> intersperse_with_modified_delimeters([], (4, 5))\n    []\n    >>> intersperse_with_modified_delimeters([1, 2, 3, 4], (6, 7))\n    [1, 6, 2, 7, 3, 6, 4]\n    \"\"\"\n", "canonical_solution": "    if not numbers:\n        return []\n\n    result = []\n    delimeters = list(delimeters)\n\n    for i, n in enumerate(numbers[:-1]):\n        result.append(n)\n        result.append(delimeters[i % 2])\n        \n    result.append(numbers[-1])\n    return result", "test": "\ndef check(candidate):\n    assert candidate([], (8, 9)) == []\n    assert candidate([1, 2, 3, 4], (6, 7)) == [1, 6, 2, 7, 3, 6, 4]\n    assert candidate([10, 9, 8, 7, 6, 5], (20, 15)) == [10, 20, 9 ,15, 8, 20, 7, 15, 6, 20, 5]\n    assert candidate([2, 2, 2], (4, 5)) == [2, 4, 2, 5, 2]\n", "entry_point": "intersperse_with_modified_delimeters", "question": "Write a function def intersperse_with_modified_delimeters(numbers: List[int], delimeters: Tuple[int, int]) -> List[int]: to solve the following problem:\nInsert numbers 'delimeters' between every two consecutive elements of input list `numbers'. \n    The first delimeter is inserted between the first pair, the second delimeter between the second pair, and then repeats.\n    >>> intersperse_with_modified_delimeters([], (4, 5))\n    []\n    >>> intersperse_with_modified_delimeters([1, 2, 3, 4], (6, 7))\n    [1, 6, 2, 7, 3, 6, 4]\n", "context": "from typing import List, Tuple\n\ndef intersperse_with_modified_delimeters(numbers: List[int], delimeters: Tuple[int, int]) -> List[int]:"}
{"key": 6, "prompt": "\nfrom typing import List, Tuple\n\ndef parse_nested_parens_extended(paren_string: str) -> Tuple[List[int], List[int]]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    The function will return two lists. \n    The first list will contain the deepest level of nesting of parentheses for each group.\n    The second list will contain the total count of parentheses for each group.\n    E.g. (()()) has maximum two levels of nesting and 6 total parentheses while ((())) has three levels of nesting and 6 total parentheses.\n    \n    >>> parse_nested_parens_extended('(()()) ((())) () ((())()())')\n    ([2, 3, 1, 3], [6, 6, 2, 10])\n    \"\"\"\n", "canonical_solution": "    def parse_paren_group(s):\n        depth = 0\n        max_depth = 0\n        total_count = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n                total_count += 1\n            elif c == ')':\n                depth -= 1\n                total_count += 1\n        return (max_depth, total_count)\n    \n    results = [parse_paren_group(x) for x in paren_string.split(' ')]\n    return ([result[0] for result in results], [result[1] for result in results])", "test": "\ndef check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == ([2, 3, 1, 3], [6, 6, 2, 10])\n    assert candidate('() (()) ((())) (((())))') == ([1, 2, 3, 4], [2, 4, 6, 8])\n    assert candidate('(()(())((())))') == ([4], [14])\n", "entry_point": "parse_nested_parens_extended", "question": "Write a function def parse_nested_parens_extended(paren_string: str) -> Tuple[List[int], List[int]]: to solve the following problem:\nInput to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    The function will return two lists. \n    The first list will contain the deepest level of nesting of parentheses for each group.\n    The second list will contain the total count of parentheses for each group.\n    E.g. (()()) has maximum two levels of nesting and 6 total parentheses while ((())) has three levels of nesting and 6 total parentheses.\n    \n    >>> parse_nested_parens_extended('(()()) ((())) () ((())()())')\n    ([2, 3, 1, 3], [6, 6, 2, 10])\n", "context": "from typing import List, Tuple\n\ndef parse_nested_parens_extended(paren_string: str) -> Tuple[List[int], List[int]]:"}
{"key": 7, "prompt": "\n\nfrom typing import List\n\n\ndef find_occurrences_and_filter(strings: List[str], substring: str) -> List[str]:\n    \"\"\"\n    Filters the input list of strings to ones that contain the given substring. \n    Then, it counts the number of occurrences of that substring in those strings \n    and returns a list of tuples, each containing a filtered string and its count of \n    the substring.\n    \n    >>> find_occurrences_and_filter([], 'a')\n    []\n    >>> find_occurrences_and_filter(['abc', 'bacd', 'cde', 'array'], 'a')\n    [('abc', 1), ('bacd', 1), ('array', 1)]\n    >>> find_occurrences_and_filter(['aaa', 'bacd', 'cde', 'array'], 'a')\n    [('aaa', 3), ('bacd', 1), ('array', 1)]\n    \"\"\"\n", "canonical_solution": "\n\n    return [(x, x.count(substring)) for x in strings if substring in x]\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'johndoe', 'xxxjohndoe', 'xxxAAA', 'xxx'], 'john') == [('johndoe', 1), ('xxxjohndoe', 1)]\n    assert candidate(['xxx', 'xxxyyy', 'aaaxxy', 'xxxAAA', 'xxx'], 'xx') == [('xxx', 1), ('xxxyyy', 1), ('aaaxxy', 1), ('xxxAAA', 1), ('xxx', 1)]\n    assert candidate(['run', 'runrun', 'prune', 'runagain'], 'run') == [('run', 1), ('runrun', 2), ('prune', 1), ('runagain', 1)]\n\n", "entry_point": "find_occurrences_and_filter", "question": "Write a function def find_occurrences_and_filter(strings: List[str], substring: str) -> List[str]: to solve the following problem:\nFilters the input list of strings to ones that contain the given substring. \n    Then, it counts the number of occurrences of that substring in those strings \n    and returns a list of tuples, each containing a filtered string and its count of \n    the substring.\n    \n    >>> find_occurrences_and_filter([], 'a')\n    []\n    >>> find_occurrences_and_filter(['abc', 'bacd', 'cde', 'array'], 'a')\n    [('abc', 1), ('bacd', 1), ('array', 1)]\n    >>> find_occurrences_and_filter(['aaa', 'bacd', 'cde', 'array'], 'a')\n    [('aaa', 3), ('bacd', 1), ('array', 1)]\n", "context": "from typing import List\n\n\ndef find_occurrences_and_filter(strings: List[str], substring: str) -> List[str]:"}
{"key": 8, "prompt": "\nfrom typing import List, Tuple\n\ndef sum_product_even_odd(numbers: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:\n    \"\"\" For a given list of integers, return two tuples. The first tuple consists of a sum and a product of all even integers in the list. The second tuple consists of a sum and a product of all odd integers in the list. For any empty list or when there are no even or odd numbers, the sum should be 0 and product should be 1.\n    >>> sum_product_even_odd([])\n    ((0, 1), (0, 1)) \n    >>> sum_product_even_odd([1, 2, 3, 4])\n    ((6, 8), (4, 3))\n    \"\"\"\n", "canonical_solution": "\n    sum_even = 0\n    prod_even = 1\n    sum_odd = 0\n    prod_odd = 1\n\n    for n in numbers:\n        if n % 2 == 0:\n            sum_even += n\n            prod_even *= n\n        else:\n            sum_odd += n\n            prod_odd *= n\n\n    return (sum_even, prod_even), (sum_odd, prod_odd)\n\n", "test": "\ndef check(candidate):\n\n    assert candidate([]) == ((0, 1), (0, 1))\n    assert candidate([2, 2, 2]) == ((6, 8), (0, 1))\n    assert candidate([3, 3, 3]) == ((0, 1), (9, 27))\n    assert candidate([1, 2, 3, 4]) == ((6, 8), (4, 3))\n    assert candidate([10]) == ((10, 10), (0, 1))\n\n", "entry_point": "sum_product_even_odd", "question": "Write a function def sum_product_even_odd(numbers: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]: to solve the following problem:\nFor a given list of integers, return two tuples. The first tuple consists of a sum and a product of all even integers in the list. The second tuple consists of a sum and a product of all odd integers in the list. For any empty list or when there are no even or odd numbers, the sum should be 0 and product should be 1.\n    >>> sum_product_even_odd([])\n    ((0, 1), (0, 1)) \n    >>> sum_product_even_odd([1, 2, 3, 4])\n    ((6, 8), (4, 3))\n", "context": "from typing import List, Tuple\n\ndef sum_product_even_odd(numbers: List[int]) -> Tuple[Tuple[int, int], Tuple[int, int]]:"}
{"key": 9, "prompt": "\n\nfrom typing import List, Tuple\n\ndef rolling_max_min(numbers: List[int]) -> Tuple[List[int], List[int]]:\n    \"\"\" From a given list of integers, generate two lists. The first list is the \n    sequence of rolling maximum elements found until the given moment in the sequence,\n    and the second list is the sequence of rolling minimum elements found until the given moment.\n    >>> rolling_max_min([1, 2, 3, 2, 3, 4, 2])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 1, 1, 1, 1, 1, 1])\n    \"\"\"\n", "canonical_solution": "\n\n    running_max = None\n    running_min = None\n    max_result = []\n    min_result = []\n\n    for n in numbers:\n        if running_max is None and running_min is None:\n            running_max = running_min = n\n        else:\n            running_max = max(running_max, n)\n            running_min = min(running_min, n)\n\n        max_result.append(running_max)\n        min_result.append(running_min)\n\n    return max_result, min_result\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([]) == ([], [])\n    assert candidate([1, 2, 3, 4]) == ([1, 2, 3, 4], [1, 1, 1, 1])\n    assert candidate([4, 3, 2, 1]) == ([4, 4, 4, 4], [4, 3, 2, 1])\n    assert candidate([3, 2, 3, 100, 3]) == ([3, 3, 3, 100, 100], [3, 2, 2, 2, 2])\n\n", "entry_point": "rolling_max_min", "question": "Write a function def rolling_max_min(numbers: List[int]) -> Tuple[List[int], List[int]]: to solve the following problem:\nFrom a given list of integers, generate two lists. The first list is the \n    sequence of rolling maximum elements found until the given moment in the sequence,\n    and the second list is the sequence of rolling minimum elements found until the given moment.\n    >>> rolling_max_min([1, 2, 3, 2, 3, 4, 2])\n    ([1, 2, 3, 3, 3, 4, 4], [1, 1, 1, 1, 1, 1, 1])\n", "context": "from typing import List, Tuple\n\ndef rolling_max_min(numbers: List[int]) -> Tuple[List[int], List[int]]:"}
{"key": 10, "prompt": "from typing import Union\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef create_palindrome_pairs(string1: str, string2: str) -> Union[None, str]:\n    \"\"\" Takes two strings as input. \n    - Find out if any of the strings is a palindrome.\n    - If none of the strings is a palindrome, return None\n    - If any of the strings is a palindrome, make the other string a palindrome\n    - Then returns the result as a single string with the two palindromic strings separated by a white space\n    >>> create_palindrome_pairs('', '')\n    ''\n    >>> create_palindrome_pairs('cat', 'dog')\n    None\n    >>> create_palindrome_pairs('civic', 'cata')\n    'civic catac'\n    \"\"\"\n", "canonical_solution": "\n    if not string1 and not string2:\n        return ''\n    \n    flag1 = is_palindrome(string1)\n    flag2 = is_palindrome(string2)\n    \n    if flag1 and flag2:\n        return string1 + ' ' + string2\n    elif flag1 and not flag2:\n        start_of_suffix = 0\n        while not is_palindrome(string2[start_of_suffix:]):\n            start_of_suffix += 1\n        string2 = string2 + string2[:start_of_suffix][::-1]\n        return string1 + ' ' + string2\n    elif not flag1 and flag2:\n        start_of_suffix = 0\n        while not is_palindrome(string1[start_of_suffix:]):\n            start_of_suffix += 1\n        string1 = string1 + string1[:start_of_suffix][::-1]\n        return string1 + ' ' + string2\n    else:\n        return None", "test": "def check(candidate):\n    # assert candidate('', '') == ''\n    assert candidate('x', 'y') == 'x y'\n    assert candidate('xyz', 'dog') == None\n    assert candidate('civic', 'dog') == 'civic dogod'\n    assert candidate('jerry', 'cat') == None", "entry_point": "create_palindrome_pairs", "question": "Write a function def create_palindrome_pairs(string1: str, string2: str) -> Union[None, str]: to solve the following problem:\nTakes two strings as input. \n    - Find out if any of the strings is a palindrome.\n    - If none of the strings is a palindrome, return None\n    - If any of the strings is a palindrome, make the other string a palindrome\n    - Then returns the result as a single string with the two palindromic strings separated by a white space\n    >>> create_palindrome_pairs('', '')\n    ''\n    >>> create_palindrome_pairs('cat', 'dog')\n    None\n    >>> create_palindrome_pairs('civic', 'cata')\n    'civic catac'\n", "context": "from typing import Union\n\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef create_palindrome_pairs(string1: str, string2: str) -> Union[None, str]:"}
{"key": 11, "prompt": "\n\nfrom typing import List\n\ndef string_xor_with_checks(a: str, b: str) -> str:\n    \"\"\" \n    Inputs are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string if the two strings are of same length, if not return 'invalid input'.\n    Test if string a or b is empty, return the non empty string or 'both strings are empty' if both are empty.\n\n    >>> string_xor_with_checks('010', '110')\n    '100'\n\n    >>> string_xor_with_checks('01', '110')\n    'invalid input'\n    \n    >>> string_xor_with_checks('', '110')\n    '110'\n\n    >>> string_xor_with_checks('', '')\n    'both strings are empty'\n    \"\"\"\n", "canonical_solution": "\n    def xor(i, j):\n        if i == j:\n            return '0'\n        else:\n            return '1'\n\n    if not a and not b:\n        return 'both strings are empty'\n    \n    if len(a) == 0:\n        return b\n\n    if len(b) == 0:\n        return a\n\n    if len(a) != len(b):\n        return 'invalid input'\n        \n    return ''.join(xor(x, y) for x, y in zip(a, b))", "test": "\n \ndef check(candidate):\n    \n    assert candidate('111000', '101010') == '010010'\n    assert candidate('1', '1') == '0'\n    assert candidate('0101', '0000') == '0101'\n    assert candidate('01', '110') == 'invalid input'\n    assert candidate('', '110') == '110'\n    assert candidate('', '') == 'both strings are empty'\n    print(\"All checks pass.\")\n\ncheck(string_xor_with_checks)\n\n", "entry_point": "string_xor_with_checks", "question": "Write a function def string_xor_with_checks(a: str, b: str) -> str: to solve the following problem:\nInputs are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string if the two strings are of same length, if not return 'invalid input'.\n    Test if string a or b is empty, return the non empty string or 'both strings are empty' if both are empty.\n\n    >>> string_xor_with_checks('010', '110')\n    '100'\n\n    >>> string_xor_with_checks('01', '110')\n    'invalid input'\n    \n    >>> string_xor_with_checks('', '110')\n    '110'\n\n    >>> string_xor_with_checks('', '')\n    'both strings are empty'\n", "context": "from typing import List\n\ndef string_xor_with_checks(a: str, b: str) -> str:"}
{"key": 12, "prompt": "\n\nfrom typing import List, Optional, Tuple\n\ndef longest_and_shortest(strings: List[str]) -> Tuple[Optional[str], Optional[str]]:\n    \"\"\" \n    Out of list of strings, return the longest one and shortest one. \n    Return the first one in case of multiple strings of the same length. \n    Return (None, None) in case the input list is empty.\n    This modification from previous function will challenge the coder to find both longest and\n    shortest string in the given list of string.\n    >>> longest_and_shortest([])\n    (None, None)\n    >>> longest_and_shortest(['a', 'b', 'c'])\n    ('a', 'a')\n    >>> longest_and_shortest(['a', 'bb', 'ccc'])\n    ('ccc', 'a')\n    \"\"\"\n", "canonical_solution": "\n\n    if not strings:\n        return (None, None)\n\n    max_len = max(len(x) for x in strings)\n    min_len = min(len(x) for x in strings)\n    longest_str = next(s for s in strings if len(s) == max_len)\n    shortest_str = next(s for s in strings if len(s) == min_len)\n    \n    return (longest_str, shortest_str)\n    \n", "test": "\n\ndef check(candidate):\n    assert candidate([]) == (None, None)\n    assert candidate(['x', 'y', 'z']) == ('x', 'x')\n    assert candidate(['x', 'yyy', 'zzzz', 'm', 'kkkk', 'abc']) == ('zzzz', 'x')\n    assert candidate(['xy', 'yz', 'z']) == ('xy', 'z')\n\n", "entry_point": "longest_and_shortest", "question": "Write a function def longest_and_shortest(strings: List[str]) -> Tuple[Optional[str], Optional[str]]: to solve the following problem:\nOut of list of strings, return the longest one and shortest one. \n    Return the first one in case of multiple strings of the same length. \n    Return (None, None) in case the input list is empty.\n    This modification from previous function will challenge the coder to find both longest and\n    shortest string in the given list of string.\n    >>> longest_and_shortest([])\n    (None, None)\n    >>> longest_and_shortest(['a', 'b', 'c'])\n    ('a', 'a')\n    >>> longest_and_shortest(['a', 'bb', 'ccc'])\n    ('ccc', 'a')\n", "context": "from typing import List, Optional, Tuple\n\ndef longest_and_shortest(strings: List[str]) -> Tuple[Optional[str], Optional[str]]:"}
{"key": 13, "prompt": "\ndef greatest_common_divisor_and_least_common_multiple(a: int, b: int) -> tuple:\n    \"\"\" Return both the greatest common divisor and the least common multiple of two integers a and b\n    >>> greatest_common_divisor_and_least_common_multiple(3, 5)\n    (1, 15)\n    >>> greatest_common_divisor_and_least_common_multiple(25, 15)\n    (5, 75)\n    \"\"\"\n", "canonical_solution": "\n    \"\"\"Euclid's Algorithm to find GCD\"\"\"\n    original_a = a\n    original_b = b\n    while b:\n        a, b = b, a % b\n      \n    gcd = a\n    lcm = abs(original_a * original_b) // gcd\n\n    return gcd, lcm\n", "test": "\ndef check(candidate):\n    assert candidate(3, 7) == (1, 21)\n    assert candidate(10, 15) == (5, 30)\n    assert candidate(49, 14) == (7, 98)\n    assert candidate(144, 60) == (12, 720)\n\n", "entry_point": "greatest_common_divisor_and_least_common_multiple", "question": "Write a function def greatest_common_divisor_and_least_common_multiple(a: int, b: int) -> tuple: to solve the following problem:\nReturn both the greatest common divisor and the least common multiple of two integers a and b\n    >>> greatest_common_divisor_and_least_common_multiple(3, 5)\n    (1, 15)\n    >>> greatest_common_divisor_and_least_common_multiple(25, 15)\n    (5, 75)\n", "context": "def greatest_common_divisor_and_least_common_multiple(a: int, b: int) -> tuple:"}
{"key": 14, "prompt": "from typing import List, Tuple\n\n\ndef all_prefixes_suffixes(string: str) -> Tuple[List[str], List[str]]:\n    \"\"\" Return a tuple consists of two lists. \n    The first list is all prefixes from shortest to longest; \n    the second list is all suffixes from shortest to longest of the input string\n    >>> all_prefixes_suffixes('abc')\n    (['a', 'ab', 'abc'], ['c', 'bc', 'abc'])\n    \"\"\"\n", "canonical_solution": "\n    prefix = []\n    suffix = []\n\n    for i in range(len(string)):\n        prefix.append(string[:i+1])\n        suffix.append(string[-i-1:])\n\n    return (prefix, suffix)", "test": "\ndef check(candidate):\n    assert candidate('') == ([], [])\n    assert candidate('asdfgh') == (['a', 'as', 'asd', 'asdf', 'asdfg', 'asdfgh'], ['h', 'gh', 'fgh', 'dfgh', 'sdfgh', 'asdfgh'])\n    assert candidate('WWW') == (['W', 'WW', 'WWW'], ['W', 'WW', 'WWW'])", "entry_point": "all_prefixes_suffixes", "question": "Write a function def all_prefixes_suffixes(string: str) -> Tuple[List[str], List[str]]: to solve the following problem:\nReturn a tuple consists of two lists. \n    The first list is all prefixes from shortest to longest; \n    the second list is all suffixes from shortest to longest of the input string\n    >>> all_prefixes_suffixes('abc')\n    (['a', 'ab', 'abc'], ['c', 'bc', 'abc'])\n", "context": "from typing import List, Tuple\n\n\ndef all_prefixes_suffixes(string: str) -> Tuple[List[str], List[str]]:"}
{"key": 15, "prompt": "\ndef string_sequence_step(n: int, step: int) -> str:\n    \"\"\" \n    Return a string containing space-delimited numbers starting from 0 upto n inclusive, where step is the increment.\n    The sequence starts from 0 and increments by step in each iteration.\n    >>> string_sequence_step(0, 1)\n    '0'\n    >>> string_sequence_step(5, 1)\n    '0 1 2 3 4 5'\n    >>> string_sequence_step(10, 2)\n    '0 2 4 6 8 10'\n    \"\"\"\n", "canonical_solution": "    return ' '.join([str(x) for x in range(0, n + 1, step)])", "test": "\ndef check(candidate):\n    assert candidate(0, 1) == '0'\n    assert candidate(5, 1) == '0 1 2 3 4 5'\n    assert candidate(10, 2) == '0 2 4 6 8 10'\n    assert candidate(20, 5) == '0 5 10 15 20'\n", "entry_point": "string_sequence_step", "question": "Write a function def string_sequence_step(n: int, step: int) -> str: to solve the following problem:\nReturn a string containing space-delimited numbers starting from 0 upto n inclusive, where step is the increment.\n    The sequence starts from 0 and increments by step in each iteration.\n    >>> string_sequence_step(0, 1)\n    '0'\n    >>> string_sequence_step(5, 1)\n    '0 1 2 3 4 5'\n    >>> string_sequence_step(10, 2)\n    '0 2 4 6 8 10'\n", "context": "def string_sequence_step(n: int, step: int) -> str:"}
{"key": 16, "prompt": "\n\ndef count_distinct_characters_with_frequency(string: str) -> dict:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consists of.\n    Also, return a dictionary which shows the frequency of each distinct character.\n    Ignore spaces in the string.\n    >>> count_distinct_characters_with_frequency('xyzXYZ')\n    {'x': 2, 'y': 2, 'z': 2}\n    >>> count_distinct_characters_with_frequency('Jerry')\n    {'j': 2, 'e': 1, 'r': 2, 'y': 1}\n    \"\"\"\n", "canonical_solution": "    string = string.lower().replace(\" \", \"\")\n    return {char: string.count(char) for char in set(string)}", "test": "\n\ndef check(candidate):\n    assert candidate('') == {}\n    assert candidate('aaa') == {'a': 3}\n    assert candidate('aab aa') == {'a': 4, 'b': 1}\n    assert candidate('abcde') == {'a': 1, 'b': 1, 'c': 1, 'd': 1, 'e': 1}\n    assert candidate('Jerry Jerry') == {'j': 2, 'e': 2, 'r': 4, 'y': 2}\n\n", "entry_point": "count_distinct_characters_with_frequency", "question": "Write a function def count_distinct_characters_with_frequency(string: str) -> dict: to solve the following problem:\nGiven a string, find out how many distinct characters (regardless of case) does it consists of.\n    Also, return a dictionary which shows the frequency of each distinct character.\n    Ignore spaces in the string.\n    >>> count_distinct_characters_with_frequency('xyzXYZ')\n    {'x': 2, 'y': 2, 'z': 2}\n    >>> count_distinct_characters_with_frequency('Jerry')\n    {'j': 2, 'e': 1, 'r': 2, 'y': 1}\n", "context": "def count_distinct_characters_with_frequency(string: str) -> dict:"}
{"key": 17, "prompt": "\nfrom typing import List, Tuple\n\ndef extend_parse_music(music_string: str, mapping: Tuple[str, str, str]) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format, \n    and a tuple of three different notes. These notes are marked as 'whole note', 'half note' and\n    'quarter note' respectively in the input string.\n    \n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last under the condition that 'whole note' lasts four beats, 'half note' lasts two beats and \n    'quarter note' lasts one beat.\n\n    For example, if the string is 'note1 note2| note3| note1| note1| note3| note3| note3| note3| note1 note1' \n    and your tuple is ('note1', 'note2|', 'note3|'), your function should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n    \"\"\"\n", "canonical_solution": "    note_map = {mapping[0]: 4, mapping[1]: 2, mapping[2]: 1}\n    return [note_map[x] for x in music_string.split(' ') if x]", "test": "\ndef check(candidate):\n    assert candidate('', ('note1', 'note2|', 'note3|')) == []\n    assert candidate('note1 note1 note1 note1', ('note1', 'note2|', 'note3|')) == [4, 4, 4, 4]\n    assert candidate('note3| note3| note3| note3|', ('note1', 'note2|', 'note3|')) == [1, 1, 1, 1]\n    assert candidate('note2| note2| note3| note3| note1 note1 note1 note1', \n                     ('note1', 'note2|', 'note3|')) == [2, 2, 1, 1, 4, 4, 4, 4]\n    assert candidate('note2| note3| note2| note3| note1 note2| note1 note2|', \n                     ('note1', 'note2|', 'note3|')) == [2, 1, 2, 1, 4, 2, 4, 2]\n", "entry_point": "extend_parse_music", "question": "Write a function def extend_parse_music(music_string: str, mapping: Tuple[str, str, str]) -> List[int]: to solve the following problem:\nInput to this function is a string representing musical notes in a special ASCII format, \n    and a tuple of three different notes. These notes are marked as 'whole note', 'half note' and\n    'quarter note' respectively in the input string.\n    \n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    note last under the condition that 'whole note' lasts four beats, 'half note' lasts two beats and \n    'quarter note' lasts one beat.\n\n    For example, if the string is 'note1 note2| note3| note1| note1| note3| note3| note3| note3| note1 note1' \n    and your tuple is ('note1', 'note2|', 'note3|'), your function should return [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4].\n", "context": "from typing import List, Tuple\n\ndef extend_parse_music(music_string: str, mapping: Tuple[str, str, str]) -> List[int]:"}
{"key": 18, "prompt": "\nfrom typing import List \n\ndef find_substrings(string: str, substrings: List[str]) -> List[int]:\n    \"\"\" Finds how many times each given substring can be found in the original string. Count overlaping cases.\n    For each substring you have to calculate the number of appearance in the passed string. \n\n    >>> find_substrings(\"\", [\"a\"])\n    [0]\n\n    >>> find_substrings(\"aaaa\", [\"a\", \"aa\", \"aaa\", \"aaaa\"])\n    [4, 3, 2, 1]\n\n    \"\"\"\n", "canonical_solution": "    counts = []\n    for substring in substrings: \n        times = 0\n        for i in range(len(string) - len(substring) + 1):\n            if string[i:i+len(substring)] == substring:\n                times += 1\n        counts.append(times)\n    return counts", "test": "\ndef check(candidate):\n    assert candidate(\"\", [\"x\"]) == [0]\n    assert candidate(\"xyxyxyx\", [\"x\", \"y\", \"xy\"]) == [4, 3, 3]\n    assert candidate(\"cacacacac\", [\"cac\", \"caca\", \"ca\"]) == [4, 3, 4]\n    assert candidate(\"john doe\", [\"john\", \"doe\", \"j\"]) == [1, 1, 1]\n", "entry_point": "find_substrings", "question": "Write a function def find_substrings(string: str, substrings: List[str]) -> List[int]: to solve the following problem:\nFinds how many times each given substring can be found in the original string. Count overlaping cases.\n    For each substring you have to calculate the number of appearance in the passed string. \n\n    >>> find_substrings(\"\", [\"a\"])\n    [0]\n\n    >>> find_substrings(\"aaaa\", [\"a\", \"aa\", \"aaa\", \"aaaa\"])\n    [4, 3, 2, 1]\n", "context": "from typing import List \n\ndef find_substrings(string: str, substrings: List[str]) -> List[int]:"}
{"key": 19, "prompt": "\nfrom typing import List\n\ndef sort_numbers(numbers: str, ascending: bool) -> str:\n    \"\"\" \n    Input is a space-delimited string of numerals from 'zero' to 'twenty'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve',\n    'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', and 'twenty'.\n    Additionally, a boolean value 'ascending' is given to decide the order of sorting. If 'ascending' is\n    True, the returned string will be sorted from smallest to largest, otherwise from largest to smallest. \n    For example:\n    >>> sort_numbers('three one five', True)\n    'one three five'\n    >>> sort_numbers('three one five', False)\n    'five three one'\n    \"\"\"\n", "canonical_solution": "\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9,\n        'ten': 10,\n        'eleven': 11,\n        'twelve': 12,\n        'thirteen': 13,\n        'fourteen': 14,\n        'fifteen': 15,\n        'sixteen': 16,\n        'seventeen': 17,\n        'eighteen': 18,\n        'nineteen': 19,\n        'twenty': 20\n    }\n    if ascending:\n        return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x]))\n    else:\n        return ' '.join(sorted([x for x in numbers.split(' ') if x], key=lambda x: value_map[x], reverse=True))\n", "test": "\ndef check(candidate):\n    assert candidate('one', True) == 'one'\n    assert candidate('three twenty fifteen', True) == 'three fifteen twenty'\n    assert candidate('twenty one two three five ten', False) == 'twenty ten five three two one'\n    assert candidate('sixteen ten one', True) == 'one ten sixteen'\n    assert candidate('eleven nine three', False) == 'eleven nine three'\n", "entry_point": "sort_numbers", "question": "Write a function def sort_numbers(numbers: str, ascending: bool) -> str: to solve the following problem:\nInput is a space-delimited string of numerals from 'zero' to 'twenty'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve',\n    'thirteen', 'fourteen', 'fifteen', 'sixteen', 'seventeen', 'eighteen', 'nineteen', and 'twenty'.\n    Additionally, a boolean value 'ascending' is given to decide the order of sorting. If 'ascending' is\n    True, the returned string will be sorted from smallest to largest, otherwise from largest to smallest. \n    For example:\n    >>> sort_numbers('three one five', True)\n    'one three five'\n    >>> sort_numbers('three one five', False)\n    'five three one'\n", "context": "from typing import List\n\ndef sort_numbers(numbers: str, ascending: bool) -> str:"}
{"key": 20, "prompt": "from typing import List, Tuple, Union\nfrom itertools import combinations\n\ndef find_closest_elements(numbers: List[Union[int, float]], n: int) -> List[Tuple[Union[int, float], Union[int, float]]]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return the n pairs of numbers that are  \n    the closest to each other and return them in order (smaller number, larger number).\n    If n positively exceeds the number of unique combinations, return all unique combinations.\n    If n is negative or zero, return an empty list.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2], 3)\n    [(2.0, 2.2), (3.0, 4.0), (1.0, 2.0)]\n    >>> find_closest_elements([1.0, 5.0, 3.1, 4.0, 5.0, 3.0], -2)\n    []\n    \"\"\"\n", "canonical_solution": "    if n <= 0:\n        return []\n    \n    pairs = list(combinations(numbers, 2))\n    closest_dist_pairs = []\n\n    # for pair in pairs:\n    #     distance = abs(pair[0] - pair[1])\n    #     heapq.heappush(closest_dist_pairs, (distance, tuple(sorted(pair))))\n    \n    # result = [heapq.heappop(closest_dist_pairs)[1] for _ in range(n) if closest_dist_pairs]\n    \n    for pair in pairs:\n        distance = abs(pair[0] - pair[1])\n        closest_dist_pairs.append((distance, tuple(sorted(pair))))\n    closest_dist_pairs.sort(key = lambda x: x[0])\n    result = [x[1] for x in closest_dist_pairs[:n]]\n\n    return result", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0, 4.5, 5.0, 2.2], 3) == [(2.0, 2.2), (4.5, 5.0), (2.2, 3.0)]\n    assert candidate([1.0, 5.0, 3.1, 4.0, 5.0, 3.9], 4) == [(5.0, 5.0), (3.9, 4.0), (3.1, 3.9), (3.1, 4.0)]\n    # assert candidate([1.0, 2.9, 3.1, 4.0, 5.0], 2) == [(2.9, 3.1), (1.0, 2.9)]\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0) == []\n    # assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 3) == [(2.2, 3.1), (3.1, 4.1), (4.1, 5.1)]\n    assert candidate([1.0, 5.0, 3.5, 4.0, 5.0, 3.0], -2) == []\n", "entry_point": "find_closest_elements", "question": "Write a function def find_closest_elements(numbers: List[Union[int, float]], n: int) -> List[Tuple[Union[int, float], Union[int, float]]]: to solve the following problem:\nFrom a supplied list of numbers (of length at least two) select and return the n pairs of numbers that are  \n    the closest to each other and return them in order (smaller number, larger number).\n    If n positively exceeds the number of unique combinations, return all unique combinations.\n    If n is negative or zero, return an empty list.\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2], 3)\n    [(2.0, 2.2), (3.0, 4.0), (1.0, 2.0)]\n    >>> find_closest_elements([1.0, 5.0, 3.1, 4.0, 5.0, 3.0], -2)\n    []\n", "context": "from typing import List, Tuple, Union\nfrom itertools import combinations\n\ndef find_closest_elements(numbers: List[Union[int, float]], n: int) -> List[Tuple[Union[int, float], Union[int, float]]]:"}
{"key": 21, "prompt": "\n\nfrom typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1. Additionally, after \n    the transformation, calculate the sum and average of all the elements in the list and return \n    them as a tuple along with the transformed list.\n\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    ([0.0, 0.25, 0.5, 0.75, 1.0], 2.5, 0.5)\n    \"\"\"\n", "canonical_solution": "\n\n    min_number = min(numbers)\n    max_number = max(numbers)\n    rescaled_numbers = [(x - min_number) / (max_number - min_number) for x in numbers]\n    sum_numbers = sum(rescaled_numbers)\n    avg_numbers = sum_numbers / len(numbers)\n    return rescaled_numbers, sum_numbers, avg_numbers\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([2.0, 49.9]) == ([0.0, 1.0], 1.0, 0.5)\n    assert candidate([100.0, 49.9]) == ([1.0, 0.0], 1.0, 0.5)\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0]) == ([0.0, 0.25, 0.5, 0.75, 1.0], 2.5, 0.5)\n    assert candidate([2.0, 1.0, 5.0, 3.0, 4.0]) == ([0.25, 0.0, 1.0, 0.5, 0.75], 2.5, 0.5)\n    assert candidate([12.0, 11.0, 15.0, 13.0, 14.0]) == ([0.25, 0.0, 1.0, 0.5, 0.75], 2.5, 0.5)\n\n", "entry_point": "rescale_to_unit", "question": "Write a function def rescale_to_unit(numbers: List[float]) -> List[float]: to solve the following problem:\nGiven list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1. Additionally, after \n    the transformation, calculate the sum and average of all the elements in the list and return \n    them as a tuple along with the transformed list.\n\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    ([0.0, 0.25, 0.5, 0.75, 1.0], 2.5, 0.5)\n", "context": "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:"}
{"key": 22, "prompt": "\nfrom typing import List, Any\n\ndef filter_types(values: List[Any], filter_type: type) -> List:\n    \"\"\"\n    Filter given list of any python values for values of the specified type\n    >>> filter_types(['a', 3.14, 5, 'hello', 'world', 42, 23.45, 'res',9.54], int)\n    [5, 42]\n    >>> filter_types([1, 2, 3, 'abc', {}, []], str)\n    ['abc']\n    >>> filter_types(['a', 'b', 2, 4.67, 'c', 'd',5.7], float)\n    [4.67, 5.7]\n    \"\"\"\n", "canonical_solution": "\n    return [x for x in values if isinstance(x, filter_type)]\n", "test": "\ndef check(candidate):\n    assert candidate([], int) == []\n    assert candidate(['a', 2.67, 'b', 4, 'c', 6.89, 'd'], str) == ['a', 'b', 'c', 'd']\n    assert candidate(['e',5.6,'f',7, 'g',8.9, 'h'], float) == [5.6, 8.9]\n    assert candidate(['i', '10.2', 'j', '11', 'k', '12.3', 'l'], int) == []\n", "entry_point": "filter_types", "question": "Write a function def filter_types(values: List[Any], filter_type: type) -> List: to solve the following problem:\nFilter given list of any python values for values of the specified type\n    >>> filter_types(['a', 3.14, 5, 'hello', 'world', 42, 23.45, 'res',9.54], int)\n    [5, 42]\n    >>> filter_types([1, 2, 3, 'abc', {}, []], str)\n    ['abc']\n    >>> filter_types(['a', 'b', 2, 4.67, 'c', 'd',5.7], float)\n    [4.67, 5.7]\n", "context": "from typing import List, Any\n\ndef filter_types(values: List[Any], filter_type: type) -> List:"}
{"key": 23, "prompt": "def strlen_add(string1: str, string2: str) -> str:\n    \"\"\" Return length sum of two given strings\n    >>> add_chars('abc', 'd')\n    4\n    \"\"\"\n", "canonical_solution": "\n    return len(string1 + string2)", "test": "def check(candidate):\n    assert candidate('abc', 'd') == 4\n    assert candidate('', 'z') == 1\n    assert candidate('x', 'y') == 2\n    assert candidate('hello', '!') == 6", "entry_point": "strlen_add", "question": "Write a function def strlen_add(string1: str, string2: str) -> str: to solve the following problem:\nReturn length sum of two given strings\n    >>> add_chars('abc', 'd')\n    4\n", "context": "def strlen_add(string1: str, string2: str) -> str:"}
{"key": 24, "prompt": "\n\ndef largest_prime_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest prime number that divides n evenly, smaller than n, return -1 if no such prime number exist\n    >>> largest_prime_divisor(15)\n    5\n    >>> largest_prime_divisor(11)\n    -1\n    \"\"\"\n", "canonical_solution": "    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    for i in reversed(range(2, n)):\n        if n % i == 0 and is_prime(i):\n            return i\n    return -1", "test": "\n\ndef check(candidate):\n    assert candidate(3) == -1\n    assert candidate(7) == -1\n    assert candidate(10) == 5\n    assert candidate(100) == 5\n    assert candidate(49) == 7\n    assert candidate(25) == 5\n    assert candidate(11) == -1\n    assert candidate(39) == 13\n\n", "entry_point": "largest_prime_divisor", "question": "Write a function def largest_prime_divisor(n: int) -> int: to solve the following problem:\nFor a given number n, find the largest prime number that divides n evenly, smaller than n, return -1 if no such prime number exist\n    >>> largest_prime_divisor(15)\n    5\n    >>> largest_prime_divisor(11)\n    -1\n", "context": "def largest_prime_divisor(n: int) -> int:"}
{"key": 25, "prompt": "\nfrom typing import List, Tuple\n\n\ndef extended_factorize(n: int) -> Tuple[int, List[int]]:\n    \"\"\" \n    Return tuple of two elements:\n    a) the number of distinct prime factors of given integer,\n    b) list of all prime factors of the given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    The input number should be equal to the product of all factors.\n    \n    >>> extended_factorize(8)\n    (1, [2, 2, 2])\n    >>> extended_factorize(25)\n    (1, [5, 5])\n    >>> extended_factorize(70)\n    (3, [2, 5, 7])\n    \"\"\"\n", "canonical_solution": "\n    import math\n    fact = []\n    distinct_count = 0\n    i = 2\n    while i <= math.sqrt(n):\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            if i not in fact:\n                distinct_count += 1\n            fact.append(i)\n    if n > 1:\n        if n not in fact:\n            distinct_count += 1\n        fact.append(n)\n    return distinct_count, fact\n", "test": "\ndef check(candidate):\n    assert candidate(2) == (1, [2])\n    assert candidate(4) == (1, [2, 2])\n    assert candidate(8) == (1, [2, 2, 2])\n    assert candidate(3 * 19) == (2, [3, 19])\n    assert candidate(3 * 19 * 3 * 19) == (2, [3, 3, 19, 19])\n    assert candidate(3 * 19 * 3 * 19 * 3 * 19) == (2, [3, 3, 3, 19, 19, 19])\n    assert candidate(3 * 19 * 19 * 19) == (2, [3, 19, 19, 19])\n    assert candidate(3 * 2 * 3) == (2, [2, 3, 3])\n    assert candidate(97) == (1, [97])\n    assert candidate(121) == (1, [11, 11])\n", "entry_point": "extended_factorize", "question": "Write a function def extended_factorize(n: int) -> Tuple[int, List[int]]: to solve the following problem:\nReturn tuple of two elements:\n    a) the number of distinct prime factors of given integer,\n    b) list of all prime factors of the given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appears in factorization.\n    The input number should be equal to the product of all factors.\n    \n    >>> extended_factorize(8)\n    (1, [2, 2, 2])\n    >>> extended_factorize(25)\n    (1, [5, 5])\n    >>> extended_factorize(70)\n    (3, [2, 5, 7])\n", "context": "from typing import List, Tuple\n\n\ndef extended_factorize(n: int) -> Tuple[int, List[int]]:"}
{"key": 26, "prompt": "\n\nfrom typing import List\n\n\ndef remove_duplicates_keep_order(numbers: List[int]) -> List[int]:\n    \"\"\" \n    From a list of integers, remove all elements that occur more than once.\n    Keep the order of the elements same as the original input and the order of the unique elements \n    similar to their appearance in the original list.\n    >>> remove_duplicates_keep_order([1, 2, 3, 2, 4, 3, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n", "canonical_solution": "    result = []\n    seen = set()\n    for number in numbers:\n        if number not in seen:\n            seen.add(number)\n            result.append(number)\n    return result", "test": "\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([1, 2, 3, 2, 4, 3, 5]) == [1, 2, 3, 4, 5]\n    assert candidate([1, 1, 2, 2, 3, 3]) == [1, 2, 3]\n\n", "entry_point": "remove_duplicates_keep_order", "question": "Write a function def remove_duplicates_keep_order(numbers: List[int]) -> List[int]: to solve the following problem:\nFrom a list of integers, remove all elements that occur more than once.\n    Keep the order of the elements same as the original input and the order of the unique elements \n    similar to their appearance in the original list.\n    >>> remove_duplicates_keep_order([1, 2, 3, 2, 4, 3, 5])\n    [1, 2, 3, 4, 5]\n", "context": "from typing import List\n\n\ndef remove_duplicates_keep_order(numbers: List[int]) -> List[int]:"}
{"key": 27, "prompt": "\n\ndef flip_case(string: str, use_map: bool=False) -> str:\n    \"\"\" \n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    Optionally, instead of using the 'swapcase' function, use a map for the fliping process.\n\n    >>> flip_case('Hello')\n    'hELLO'\n    >>> flip_case('Hello', True)\n    'hELLO'\n    \"\"\"\n", "canonical_solution": "    if use_map:\n        return ''.join(chr(ord(c) ^ 32) if c.isalpha() else c for c in string)    \n    return string.swapcase()", "test": "\n\ndef check(candidate):\n    assert candidate('') == ''\n    assert candidate('', True) == ''\n    assert candidate('Hello!') == 'hELLO!'\n    assert candidate('Hello!', True) == 'hELLO!'\n    assert candidate('These violent delights have violent ends') == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n    assert candidate('These violent delights have violent ends', True) == 'tHESE VIOLENT DELIGHTS HAVE VIOLENT ENDS'\n\n", "entry_point": "flip_case", "question": "Write a function def flip_case(string: str, use_map: bool=False) -> str: to solve the following problem:\nFor a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    Optionally, instead of using the 'swapcase' function, use a map for the fliping process.\n\n    >>> flip_case('Hello')\n    'hELLO'\n    >>> flip_case('Hello', True)\n    'hELLO'\n", "context": "def flip_case(string: str, use_map: bool=False) -> str:"}
{"key": 28, "prompt": "\n\nfrom typing import List\n\n\ndef concatenate(strings: List[str], delim: str) -> str:\n    \"\"\" Concatenates list of strings into a single string separated by a delimiter.\n    >>> concatenate([], '_')\n    ''\n    >>> concatenate(['a', 'b', 'c'], '_')\n    'a_b_c'\n    >>> concatenate(['a', 'b', 'c', 'd'], '_')\n    'a_b_c_d'\n    \"\"\"\n", "canonical_solution": "\n\n    return delim.join(strings)\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([], '_') == ''\n    assert candidate(['x', 'y', 'z'], '_') == 'x_y_z'\n    assert candidate(['x', 'y', 'z', 'w', 'k'], '_') == 'x_y_z_w_k'\n    assert candidate(['apple', 'banana', 'cherry'], ', ') == 'apple, banana, cherry'\n    assert candidate(['sun', 'moon', 'star'], ' - ') == 'sun - moon - star'\n\n", "entry_point": "concatenate", "question": "Write a function def concatenate(strings: List[str], delim: str) -> str: to solve the following problem:\nConcatenates list of strings into a single string separated by a delimiter.\n    >>> concatenate([], '_')\n    ''\n    >>> concatenate(['a', 'b', 'c'], '_')\n    'a_b_c'\n    >>> concatenate(['a', 'b', 'c', 'd'], '_')\n    'a_b_c_d'\n", "context": "from typing import List\n\n\ndef concatenate(strings: List[str], delim: str) -> str:"}
{"key": 29, "prompt": "\n\nfrom typing import List, Optional\n\n\ndef filter_by_prefix_suffix(strings: List[str], prefix: Optional[str] = None, suffix: Optional[str] = None) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix and end with a given suffix.\n    Both prefix and suffix parameters are optional, if they are not provided, return the list as it is. If both are provided, a string should start with prefix and end with suffix to be included in the result.\n    If a string starts with prefix but does not end with suffix or vice versa, it should not be in the result.\n\n    >>> filter_by_prefix_suffix([], 'a')    \n    []\n\n    >>> filter_by_prefix_suffix(['abc', 'bcd', 'cde', 'array'], 'a')  \n    ['abc', 'array']\n\n    >>> filter_by_prefix_suffix(['abc', 'abcd', 'abcde', 'abcdef'], 'a', 'd')  \n    ['abcd']\n\n    >>> filter_by_prefix_suffix(['abc', 'abcd', 'abcde', 'abcdef'])  # Neither prefix nor suffix is provided\n    ['abc', 'abcd', 'abcde', 'abcdef']\n    \"\"\"\n", "canonical_solution": "\n\n    return [x for x in strings if (prefix is None or x.startswith(prefix)) and (suffix is None or x.endswith(suffix))]\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxxXYZ'], 'xxx', 'AAA') == ['xxxAAA']\n    assert candidate(['xyzAAA', 'yzzAAA', 'zzzAAA', 'xyzBBB'], None, 'AAA') == ['xyzAAA', 'yzzAAA', 'zzzAAA']\n    assert candidate(['xyzAAA', 'xyzBBB', 'xyyAAA'], 'xyz') == ['xyzAAA', 'xyzBBB']\n    assert candidate(['xyzAAA', 'xyzBBB', 'xyzCCC']) == ['xyzAAA', 'xyzBBB', 'xyzCCC']\n\n", "entry_point": "filter_by_prefix_suffix", "question": "Write a function def filter_by_prefix_suffix(strings: List[str], prefix: Optional[str] = None, suffix: Optional[str] = None) -> List[str]: to solve the following problem:\nFilter an input list of strings only for ones that start with a given prefix and end with a given suffix.\n    Both prefix and suffix parameters are optional, if they are not provided, return the list as it is. If both are provided, a string should start with prefix and end with suffix to be included in the result.\n    If a string starts with prefix but does not end with suffix or vice versa, it should not be in the result.\n\n    >>> filter_by_prefix_suffix([], 'a')    \n    []\n\n    >>> filter_by_prefix_suffix(['abc', 'bcd', 'cde', 'array'], 'a')  \n    ['abc', 'array']\n\n    >>> filter_by_prefix_suffix(['abc', 'abcd', 'abcde', 'abcdef'], 'a', 'd')  \n    ['abcd']\n\n    >>> filter_by_prefix_suffix(['abc', 'abcd', 'abcde', 'abcdef'])  # Neither prefix nor suffix is provided\n    ['abc', 'abcd', 'abcde', 'abcdef']\n", "context": "from typing import List, Optional\n\n\ndef filter_by_prefix_suffix(strings: List[str], prefix: Optional[str] = None, suffix: Optional[str] = None) -> List[str]:"}
{"key": 30, "prompt": "\n\n\ndef get_positive_and_negative(l: list):\n    \"\"\"Return two lists: the first with only positive numbers in the input list, and the second with only negative numbers.\n    >>> get_positive_and_negative([-1, 2, -4, 5, 6])\n    ([2, 5, 6], [-1, -4])\n    >>> get_positive_and_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    ([5, 3, 2, 3, 9, 123, 1], [-5, -3, -10])\n    \"\"\"\n", "canonical_solution": "\n\n    return [e for e in l if e > 0], [e for e in l if e < 0]\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([-1, -2, 4, 5, 6]) == ([4, 5, 6], [-1, -2])\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == ([5, 3, 2, 3, 9, 123, 1], [-5, -3, -10])\n    assert candidate([-1, -2]) == ([], [-1, -2])\n    assert candidate([]) == ([], [])\n\n", "entry_point": "get_positive_and_negative", "question": "Write a function def get_positive_and_negative(l: list): to solve the following problem:\nReturn two lists: the first with only positive numbers in the input list, and the second with only negative numbers.\n    >>> get_positive_and_negative([-1, 2, -4, 5, 6])\n    ([2, 5, 6], [-1, -4])\n    >>> get_positive_and_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    ([5, 3, 2, 3, 9, 123, 1], [-5, -3, -10])\n", "context": "def get_positive_and_negative(l: list):"}
{"key": 31, "prompt": "\n\ndef is_prime_and_factor_count(n):\n    \"\"\"Return a list, [a, b] where a is a boolean indicating if a given number is a prime and b is the number of factors for non-prime numbers, and false otherwise.\n    >>> is_prime_and_factor_count(6)\n    [False, 4]\n    >>> is_prime_and_factor_count(101)\n    [True, 0]\n    >>> is_prime_and_factor_count(11)\n    [True, 0]\n    >>> is_prime_and_factor_count(13441)\n    [True, 0]\n    >>> is_prime_and_factor_count(61)\n    [True, 0]\n    >>> is_prime_and_factor_count(4)\n    [False, 3]\n    >>> is_prime_and_factor_count(1)\n    [False, 1]\n    >>> is_prime_and_factor_count(49)\n    [False, 3]\n    \"\"\"\n", "canonical_solution": "    factors = [i for i in range(1,n+1) if n%i == 0]\n    if len(factors) == 2:\n        return [True, 0]\n    else:\n        return [False, len(factors)]", "test": "\n\ndef check(candidate):\n    assert candidate(6) == [False, 4] \n    assert candidate(101) == [True, 0]\n    assert candidate(11) == [True, 0]\n    assert candidate(13441) == [True, 0]\n    assert candidate(61) == [True, 0]\n    assert candidate(4) == [False, 3]\n    assert candidate(1) == [False, 1]\n    assert candidate(5) == [True, 0]\n    assert candidate(7) == [True, 0]\n    assert candidate(49) == [False, 3]\n    assert candidate(17) == [True, 0]\n    assert candidate(5 * 17) == [False, 4]\n    assert candidate(11 * 7) == [False, 4]\n    assert candidate(13441 * 19) == [False, 4]\n\n", "entry_point": "is_prime_and_factor_count", "question": "Write a function def is_prime_and_factor_count(n): to solve the following problem:\nReturn a list, [a, b] where a is a boolean indicating if a given number is a prime and b is the number of factors for non-prime numbers, and false otherwise.\n    >>> is_prime_and_factor_count(6)\n    [False, 4]\n    >>> is_prime_and_factor_count(101)\n    [True, 0]\n    >>> is_prime_and_factor_count(11)\n    [True, 0]\n    >>> is_prime_and_factor_count(13441)\n    [True, 0]\n    >>> is_prime_and_factor_count(61)\n    [True, 0]\n    >>> is_prime_and_factor_count(4)\n    [False, 3]\n    >>> is_prime_and_factor_count(1)\n    [False, 1]\n    >>> is_prime_and_factor_count(49)\n    [False, 3]\n", "context": "def is_prime_and_factor_count(n):"}
{"key": 32, "prompt": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef modified_find_zero(xs:list, y:float):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    y is a constant\n    modifed_find_zero find x such that poly(x) = y.\n    modifed_find_zero returns only one point, even if there are many.\n    Moreover, modifed_find_zero only takes list xs having even and nonzero\n    coefficients as it guarantees a solution.\n    >>> round(modified_find_zero([1, 2],1), 2) # f(x) = 1 + 2x\n    0.0\n    >>> round(modified_find_zero([-6, 11, -6, 1],0), 2)\n    1.0\n    \"\"\"\n", "canonical_solution": "    begin, end = -1., 1.\n    while (poly(xs, begin) - y) * (poly(xs, end) - y) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while end - begin > 1e-10:\n        center = (begin + end) / 2.0\n        if (poly(xs, center) - y) * (poly(xs, begin) - y) > 0:\n            begin = center\n        else:\n            end = center\n    return begin", "test": "def check(candidate):\n    import math\n    import random\n    rng = random.Random(42)\n    import copy\n    for _ in range(100):\n        ncoeff = 2 * rng.randint(1, 3)\n        coeffs = []\n        for _ in range(ncoeff):\n            coeff = rng.randint(-10, 10)\n            if coeff == 0:\n                coeff = 1\n            coeffs.append(coeff)\n        y = rng.randint(-50,50)\n        solution = candidate(copy.deepcopy(coeffs), y)\n        assert math.fabs(poly(coeffs, solution) - y) < 1e-4", "entry_point": "modified_find_zero", "question": "Write a function def modified_find_zero(xs:list, y:float): to solve the following problem:\nxs are coefficients of a polynomial.\n    y is a constant\n    modifed_find_zero find x such that poly(x) = y.\n    modifed_find_zero returns only one point, even if there are many.\n    Moreover, modifed_find_zero only takes list xs having even and nonzero\n    coefficients as it guarantees a solution.\n    >>> round(modified_find_zero([1, 2],1), 2) # f(x) = 1 + 2x\n    0.0\n    >>> round(modified_find_zero([-6, 11, -6, 1],0), 2)\n    1.0\n", "context": "import math\n\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef modified_find_zero(xs:list, y:float):"}
{"key": 33, "prompt": "\n\ndef sort_third_fifth(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that l' is identical to l in \n    the indices that are not divisible by both three and five, while its values at the \n    indices that are divisible by both three and five are equal to the values of the \n    corresponding indices of l, but sorted.\n    \n    >>> sort_third_fifth([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15]\n    >>> sort_third_fifth([5, 14, 100, 25, -20, 30, 2, 70, 45, 90, -15])\n    [5, 14, -15, 25, -20, 30, 2, 70, 45, 90, 100]\n    \"\"\"\n", "canonical_solution": "    l = list(l)\n    indices = [i for i in range(len(l)) if (i % 3 == 0) and (i % 5 == 0)]\n    elements = sorted([l[i] for i in indices])\n    for i, el in zip(indices, elements):\n        l[i] = el\n    return l", "test": "\n\ndef check(candidate):\n    assert tuple(candidate([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15])) == tuple(sort_third_fifth([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15]))\n    assert tuple(candidate([5, 14, 100, 25, -20, 30, 2, 70, 45, 90, -15])) == tuple(sort_third_fifth([5, 14, 100, 25, -20, 30, 2, 70, 45, 90, -15]))\n    assert tuple(candidate([25, 100, 30, -15, 45, 90, 5, 14, 2, 70])) == tuple(sort_third_fifth([25, 100, 30, -15, 45, 90, 5, 14, 2, 70]))\n    assert tuple(candidate([5, 14, 100, 25, -20, 30, 2, 70, 45, 90, -15, 0])) == tuple(sort_third_fifth([5, 14, 100, 25, -20, 30, 2, 70, 45, 90, -15, 0]))\n    assert tuple(candidate([5, 14, 100, 25, -20, 30, 2, 60, 45, 90, -15, 0])) == tuple(sort_third_fifth([5, 14, 100, 25, -20, 30, 2, 60, 45, 90, -15, 0]))\n\n", "entry_point": "sort_third_fifth", "question": "Write a function def sort_third_fifth(l: list): to solve the following problem:\nThis function takes a list l and returns a list l' such that l' is identical to l in \n    the indices that are not divisible by both three and five, while its values at the \n    indices that are divisible by both three and five are equal to the values of the \n    corresponding indices of l, but sorted.\n    \n    >>> sort_third_fifth([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15]\n    >>> sort_third_fifth([5, 14, 100, 25, -20, 30, 2, 70, 45, 90, -15])\n    [5, 14, -15, 25, -20, 30, 2, 70, 45, 90, 100]\n", "context": "def sort_third_fifth(l: list):"}
{"key": 34, "prompt": "\n\ndef unique(l: list, descending: bool) -> list: \n    \"\"\"Return sorted unique elements in a list. If descending is True, sort the list in descending order\n    If descending is False, sort in ascending order.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], True)\n    [123, 9, 5, 3, 2, 0]\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], False)\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n", "canonical_solution": "\n\n    unique_list = list(set(l))\n    return sorted(unique_list, reverse=descending)\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123], True) == [123, 9, 5, 3, 2, 0]\n    assert candidate([5, 3, 5, 2, 3, 3, 9, 0, 123], False) == [0, 2, 3, 5, 9, 123]\n\n\n", "entry_point": "unique", "question": "Write a function def unique(l: list, descending: bool) -> list: to solve the following problem:\nReturn sorted unique elements in a list. If descending is True, sort the list in descending order\n    If descending is False, sort in ascending order.\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], True)\n    [123, 9, 5, 3, 2, 0]\n    \n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123], False)\n    [0, 2, 3, 5, 9, 123]\n", "context": "def unique(l: list, descending: bool) -> list:"}
{"key": 35, "prompt": "\n\ndef find_max_min_sum(l: list):\n    \"\"\"Return maximum and minimum elements and the sum of all elements in the list.\n    >>> find_max_min_sum([1, 2, 3])\n    (3, 1, 6)\n    >>> find_max_min_sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    (123, -10, 128)\n    \"\"\"\n", "canonical_solution": "\n\n    max_elem = l[0]\n    min_elem = l[0]\n    sum_elem = l[0]\n    for e in l[1:]:\n        if e > max_elem:\n            max_elem = e\n        if e < min_elem:\n            min_elem = e\n        sum_elem += e\n    return max_elem, min_elem, sum_elem\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([1, 2, 3]) == (3, 1, 6)\n    assert candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10]) == (123, -10, 128)\n\n", "entry_point": "find_max_min_sum", "question": "Write a function def find_max_min_sum(l: list): to solve the following problem:\nReturn maximum and minimum elements and the sum of all elements in the list.\n    >>> find_max_min_sum([1, 2, 3])\n    (3, 1, 6)\n    >>> find_max_min_sum([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    (123, -10, 128)\n", "context": "def find_max_min_sum(l: list):"}
{"key": 36, "prompt": "def fizz_buzz_plus(n: int, dig: int, divs: list):\n    \"\"\"\n    Return the number of times the digit 'dig' appears in integers less than n which is divisible by any number in divs.\n    Among the divisors, assume that they are all prime numbers.\n    \n    :param n: integer, upper limit number\n    :param dig: integer, target digit\n    :param divs: list of integers, divisor list, which are all prime numbers\n    >>> fizz_buzz_plus(50, 7, [11, 13])\n    0\n    >>> fizz_buzz_plus(78, 7, [11, 13])\n    2\n    >>> fizz_buzz_plus(79, 7, [11, 13])\n    3\n    \"\"\"\n", "canonical_solution": "\n    ns = []\n    for i in range(n):\n        if any(i % div == 0 for div in divs):\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == str(dig))\n    return ans", "test": "def check(candidate):\n    assert candidate(50, 7, [11, 13]) == 0\n    assert candidate(78, 7, [11, 13]) == 2\n    assert candidate(79, 7, [11, 13]) == 3\n    assert candidate(100, 7, [11, 13]) == 3\n    assert candidate(200, 7, [11, 13]) == 6\n    assert candidate(4000, 7, [11, 13]) == 192\n    assert candidate(10000, 7, [11, 13]) == 639\n    assert candidate(100000, 7, [11, 13]) == 8026\n    assert candidate(80, 5, [7, 11]) == 4\n    assert candidate(150, 2, [7, 13, 17]) == 8\n    assert candidate(550, 3, [3, 5, 7]) == 111", "entry_point": "fizz_buzz_plus", "question": "Write a function def fizz_buzz_plus(n: int, dig: int, divs: list): to solve the following problem:\nReturn the number of times the digit 'dig' appears in integers less than n which is divisible by any number in divs.\n    Among the divisors, assume that they are all prime numbers.\n    \n    :param n: integer, upper limit number\n    :param dig: integer, target digit\n    :param divs: list of integers, divisor list, which are all prime numbers\n    >>> fizz_buzz_plus(50, 7, [11, 13])\n    0\n    >>> fizz_buzz_plus(78, 7, [11, 13])\n    2\n    >>> fizz_buzz_plus(79, 7, [11, 13])\n    3\n", "context": "def fizz_buzz_plus(n: int, dig: int, divs: list):"}
{"key": 37, "prompt": "def sort_even_and_odd(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the multiples of 3 indices, while its values at the even indices except multiples of 3 are equal\n    to the values of the even indices of l, but in the descending sorted order, and the odd indices' values are equal\n    to the values of the odd indices of l, but in the ascending sorted order.\n    >>> sort_even_and_odd([1, 2, 3, -3, -2, -1])\n    [1, -1, 3, -3, -2, 2]\n    >>> sort_even_and_odd([5, 6, 3, 4, 2, 0])\n    [5, 0, 3, 4, 2, 6]\n    \"\"\"\n", "canonical_solution": "\n    evens = sorted([v for i, v in enumerate(l) if i%2==0 and i%3!=0], reverse=True)\n    odds = sorted([v for i, v in enumerate(l) if i%2!=0 and i%3!=0])\n    multiples_3 = [v for i, v in enumerate(l) if i%3==0]\n\n    ans = []\n    i = j = k = 0\n    for index in range(len(l)):\n        if index%3==0:\n            ans.append(multiples_3[i])\n            i+=1\n        elif index%2==0:\n            ans.append(evens[j])\n            j+=1\n        else:\n            ans.append(odds[k])\n            k+=1\n    return ans", "test": "def check(candidate):\n    assert tuple(candidate([1, 2, 3, -3, -2, -1])) == tuple([1, -1, 3, -3, -2, 2])\n    assert tuple(candidate([5, 6, 3, 4, 2, 0])) == tuple([5, 0, 3, 4, 2, 6])\n    assert tuple(candidate([5, 3, -5, 2, -3, 3, 9, 0, 123, 2, -12, 7, -10])) == tuple([5, 0, 123, 2, -3, 3, 9, 3, -5, 2, -12, 7, -10])", "entry_point": "sort_even_and_odd", "question": "Write a function def sort_even_and_odd(l: list): to solve the following problem:\nThis function takes a list l and returns a list l' such that\n    l' is identical to l in the multiples of 3 indices, while its values at the even indices except multiples of 3 are equal\n    to the values of the even indices of l, but in the descending sorted order, and the odd indices' values are equal\n    to the values of the odd indices of l, but in the ascending sorted order.\n    >>> sort_even_and_odd([1, 2, 3, -3, -2, -1])\n    [1, -1, 3, -3, -2, 2]\n    >>> sort_even_and_odd([5, 6, 3, 4, 2, 0])\n    [5, 0, 3, 4, 2, 6]\n", "context": "def sort_even_and_odd(l: list):"}
{"key": 38, "prompt": "\ndef encode_double_cyclic(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of four characters twice.\n    \"\"\"\n    # split string to groups. Each of length 4.\n    groups = [s[(4 * i):min((4 * i + 4), len(s))] for i in range((len(s) + 3) // 4)]\n    # cycle elements in each group twice. Unless group has fewer elements than 4.\n    groups = [(group[2:] + group[:2]) if len(group) == 4 else group for group in groups]\n    return \"\".join(groups)\n\ndef decode_double_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_double_cyclic function. Returns decoded string.\n    \"\"\"\n", "canonical_solution": "\n    # To decode, cycle in reverse direction; same as encoding twice\n    return encode_double_cyclic(encode_double_cyclic(s))\n", "test": "\ndef check(candidate):\n    from random import randint, choice\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(20, 40)))\n        encoded_str = encode_double_cyclic(str)\n        assert candidate(encoded_str) == str\n", "entry_point": "encode_double_cyclic", "question": "Write a function def encode_double_cyclic(s: str): to solve the following problem:\nreturns encoded string by cycling groups of four characters twice.\n", "context": "def encode_double_cyclic(s: str):"}
{"key": 39, "prompt": "\ndef prime_fib_sum(n: int, m: int):\n    \"\"\"\n    prime_fib_sum returns the sum of numbers from the n-th to m-th that are Fibonacci numbers and also prime.\n    >>> prime_fib_sum(1, 3)\n    10\n    >>> prime_fib_sum(2, 4)\n    21\n    >>> prime_fib_sum(3, 5)\n    107\n    >>> prime_fib_sum(4, 6)\n    335\n    >>> prime_fib_sum(5, 7)\n    1819\n    \"\"\"\n", "canonical_solution": "\nimport math\n\ndef is_prime(p):\n    if p < 2:\n        return False\n    for k in range(2, min(int(math.sqrt(p)) + 1, p - 1)):\n        if p % k == 0:\n            return False\n    return True\n\ndef prime_fib_sum(n, m):\n    f = [0, 1]\n    prime_fibs = []\n    while len(prime_fibs) < m:\n        f.append(f[-1] + f[-2])\n        if is_prime(f[-1]):\n            prime_fibs.append(f[-1])\n    return sum(prime_fibs[n-1:m])\n", "test": "\ndef check(candidate):\n    assert candidate(1, 3) == 2+3+5\n    assert candidate(2, 4) == 3+5+13\n    assert candidate(3, 5) == 5+13+89\n    assert candidate(4, 6) == 13+89+233\n    assert candidate(5, 7) == 89+233+1597\n    assert candidate(6, 8) == 233+1597+28657\n    assert candidate(7, 9) == 1597+28657+514229\n    assert candidate(8, 10) == 28657+514229+433494437\n", "entry_point": "prime_fib_sum", "question": "Write a function def prime_fib_sum(n: int, m: int): to solve the following problem:\nprime_fib_sum returns the sum of numbers from the n-th to m-th that are Fibonacci numbers and also prime.\n    >>> prime_fib_sum(1, 3)\n    10\n    >>> prime_fib_sum(2, 4)\n    21\n    >>> prime_fib_sum(3, 5)\n    107\n    >>> prime_fib_sum(4, 6)\n    335\n    >>> prime_fib_sum(5, 7)\n    1819\n", "context": "def prime_fib_sum(n: int, m: int):"}
{"key": 40, "prompt": "\ndef four_tuples_sum_to_zero(l: list):\n    \"\"\"\n    four_tuples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are four distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> four_tuples_sum_to_zero([1, 3, 5, 0, -1])\n    False\n    >>> four_tuples_sum_to_zero([1, 3, -2, 1, -2])\n    True\n    >>> four_tuples_sum_to_zero([1, 2, 3, 7, -5])\n    False\n    >>> four_tuples_sum_to_zero([2, 4, -5, 3, 9, 7, -7])\n    True\n    >>> four_tuples_sum_to_zero([1, 0, 0, 0, 15])\n    False\n    \"\"\"\n", "canonical_solution": "    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                for m in range(k + 1, len(l)):\n                    if l[i] + l[j] + l[k] + l[m] == 0:\n                        return True\n    return False", "test": "\ndef check(candidate):\n    assert candidate([1, 3, 5, 0, -1]) == False\n    assert candidate([1, 3, -2, 1, -2]) == True\n    assert candidate([1, 2, 3, 7, -5]) == False\n    assert candidate([2, 4, -5, 3, 9, 7, -7]) == True\n    assert candidate([1, 0, 0, 0, 15]) == False\n    assert candidate([1, -1, 2, -2, 3, -3, 4, -4]) == True\n    assert candidate([100, 200, -300, -50, 50]) == False\n    assert candidate([100, 200, -300, -50, 51]) == False\n    assert candidate([1, 0, 0, 0, -1]) == True\n", "entry_point": "four_tuples_sum_to_zero", "question": "Write a function def four_tuples_sum_to_zero(l: list): to solve the following problem:\nfour_tuples_sum_to_zero takes a list of integers as an input.\n    it returns True if there are four distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> four_tuples_sum_to_zero([1, 3, 5, 0, -1])\n    False\n    >>> four_tuples_sum_to_zero([1, 3, -2, 1, -2])\n    True\n    >>> four_tuples_sum_to_zero([1, 2, 3, 7, -5])\n    False\n    >>> four_tuples_sum_to_zero([2, 4, -5, 3, 9, 7, -7])\n    True\n    >>> four_tuples_sum_to_zero([1, 0, 0, 0, 15])\n    False\n", "context": "def four_tuples_sum_to_zero(l: list):"}
{"key": 41, "prompt": "\ndef car_race_collision_mania(n: int, m: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide. \n\n    This time, imagine there are m such infinitely long roads parallel to each other. On each road,\n    the exact same scenario of car collisions happen as described above.\n\n    This function outputs the number of such collisions on m roads.\n    \"\"\"\n", "canonical_solution": "\n    return m*(n**2)\n", "test": "\ndef check(candidate):\n    assert candidate(2, 2) == 8\n    assert candidate(3, 3) == 27\n    assert candidate(4, 4) == 64\n    assert candidate(8, 2) == 128\n    assert candidate(10, 3) == 300\n", "entry_point": "car_race_collision_mania", "question": "Write a function def car_race_collision_mania(n: int, m: int): to solve the following problem:\nImagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide. \n\n    This time, imagine there are m such infinitely long roads parallel to each other. On each road,\n    the exact same scenario of car collisions happen as described above.\n\n    This function outputs the number of such collisions on m roads.\n", "context": "def car_race_collision_mania(n: int, m: int):"}
{"key": 42, "prompt": "\n\ndef incr_list_multilayer(l: list):\n    \"\"\"Return list with elements incremented by 1. If the elements are list, increment each members of the list by 1.\n    >>> incr_list_multilayer([1, 2, 3])\n    [2, 3, 4]\n    \n    >>> incr_list_multilayer([5, 3, [5, 2, 3, 3, 9, 0, 123]])\n    [6, 4, [6, 3, 4, 4, 10, 1, 124]]\n    \"\"\"\n", "canonical_solution": "    new_list = []\n    for e in l:\n        if type(e) is list:\n            new_list += [incr_list_multilayer(e)]\n        else:\n            new_list += [e+1]\n    return new_list", "test": "\n\ndef check(candidate):\n    assert candidate([]) == []\n    assert candidate([3, 2, 1]) == [4, 3, 2]\n    assert candidate([5, 2, 5, 2, [3, 3, 9, 0, 123]]) == [6, 3, 6, 3, [4, 4, 10, 1, 124]]\n    assert candidate([1, [2, [3]]]) == [2, [3, [4]]]\n\n", "entry_point": "incr_list_multilayer", "question": "Write a function def incr_list_multilayer(l: list): to solve the following problem:\nReturn list with elements incremented by 1. If the elements are list, increment each members of the list by 1.\n    >>> incr_list_multilayer([1, 2, 3])\n    [2, 3, 4]\n    \n    >>> incr_list_multilayer([5, 3, [5, 2, 3, 3, 9, 0, 123]])\n    [6, 4, [6, 3, 4, 4, 10, 1, 124]]\n", "context": "def incr_list_multilayer(l: list):"}
{"key": 43, "prompt": "\ndef pairs_sum_to_zero_extended(list_el, zero_sum):\n    \"\"\"\n    pairs_sum_to_zero_extended takes a list of integers and an integer sum as input.\n    it returns True if there are three distinct elements in the list that\n    sum to the given sum, and False otherwise. The function only returns `True` when three numbers sum to\n    the given sum, even if two numbers in the list sum to the given sum it should return `False`.\n    And the function should not return True for triplets containing duplicate elements.\n    >>> pairs_sum_to_zero_extended([-1, 0, 1, 2, -1, -4], 1)\n    True\n    >>> pairs_sum_to_zero_extended([1, 3, -2, 1], 0)\n    True\n    >>> pairs_sum_to_zero_extended([1, 2, 3, 7], 10)\n    True\n    >>> pairs_sum_to_zero_extended([2, 4, -2, 3, 5, 7], 7)\n    True\n    >>> pairs_sum_to_zero_extended([1], 0)\n    False\n    \"\"\"\n", "canonical_solution": "\n    list_el.sort()\n    n = len(list_el)\n    for i in range(0, n-2):\n        l = i + 1\n        r = n - 1\n        for j in range(i+1,n-1):\n            for k in range(j+1,n):\n                if (list_el[i] + list_el[j] + list_el[k] == zero_sum):\n                    return True\n\n    return False\n", "test": "def check(candidate):\n    assert candidate([-1, 0, 1, 2, -1, -4], 1) == True\n    assert candidate([1, 3, -2, 1], 0) == True\n    assert candidate([1, 2, 3, 7], 10) == True\n    assert candidate([2, 4, -2, 3, 5, 7], 7) == True\n    assert candidate([1], 0) == False\n\n    assert candidate([1, 4, -3, 7, -2, 6, -1, 6, 0], 6) == True\n    assert candidate([1, 4, 7, 2, 6, -1, 6, 0], 13) == True\n    assert candidate([1, 4, 7, 2, 6, 6, 0], 15) == True\n    assert candidate([1, 3, -1, 2, -1, 5], 3) == True\n", "entry_point": "pairs_sum_to_zero_extended", "question": "Write a function def pairs_sum_to_zero_extended(list_el, zero_sum): to solve the following problem:\npairs_sum_to_zero_extended takes a list of integers and an integer sum as input.\n    it returns True if there are three distinct elements in the list that\n    sum to the given sum, and False otherwise. The function only returns `True` when three numbers sum to\n    the given sum, even if two numbers in the list sum to the given sum it should return `False`.\n    And the function should not return True for triplets containing duplicate elements.\n    >>> pairs_sum_to_zero_extended([-1, 0, 1, 2, -1, -4], 1)\n    True\n    >>> pairs_sum_to_zero_extended([1, 3, -2, 1], 0)\n    True\n    >>> pairs_sum_to_zero_extended([1, 2, 3, 7], 10)\n    True\n    >>> pairs_sum_to_zero_extended([2, 4, -2, 3, 5, 7], 7)\n    True\n    >>> pairs_sum_to_zero_extended([1], 0)\n    False\n", "context": "def pairs_sum_to_zero_extended(list_el, zero_sum):"}
{"key": 44, "prompt": "\n\ndef change_base(x: int, base: int, padding: int = 0):\n    \"\"\"\n    Change numerical base of input number x to base and pad it to ensure it has at least `padding` digits.\n    Return string representation after the conversion.\n    base numbers are less than 10.\n    padding helps to return a fixed length string. If length of converted number is less than padding, \n    zeroes will be added at the beginning. By default padding is zero.\n    \n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 3, 4)\n    '0022'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2, 5)\n    '00111'\n    \"\"\"\n", "canonical_solution": "    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x //= base\n    return ret.rjust(padding, '0')", "test": "\n\ndef check(candidate):\n    assert candidate(8, 3) == \"22\"\n    assert candidate(9, 3) == \"100\"\n    assert candidate(234, 2) == \"11101010\"\n    assert candidate(16, 2) == \"10000\"\n    assert candidate(8, 2) == \"1000\"\n    assert candidate(7, 2) == \"111\"\n    for x in range(2, 8):\n        assert candidate(x, x + 1) == str(x)\n    assert candidate(8, 3, 4) == \"0022\"\n    assert candidate(16, 2, 5) == \"10000\"\n    assert candidate(7, 2, 5) == \"00111\"\n\n", "entry_point": "change_base", "question": "Write a function def change_base(x: int, base: int, padding: int = 0): to solve the following problem:\nChange numerical base of input number x to base and pad it to ensure it has at least `padding` digits.\n    Return string representation after the conversion.\n    base numbers are less than 10.\n    padding helps to return a fixed length string. If length of converted number is less than padding, \n    zeroes will be added at the beginning. By default padding is zero.\n    \n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 3, 4)\n    '0022'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2, 5)\n    '00111'\n", "context": "def change_base(x: int, base: int, padding: int = 0):"}
{"key": 45, "prompt": "\n\ndef triangle_area(a, h):\n    \"\"\"Given length of a side a and height h, return area for a triangle. Handle cases where\n    values of a or h are negative and throw an exception in such cases.\n    >>> triangle_area(5, 3)\n    7.5\n    >>> triangle_area(-5, 3)\n    Exception: All sides and heights should be greater than zero\n    \"\"\"\n", "canonical_solution": "\n\n    if a <= 0 or h <= 0:\n        raise Exception(\"All sides and heights should be greater than zero\")\n        \n    return a * h / 2.0\n\n", "test": "\n\ndef check(candidate):\n    assert candidate(5, 3) == 7.5\n    assert candidate(2, 2) == 2.0\n    assert candidate(10, 8) == 40.0\n    \n    try:\n        candidate(-5, 3)\n        assert False, \"Exception was expected\"\n    except Exception as e:\n        assert str(e) == \"All sides and heights should be greater than zero\"\n\n    try:\n        candidate(5, -3)\n        assert False, \"Exception was expected\"\n    except Exception as e:\n        assert str(e) == \"All sides and heights should be greater than zero\"\n\n    try:\n        candidate(-5, -3)\n        assert False, \"Exception was expected\"\n    except Exception as e:\n        assert str(e) == \"All sides and heights should be greater than zero\"\n\n", "entry_point": "triangle_area", "question": "Write a function def triangle_area(a, h): to solve the following problem:\nGiven length of a side a and height h, return area for a triangle. Handle cases where\n    values of a or h are negative and throw an exception in such cases.\n    >>> triangle_area(5, 3)\n    7.5\n    >>> triangle_area(-5, 3)\n    Exception: All sides and heights should be greater than zero\n", "context": "def triangle_area(a, h):"}
{"key": 46, "prompt": "def fib5(n: int):\n    \"\"\"The Fib5 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib5(0) -> 0\n    fib5(1) -> 1\n    fib5(2) -> 2\n    fib5(3) -> 3\n    fib5(4) -> 0\n    fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n    Please write a function to compute the n-th element of the fib5 number sequence efficiently. Also, do not use recursion.\n    >>> fib5(6)\n    6\n    >>> fib5(7)\n    12\n    >>> fib5(8)\n    23\n    \"\"\"\n", "canonical_solution": "\n    results = [0, 1, 2, 3, 0]\n    if n < 5:\n        return results[n]\n\n    for _ in range(5, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4] + results[-5])\n        results.pop(0)\n\n    return results[-1]", "test": "def check(candidate):\n    assert candidate(6) == 12\n    assert candidate(8) == 44\n    assert candidate(10) == 170\n    assert candidate(12) == 656", "entry_point": "fib5", "question": "Write a function def fib5(n: int): to solve the following problem:\nThe Fib5 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib5(0) -> 0\n    fib5(1) -> 1\n    fib5(2) -> 2\n    fib5(3) -> 3\n    fib5(4) -> 0\n    fib5(n) -> fib5(n-1) + fib5(n-2) + fib5(n-3) + fib5(n-4) + fib5(n-5).\n    Please write a function to compute the n-th element of the fib5 number sequence efficiently. Also, do not use recursion.\n    >>> fib5(6)\n    6\n    >>> fib5(7)\n    12\n    >>> fib5(8)\n    23\n", "context": "def fib5(n: int):"}
{"key": 47, "prompt": "\ndef median_with_filter(l: list, filter_value: int):\n    \"\"\"Return median of elements in the list l after excluding the given filter_value.\n    If the filter_value is not in the list, return the median of the original list.\n    >>> median_with_filter([3, 1, 2, 4, 5], 3)\n    2.5\n    >>> median_with_filter([-10, 4, 6, 1000, 10, 20], 1000)\n    10\n    >>> median_with_filter([1, 1, 2, 4, 5], 1)\n    4\n    \"\"\"\n", "canonical_solution": "    l = [i for i in l if i != filter_value]\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2.0", "test": "def check(candidate):    \n    assert candidate([3, 1, 2, 4, 5], 3) == 3    \n    assert candidate([-10, 4, 6, 1000, 10, 20], 1000) == 6       \n    assert candidate([8, 1, 3, 9, 9, 2, 7, 1, 1], 1) == 7.5\n    assert candidate([-1, 1,-1, 1], -1) == 1", "entry_point": "median_with_filter", "question": "Write a function def median_with_filter(l: list, filter_value: int): to solve the following problem:\nReturn median of elements in the list l after excluding the given filter_value.\n    If the filter_value is not in the list, return the median of the original list.\n    >>> median_with_filter([3, 1, 2, 4, 5], 3)\n    2.5\n    >>> median_with_filter([-10, 4, 6, 1000, 10, 20], 1000)\n    10\n    >>> median_with_filter([1, 1, 2, 4, 5], 1)\n    4\n", "context": "def median_with_filter(l: list, filter_value: int):"}
{"key": 48, "prompt": "\n\ndef is_palindrome_list(text_list: list):\n    \"\"\"\n    Checks if each string in the given list is a palindrome\n    Returns a list of bools where True means the string at that index is a palindrome\n\n    >>> is_palindrome_list(['', 'aba', 'aaaaa', 'zbcd'])\n    [True, True, True, False]\n    \"\"\"\n", "canonical_solution": "    res = []\n    for text in text_list:\n        is_palindrome = True\n        for i in range(len(text)):\n            if text[i] != text[len(text) - 1 - i]:\n                is_palindrome = False\n                break\n        res.append(is_palindrome)\n    return res", "test": "\n\ndef check(candidate):\n    assert candidate(['', 'aba', 'aaaaa', 'zbcd']) == [True, True, True, False]\n    assert candidate(['xywyx', 'xywyz', 'xywzx']) == [True, False, False]\n    assert candidate(['1234321', 'abcdedcba', 'aabbcc']) == [True, True, False]\n\n", "entry_point": "is_palindrome_list", "question": "Write a function def is_palindrome_list(text_list: list): to solve the following problem:\nChecks if each string in the given list is a palindrome\n    Returns a list of bools where True means the string at that index is a palindrome\n\n    >>> is_palindrome_list(['', 'aba', 'aaaaa', 'zbcd'])\n    [True, True, True, False]\n", "context": "def is_palindrome_list(text_list: list):"}
{"key": 49, "prompt": "\ndef modp(n: int, m:int, p: int):\n    \"\"\"Return m^n modulo p (be aware of numerics).\n    >>> modp(3, 2, 5)\n    3\n    >>> modp(1101, 2, 101)\n    2\n    >>> modp(0, 2, 101)\n    1\n    >>> modp(3, 2, 11)\n    8\n    >>> modp(100, 2, 101)\n    1\n    \"\"\"\n", "canonical_solution": "\n    ret = 1\n    for i in range(n):\n        ret = (m * ret) % p\n    return ret\n", "test": "\ndef check(candidate):\n    assert candidate(3, 2, 5) == 3\n    assert candidate(1101, 2, 101) == 2\n    assert candidate(0, 2, 101) == 1\n    assert candidate(3, 2, 11) == 8\n    assert candidate(100, 2, 101) == 1\n    assert candidate(30, 2, 5) == 4\n    assert candidate(31, 2, 5) == 3\n    assert candidate(5, 3, 7) == 5\n    assert candidate(7, 4, 9) == 4\n", "entry_point": "modp", "question": "Write a function def modp(n: int, m:int, p: int): to solve the following problem:\nReturn m^n modulo p (be aware of numerics).\n    >>> modp(3, 2, 5)\n    3\n    >>> modp(1101, 2, 101)\n    2\n    >>> modp(0, 2, 101)\n    1\n    >>> modp(3, 2, 11)\n    8\n    >>> modp(100, 2, 101)\n    1\n", "context": "def modp(n: int, m:int, p: int):"}
{"key": 50, "prompt": "\ndef encode_shift_multiple(s: str, n: int):\n    \"\"\"\n    Returns an encoded string by shifting every character by n steps in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + n - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift_multiple(s: str, n: int):\n    \"\"\"\n    Takes as input a string encoded with the encode_shift_multiple function and the number of steps by which it has been shifted.\n    Returns decoded original string.\n    \"\"\"\n\n    \"\"\"\n    Returns an encoded string by shifting every character by n steps in the alphabet.\n    \"\"\"\n", "canonical_solution": "    return \"\".join([chr(((ord(ch) - n - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "test": "def check(candidate_decode):\n    from random import randint, choice\n    import copy\n    import string\n\n    letters = string.ascii_lowercase\n    for _ in range(100):\n        str = ''.join(choice(letters) for i in range(randint(10, 20)))\n        steps = randint(1,25)\n        encoded_str = encode_shift_multiple(str, steps)\n        assert candidate_decode(copy.deepcopy(encoded_str), steps) == str", "entry_point": "decode_shift_multiple", "question": "Write a function def decode_shift_multiple(s: str, n: int): to solve the following problem:\nTakes as input a string encoded with the encode_shift_multiple function and the number of steps by which it has been shifted.\n    Returns decoded original string.\n", "context": "def encode_shift_multiple(s: str, n: int):\n    \"\"\"\n    Returns an encoded string by shifting every character by n steps in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + n - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift_multiple(s: str, n: int):"}
{"key": 51, "prompt": "\n\ndef count_vowels_and_consonants(text):\n    \"\"\"\n    Count the number of each vowel and consonant letters in the text.\n\n    This function takes string and returns two dictionaries:\n    * The first dictionary has keys of the vowel letters and values of the number of each vowel in the text.\n    * The second dictionary has keys of the consonant letters and values of the number of each consonant in the text.\n\n    Letters are considered without regard to their case.\n\n    >>> count_vowels_and_consonants('')\n    ({}, {})\n    >>> count_vowels_and_consonants('abcdef')\n    ({\"a\": 1, \"e\": 1}, {\"b\": 1, \"c\": 1, \"d\": 1, \"f\": 1})\n    >>> count_vowels_and_consonants('aaBAA')\n    ({\"a\": 4}, {\"b\": 1})\n    >>> count_vowels_and_consonants('zbcd')\n    ({\"a\": 0, \"e\": 0, \"i\": 0, \"o\": 0, \"u\": 0}, {\"z\": 1, \"b\": 1, \"c\": 1, \"d\": 1})\n\n    \"\"\"\n", "canonical_solution": "\n\n    vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"]\n    vowel_count = dict.fromkeys(vowels, 0)\n    consonant_count = {}\n    for s in text.lower():\n        if s in vowels:\n            vowel_count[s] += 1\n        elif s.isalpha():\n            if s in consonant_count:\n                consonant_count[s] += 1\n            else:\n                consonant_count[s] = 1\n    return vowel_count, consonant_count\n\n", "test": "\n\ndef check(candidate):\n    assert candidate('') == ({'a': 0, 'e': 0, 'i': 0, 'o': 0, 'u': 0}, {})\n    assert candidate('abcdef') == ({\"a\": 1, \"e\": 1, \"i\": 0, \"o\": 0, \"u\": 0}, {\"b\": 1, \"c\": 1, \"d\": 1, \"f\": 1})\n    assert candidate('fedcba') == ({\"a\": 1, \"e\": 1, \"i\": 0, \"o\": 0, \"u\": 0}, {\"f\": 1, \"d\": 1, \"c\": 1, \"b\": 1})\n    assert candidate('eeeee') == ({\"a\": 0, \"e\": 5, \"i\": 0, \"o\": 0, \"u\": 0}, {})\n    assert candidate('ybcd') == ({\"a\": 0, \"e\": 0, \"i\": 0, \"o\": 0, \"u\": 0}, {\"y\": 1, \"b\": 1, \"c\": 1, \"d\": 1})\n\n", "entry_point": "count_vowels_and_consonants", "question": "Write a function def count_vowels_and_consonants(text): to solve the following problem:\nCount the number of each vowel and consonant letters in the text.\n\n    This function takes string and returns two dictionaries:\n    * The first dictionary has keys of the vowel letters and values of the number of each vowel in the text.\n    * The second dictionary has keys of the consonant letters and values of the number of each consonant in the text.\n\n    Letters are considered without regard to their case.\n\n    >>> count_vowels_and_consonants('')\n    ({}, {})\n    >>> count_vowels_and_consonants('abcdef')\n    ({\"a\": 1, \"e\": 1}, {\"b\": 1, \"c\": 1, \"d\": 1, \"f\": 1})\n    >>> count_vowels_and_consonants('aaBAA')\n    ({\"a\": 4}, {\"b\": 1})\n    >>> count_vowels_and_consonants('zbcd')\n    ({\"a\": 0, \"e\": 0, \"i\": 0, \"o\": 0, \"u\": 0}, {\"z\": 1, \"b\": 1, \"c\": 1, \"d\": 1})\n", "context": "def count_vowels_and_consonants(text):"}
{"key": 52, "prompt": "\n\ndef threshold_analysis(l: list, lower_t: int, upper_t: int):\n    \"\"\"Return True if all numbers in the list l are within the inclusive range made by thresholds lower_t and upper_t, otherwise return False.\n    >>> threshold_analysis([1, 2, 4, 10], 1, 100)\n    True\n    >>> threshold_analysis([1, 20, 4, 10], 5, 15)\n    False\n    \"\"\"\n", "canonical_solution": "\n\n    for e in l:\n        if e < lower_t or e > upper_t:\n            return False\n    return True\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([1, 2, 4, 10], 1, 100)\n    assert not candidate([1, 20, 4, 10], 5, 15)\n    assert candidate([1, 20, 4, 10], 1, 20)\n    assert candidate([1, 8, 4, 10], 1, 10)\n    assert not candidate([1, 8, 4, 10], 2, 9)\n\n", "entry_point": "threshold_analysis", "question": "Write a function def threshold_analysis(l: list, lower_t: int, upper_t: int): to solve the following problem:\nReturn True if all numbers in the list l are within the inclusive range made by thresholds lower_t and upper_t, otherwise return False.\n    >>> threshold_analysis([1, 2, 4, 10], 1, 100)\n    True\n    >>> threshold_analysis([1, 20, 4, 10], 5, 15)\n    False\n", "context": "def threshold_analysis(l: list, lower_t: int, upper_t: int):"}
{"key": 53, "prompt": "\ndef add_multiply(x: int, y: int, z: int):\n    \"\"\"First add two numbers x and y, then multiply the result with z\n    >>> add_multiply(2, 3, 4)\n    20\n    >>> add_multiply(5, 7, 2)\n    24\n    \"\"\"\n", "canonical_solution": "    return (x + y) * z", "test": "\ndef check(candidate):\n    import random\n\n    assert candidate(0, 1, 2) == 2\n    assert candidate(1, 0, 2) == 2\n    assert candidate(2, 3, 4) == 20\n    assert candidate(5, 7, 2) == 24\n    assert candidate(7, 5, 2) == 24\n\n    for i in range(100):\n        x, y, z = random.randint(0, 1000), random.randint(0, 1000), random.randint(0, 1000)\n        assert candidate(x, y, z) == (x + y) * z\n        \n\ncheck(add_multiply)\n", "entry_point": "add_multiply", "question": "Write a function def add_multiply(x: int, y: int, z: int): to solve the following problem:\nFirst add two numbers x and y, then multiply the result with z\n    >>> add_multiply(2, 3, 4)\n    20\n    >>> add_multiply(5, 7, 2)\n    24\n", "context": "def add_multiply(x: int, y: int, z: int):"}
{"key": 54, "prompt": "\n\n\ndef same_chars_count(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters with the same count of each character.\n    >>> same_chars_count('eabcdzzzz', 'abcdzezzz')\n    True\n    >>> same_chars_count('abcd', 'dddddddabc')\n    False\n    >>> same_chars_count('abccba', 'cbaacb')\n    True\n    >>> same_chars_count('eabcd', 'abcde')\n    True\n    >>> same_chars_count('abcd', 'abcde')\n    False\n    >>> same_chars_count('eabcdzzzz', 'dddddabczze')\n    False\n    \"\"\"\n", "canonical_solution": "\n\n    return sorted(s0) == sorted(s1)\n\n", "test": "\n\ndef check(candidate):\n    assert candidate('eabcdzzzz', 'abcdzezzz') == True\n    assert candidate('abcd', 'dddddddabc') == False\n    assert candidate('abccba', 'cbaacb') == True\n    assert candidate('eabcd', 'abcde') == True\n    assert candidate('abcd', 'abcde') == False\n    assert candidate('eabcdzzzz', 'dddddabczze') == False\n    assert candidate('aab', 'aca') == False\n\n", "entry_point": "same_chars_count", "question": "Write a function def same_chars_count(s0: str, s1: str): to solve the following problem:\nCheck if two words have the same characters with the same count of each character.\n    >>> same_chars_count('eabcdzzzz', 'abcdzezzz')\n    True\n    >>> same_chars_count('abcd', 'dddddddabc')\n    False\n    >>> same_chars_count('abccba', 'cbaacb')\n    True\n    >>> same_chars_count('eabcd', 'abcde')\n    True\n    >>> same_chars_count('abcd', 'abcde')\n    False\n    >>> same_chars_count('eabcdzzzz', 'dddddabczze')\n    False\n", "context": "def same_chars_count(s0: str, s1: str):"}
{"key": 55, "prompt": "\ndef fib_memo(n: int, memo: dict):\n    \"\"\"\n    Return n-th Fibonacci number using memoization (an optimization technique used primarily \n    to speed up computer programs by storing the results of expensive function calls).\n    The 'memo' parameter is a dictionary used for storing previously calculated values.\n\n    >>> fib_memo(10, {})\n    55\n    >>> fib_memo(20, {})\n    6765\n    >>> fib_memo(30, {})\n    832040\n    \"\"\"\n", "canonical_solution": "\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n not in memo:\n        memo[n] = fib_memo(n - 1, memo) + fib_memo(n - 2, memo)\n    return memo[n]\n", "test": "\ndef check(candidate):\n    assert candidate(10, {}) == 55\n    assert candidate(20, {}) == 6765\n    assert candidate(30, {}) == 832040\n    assert candidate(15, {}) == 610\n    assert candidate(25, {}) == 75025\n", "entry_point": "fib_memo", "question": "Write a function def fib_memo(n: int, memo: dict): to solve the following problem:\nReturn n-th Fibonacci number using memoization (an optimization technique used primarily \n    to speed up computer programs by storing the results of expensive function calls).\n    The 'memo' parameter is a dictionary used for storing previously calculated values.\n\n    >>> fib_memo(10, {})\n    55\n    >>> fib_memo(20, {})\n    6765\n    >>> fib_memo(30, {})\n    832040\n", "context": "def fib_memo(n: int, memo: dict):"}
{"key": 56, "prompt": "def correct_bracketing_advanced(brackets: str, brack_pairs: dict):\n    \"\"\"\n    brackets is a string of characters consisting of pairs defined in brack_pairs.\n    brack_pairs is a dictionary where keys are opening brackets and values are the corresponding closing brackets.\n    return True if every opening bracket has a corresponding closing bracket in the correct order.\n    >>> correct_bracketing_advanced(\"<>\", {'<': '>'})\n    True   \n    >>> correct_bracketing_advanced(\"<<><>>\", {'<': '>'})    \n    True  \n    >>> correct_bracketing_advanced(\"<(<)[]>\", {'<': '>', '(': ')', '[': ']'})    \n    False    \n    >>> correct_bracketing_advanced(\"<(>)]\", {'<': '>', '(': ')', '[': ']'})    \n    False\n    \"\"\"\n", "canonical_solution": "    stack = []    \n    for b in brackets:        \n        if b in brack_pairs.keys():            \n            stack.append(b)        \n        elif not stack or brack_pairs[stack.pop()] != b:\n            return False   \n    return not stack", "test": "def check(candidate):  \n    brack_pairs = {'<': '>', '(': ')', '[': ']'}\n    assert candidate(\"<>\", brack_pairs)   \n    assert candidate(\"<<><>>\", brack_pairs)    \n    assert not candidate(\"<(<)[]>\", brack_pairs)   \n    assert candidate(\"<>()[]\", brack_pairs)    \n    assert not candidate(\"<<<><>>>>\", brack_pairs)    \n    assert not candidate(\"><<>\", brack_pairs)   \n    assert not candidate(\"<\", brack_pairs)   \n    assert not candidate(\"<<<<\", brack_pairs)    \n    assert not candidate(\">\", brack_pairs)    \n    assert not candidate(\"<<>\", brack_pairs)    \n    assert not candidate(\"<>)()[]\", brack_pairs)    \n    assert not candidate(\"<(<)[]>]\", brack_pairs)", "entry_point": "correct_bracketing_advanced", "question": "Write a function def correct_bracketing_advanced(brackets: str, brack_pairs: dict): to solve the following problem:\nbrackets is a string of characters consisting of pairs defined in brack_pairs.\n    brack_pairs is a dictionary where keys are opening brackets and values are the corresponding closing brackets.\n    return True if every opening bracket has a corresponding closing bracket in the correct order.\n    >>> correct_bracketing_advanced(\"<>\", {'<': '>'})\n    True   \n    >>> correct_bracketing_advanced(\"<<><>>\", {'<': '>'})    \n    True  \n    >>> correct_bracketing_advanced(\"<(<)[]>\", {'<': '>', '(': ')', '[': ']'})    \n    False    \n    >>> correct_bracketing_advanced(\"<(>)]\", {'<': '>', '(': ')', '[': ']'})    \n    False\n", "context": "def correct_bracketing_advanced(brackets: str, brack_pairs: dict):"}
{"key": 57, "prompt": "def advanced_monotonic(l: list, strict: bool):\n    \"\"\"\n    Return True is list elements are monotonically increasing or decreasing. If strict is True, then it checks for strictly increasing or decreasing.\n   \n    >>> advanced_monotonic([1, 2, 4, 20], False)\n    True\n    >>> advanced_monotonic([1, 2, 4, 20], True)\n    True\n    >>> advanced_monotonic([1, 20, 4, 10], False)\n    False\n    >>> advanced_monotonic([1, 20, 4, 10], True)\n    False\n    >>> advanced_monotonic([4, 1, 0, -10], False)\n    True\n    >>> advanced_monotonic([1, 1, 2, 3], False)\n    True\n    >>> advanced_monotonic([1, 1, 2, 3], True)\n    False\n    \"\"\"\n", "canonical_solution": "    if strict:\n        if l == sorted(l) and len(set(l)) == len(l):\n            return True\n        elif l == sorted(l, reverse = True) and len(set(l)) == len(l):\n            return True\n        else:\n            return False\n    else:\n        if l == sorted(l) or l == sorted(l, reverse = True):\n            return True\n        else:\n            return False", "test": "def check(candidate):\n    assert candidate([1, 2, 4, 20], False) == True\n    assert candidate([1, 2, 4, 20], True) == True\n    assert candidate([1, 20, 4, 10], False) == False\n    assert candidate([1, 20, 4, 10], True) == False\n    assert candidate([4, 1, 0, -10], False) == True\n    assert candidate([1, 1, 2, 3], False) == True\n    assert candidate([1, 1, 2, 3], True) == False\n    assert candidate([1, 2, 2, 3, 3, 4], False) == True\n    assert candidate([1, 2, 2, 3, 3, 4], True) == False", "entry_point": "advanced_monotonic", "question": "Write a function def advanced_monotonic(l: list, strict: bool): to solve the following problem:\nReturn True is list elements are monotonically increasing or decreasing. If strict is True, then it checks for strictly increasing or decreasing.\n   \n    >>> advanced_monotonic([1, 2, 4, 20], False)\n    True\n    >>> advanced_monotonic([1, 2, 4, 20], True)\n    True\n    >>> advanced_monotonic([1, 20, 4, 10], False)\n    False\n    >>> advanced_monotonic([1, 20, 4, 10], True)\n    False\n    >>> advanced_monotonic([4, 1, 0, -10], False)\n    True\n    >>> advanced_monotonic([1, 1, 2, 3], False)\n    True\n    >>> advanced_monotonic([1, 1, 2, 3], True)\n    False\n", "context": "def advanced_monotonic(l: list, strict: bool):"}
{"key": 58, "prompt": "\ndef common(l1: list, l2: list, l3: list):\n    \"\"\"Return sorted unique common elements for three lists.\n   >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121], [6, 1, 5, 8, 653, 99])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2, 5, 6], [2, 3, 9, 6])\n    [2, 3]\n    \"\"\"\n", "canonical_solution": "\n\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            for e3 in l3:\n                if e1 == e2 and e2 == e3:\n                    ret.add(e1)\n    return sorted(list(ret))\n\n", "test": "\n\ndef check(candidate):\n    assert candidate([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121], [6, 1, 5, 8, 653, 99]) == [1, 5, 653]\n    assert candidate([5, 3, 2, 8], [3, 2, 5, 6], [2, 3, 9, 6]) == [2, 3]\n    assert candidate([4, 3, 2, 8], [3, 2, 4, 5], [3, 5, 9, 4]) == [3, 4]\n    assert candidate([4, 3, 2, 8], [], []) == []\n\n\n", "entry_point": "common", "question": "Write a function def common(l1: list, l2: list, l3: list): to solve the following problem:\nReturn sorted unique common elements for three lists.\n   >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121], [6, 1, 5, 8, 653, 99])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2, 5, 6], [2, 3, 9, 6])\n    [2, 3]\n", "context": "def common(l1: list, l2: list, l3: list):"}
{"key": 59, "prompt": "\ndef prime_factors(n: int):\n    \"\"\"Return a list of all the prime factors of n, and the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> prime_factors(13195)\n    ([5, 7, 13, 29], 29)\n    >>> prime_factors(2048)\n    ([2], 2)\n    \"\"\"\n", "canonical_solution": "    def is_prime(k):\n        \"\"\"Return whether k is a prime number.\"\"\"\n        if k < 2:\n            return False\n        for i in range(2, k-1):\n            if k % i == 0:\n                return False\n        return True\n\n    largest = 1\n    factors = []\n    for j in range(2, n + 1):\n        if n % j == 0 and is_prime(j):\n            factors.append(j)\n            largest = max(largest, j)\n    return factors, largest", "test": "\ndef check(candidate):\n    factors, largest = candidate(15)\n    assert factors == [3, 5]\n    assert largest == 5\n\n    factors, largest = candidate(27)\n    assert factors == [3]\n    assert largest == 3\n\n    factors, largest = candidate(63)\n    assert factors == [3, 7]\n    assert largest == 7\n\n    factors, largest = candidate(330)\n    assert factors == [2, 3, 5, 11]\n    assert largest == 11\n\n    factors, largest = candidate(13195)\n    assert factors == [5, 7, 13, 29]\n    assert largest == 29\n", "entry_point": "prime_factors", "question": "Write a function def prime_factors(n: int): to solve the following problem:\nReturn a list of all the prime factors of n, and the largest prime factor of n. Assume n > 1 and is not a prime.\n\n    >>> prime_factors(13195)\n    ([5, 7, 13, 29], 29)\n    >>> prime_factors(2048)\n    ([2], 2)\n", "context": "def prime_factors(n: int):"}
{"key": 60, "prompt": "\ndef sum_to_n_odd_numbers(n: int):\n    \"\"\"sum_to_n_odd_numbers is a function that sums the odd numbers from 1 to n.\n    >>> sum_to_n_odd_numbers(30)\n    225\n    >>> sum_to_n_odd_numbers(100)\n    2500\n    >>> sum_to_n_odd_numbers(5)\n    9\n    >>> sum_to_n_odd_numbers(10)\n    25\n    >>> sum_to_n_odd_numbers(1)\n    1\n    \"\"\"\n", "canonical_solution": "    return sum([i for i in range(n + 1) if i%2 != 0])", "test": "\ndef check(candidate):\n    assert candidate(1) == 1\n    assert candidate(6) == 9\n    assert candidate(11) == 36\n    assert candidate(30) == 225\n    assert candidate(100) == 2500\n", "entry_point": "sum_to_n_odd_numbers", "question": "Write a function def sum_to_n_odd_numbers(n: int): to solve the following problem:\nsum_to_n_odd_numbers is a function that sums the odd numbers from 1 to n.\n    >>> sum_to_n_odd_numbers(30)\n    225\n    >>> sum_to_n_odd_numbers(100)\n    2500\n    >>> sum_to_n_odd_numbers(5)\n    9\n    >>> sum_to_n_odd_numbers(10)\n    25\n    >>> sum_to_n_odd_numbers(1)\n    1\n", "context": "def sum_to_n_odd_numbers(n: int):"}
{"key": 61, "prompt": "\n\n\n\ndef correct_bracketing_with_types(brackets: str):\n    \"\"\" brackets is a string of \"(\", \")\", \"[\", \"]\" , \"{\" , \"}\".\n    return True if every opening bracket has a corresponding closing bracket, and opening and closing brackets are of the same type.\n\n    >>> correct_bracketing_with_types(\"(\")\n    False\n    >>> correct_bracketing_with_types(\"()\")\n    True\n    >>> correct_bracketing_with_types(\"(()())\")\n    True\n    >>> correct_bracketing_with_types(\")(()\")\n    False\n    >>> correct_bracketing_with_types(\"{(})\")\n    False\n\n    \"\"\"\n", "canonical_solution": "\n\n    opened = []\n    for ch in brackets:\n        if ch in \"([{\":\n            opened.append(ch)\n        else:\n            if len(opened) == 0:\n                return False\n           \n            open_bracket = opened.pop()\n            if open_bracket == '(' and ch != ')':\n                return False\n            if open_bracket == '[' and ch != ']':\n                return False\n            if open_bracket == '{' and ch != '}':\n                return False\n       \n    return len(opened) == 0\n\n", "test": "\n\ndef check(candidate):\n    assert candidate(\"()\")\n    assert candidate(\"(()())\")\n    assert candidate(\"()()[{[()()]()}]{{[()]}}\")\n    assert candidate(\"{[()]}\")\n    assert not candidate(\"((()())))\")\n    assert not candidate(\"[((]))\")\n    assert not candidate(\")(()\")\n    assert not candidate(\"]\")\n    assert not candidate(\"[((())\")\n    assert not candidate(\"[{()}\")\n    assert not candidate(\"{(})\")\n    assert not candidate(\"()()(()())())(()\")\n    assert not candidate(\"()()(()())()))()\")\n\n\n", "entry_point": "correct_bracketing_with_types", "question": "Write a function def correct_bracketing_with_types(brackets: str): to solve the following problem:\nbrackets is a string of \"(\", \")\", \"[\", \"]\" , \"{\" , \"}\".\n    return True if every opening bracket has a corresponding closing bracket, and opening and closing brackets are of the same type.\n\n    >>> correct_bracketing_with_types(\"(\")\n    False\n    >>> correct_bracketing_with_types(\"()\")\n    True\n    >>> correct_bracketing_with_types(\"(()())\")\n    True\n    >>> correct_bracketing_with_types(\")(()\")\n    False\n    >>> correct_bracketing_with_types(\"{(})\")\n    False\n", "context": "def correct_bracketing_with_types(brackets: str):"}
{"key": 62, "prompt": "def higher_derivative(xs: list, n: int):\n    \"\"\" \n    xs represent coefficients of a polynomial in ascending order.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    n represent the order of derivative.\n    Return derivative of this polynomial of order 'n' in the same form.\n    \n    >>> higher_derivative([3, 1, 2, 4, 5], 1)\n    [1, 4, 12, 20]\n    >>> higher_derivative([1, 2, 3], 2)\n    [6]\n    >>> higher_derivative([3, 1, 2, 4, 5], 2)\n    [4, 24, 60]\n    \"\"\"\n", "canonical_solution": "    for _ in range(n):\n        xs = [(i * x) for i, x in enumerate(xs)][1:]\n    return xs", "test": "def check(candidate):\n    assert candidate([3, 1, 2, 4, 5], 1) == [1, 4, 12, 20]\n    assert candidate([1, 2, 3], 2) == [6]\n    assert candidate([3, 2, 1], 2) == [2]\n    assert candidate([3, 2, 1, 0, 4], 3) == [0,96]\n    assert candidate([1], 1) == []", "entry_point": "higher_derivative", "question": "Write a function def higher_derivative(xs: list, n: int): to solve the following problem:\nxs represent coefficients of a polynomial in ascending order.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n    n represent the order of derivative.\n    Return derivative of this polynomial of order 'n' in the same form.\n    \n    >>> higher_derivative([3, 1, 2, 4, 5], 1)\n    [1, 4, 12, 20]\n    >>> higher_derivative([1, 2, 3], 2)\n    [6]\n    >>> higher_derivative([3, 1, 2, 4, 5], 2)\n    [4, 24, 60]\n", "context": "def higher_derivative(xs: list, n: int):"}
{"key": 63, "prompt": "def fibfib_super(n: int):\n    \"\"\"The FibFib_super number sequence is a sequence similar to the FibFib sequence that's defined as follows:\n    fibfib_super(0) == 0\n    fibfib_super(1) == 0\n    fibfib_super(2) == 1\n    fibfib_super(3) == 1\n    fibfib_super(n) == fibfib_super(n-1) + fibfib_super(n-2) + fibfib_super(n-3) + fibfib_super(n-4).\n    Please write a function to efficiently compute the n-th element of the fibfib_super number sequence.\n    >>> fibfib_super(1)\n    0\n    >>> fibfib_super(5)\n    4\n    >>> fibfib_super(8)\n    29\n    \"\"\"\n", "canonical_solution": "    if n == 0:\n        return 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    if n == 3:\n        return 1\n    return fibfib_super(n - 1) + fibfib_super(n - 2) + fibfib_super(n - 3) + fibfib_super(n - 4)\n", "test": "def check(candidate):\n    assert candidate(2) == 1\n    assert candidate(1) == 0\n    assert candidate(5) == 4\n    assert candidate(8) == 29\n    assert candidate(10) == 108\n    assert candidate(12) == 401\n    assert candidate(14) == 1490", "entry_point": "fibfib_super", "question": "Write a function def fibfib_super(n: int): to solve the following problem:\nThe FibFib_super number sequence is a sequence similar to the FibFib sequence that's defined as follows:\n    fibfib_super(0) == 0\n    fibfib_super(1) == 0\n    fibfib_super(2) == 1\n    fibfib_super(3) == 1\n    fibfib_super(n) == fibfib_super(n-1) + fibfib_super(n-2) + fibfib_super(n-3) + fibfib_super(n-4).\n    Please write a function to efficiently compute the n-th element of the fibfib_super number sequence.\n    >>> fibfib_super(1)\n    0\n    >>> fibfib_super(5)\n    4\n    >>> fibfib_super(8)\n    29\n", "context": "def fibfib_super(n: int):"}
{"key": 64, "prompt": "\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s, include_y_end=True, include_y_all=False):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. The function also takes \n    two other parameters - include_y_end and include_y_all. If include_y_end \n    is True, 'y' is considered a vowel when it is at the end of the \n    word. If include_y_all is True, 'y' is considered a vowel \n    regardless of where it appears in the word.\n    \n    Example:\n    >>> vowels_count(\"abcde\", include_y_end=True, include_y_all=False)\n    2\n    >>> vowels_count(\"ACEDY\", include_y_end=True, include_y_all=False)\n    3\n    >>> vowels_count(\"aby\", include_y_end=False, include_y_all=True)\n    3\n    \"\"\"\n", "canonical_solution": "\n\n    vowels = \"aeiouAEIOU\"\n    n_vowels = sum(c in vowels for c in s)\n    if s[-1] == 'y' or s[-1] == 'Y':\n        if include_y_end:\n            n_vowels += 1\n    if 'y' in s or 'Y' in s:\n        if include_y_all:\n            n_vowels += s.count('y') + s.count('Y')\n    return n_vowels\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"abcde\", include_y_end=True, include_y_all=False) == 2, \"Test 1\"\n    assert candidate(\"Alone\", include_y_end=True, include_y_all=False) == 3, \"Test 2\"\n    assert candidate(\"key\", include_y_end=True, include_y_all=False) == 2, \"Test 3\"\n    assert candidate(\"bye\", include_y_end=False, include_y_all=True) == 2, \"Test 4\"\n    assert candidate(\"keY\", include_y_end=True, include_y_all=True) == 3, \"Test 5\"\n    assert candidate(\"bYe\", include_y_end=False, include_y_all=False) == 1, \"Test 6\"\n    assert candidate(\"ACEDY\", include_y_end=True, include_y_all=False) == 3, \"Test 7\"\n\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "vowels_count", "question": "Write a function def vowels_count(s, include_y_end=True, include_y_all=False): to solve the following problem:\nWrite a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. The function also takes \n    two other parameters - include_y_end and include_y_all. If include_y_end \n    is True, 'y' is considered a vowel when it is at the end of the \n    word. If include_y_all is True, 'y' is considered a vowel \n    regardless of where it appears in the word.\n    \n    Example:\n    >>> vowels_count(\"abcde\", include_y_end=True, include_y_all=False)\n    2\n    >>> vowels_count(\"ACEDY\", include_y_end=True, include_y_all=False)\n    3\n    >>> vowels_count(\"aby\", include_y_end=False, include_y_all=True)\n    3\n", "context": "FIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef vowels_count(s, include_y_end=True, include_y_all=False):"}
{"key": 65, "prompt": "\ndef circular_shift_modified(x, shift, direction):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift \n    if direction is 'r' or 'R' and left by shift if direction is 'l' or 'L'\n    If shift > number of digits or <= 0, return digits reversed.\n    return the result as a string.\n\n    >>> circular_shift_modified(1234, 1, 'r')\n    \"4123\"\n    >>> circular_shift_modified(1234, 2, 'l')\n    \"3412\"\n    >>> circular_shift_modified(1234, 0, 'r')\n    \"4321\"\n    >>> circular_shift_modified(1234, 5, 'l')\n    \"4321\"\n    >>> circular_shift_modified(1234, -2, 'l')\n    \"4321\"\n    \"\"\"\n", "canonical_solution": "    s = str(x)\n    if shift > len(s) or shift <= 0:\n        return s[::-1]\n    else:\n        if direction == 'r' or direction == 'R':\n            return s[len(s) - shift:] + s[:len(s) - shift]\n        else:  # direction = 'l' or 'L'\n            return s[shift:] + s[:shift]", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(4567, 2, 'r') == \"6745\"\n    assert candidate(1234, 3, 'l') == \"4123\"\n    \n    # Check edge cases which are easy to work out by hand.\n    assert candidate(4567, 0, 'r') == \"7654\"\n    assert candidate(1234, 5, 'l') == \"4321\"\n    assert candidate(1234, -2, 'R') == \"4321\"\n    assert candidate(7854, 2, 'L') == \"5478\"\n\n    # Check case when direction is in uppercase\n    assert candidate(4567, 2, 'R') == \"6745\"\n    assert candidate(1234, 3, 'L') == \"4123\"\n", "entry_point": "circular_shift_modified", "question": "Write a function def circular_shift_modified(x, shift, direction): to solve the following problem:\nCircular shift the digits of the integer x, shift the digits right by shift \n    if direction is 'r' or 'R' and left by shift if direction is 'l' or 'L'\n    If shift > number of digits or <= 0, return digits reversed.\n    return the result as a string.\n\n    >>> circular_shift_modified(1234, 1, 'r')\n    \"4123\"\n    >>> circular_shift_modified(1234, 2, 'l')\n    \"3412\"\n    >>> circular_shift_modified(1234, 0, 'r')\n    \"4321\"\n    >>> circular_shift_modified(1234, 5, 'l')\n    \"4321\"\n    >>> circular_shift_modified(1234, -2, 'l')\n    \"4321\"\n", "context": "def circular_shift_modified(x, shift, direction):"}
{"key": 66, "prompt": "def digitSum(s, lower=False):\n    \"\"\"Task\n    Write a function that takes a string as input and a boolean (lower) if lower is False it should \n    return the sum of the upper characters only ASCII codes. If lower is True it should \n    return the sum of the lower characters only ASCII codes.\n \n    Examples:\n        digitSum(\"\", False) => 0\n        digitSum(\"abAB\", False) => 131\n        digitSum(\"abcCd\", False) => 67\n        digitSum(\"helloE\", False) => 69\n        digitSum(\"woArBld\", False) => 131      \n        digitSum(\"aAaaaXa\", False) => 153\n        digitSum(\"\", True) => 0\n        digitSum(\"abAB\", True) => 195\n        digitSum(\"abcCd\", True) => 394\n        digitSum(\"helloE\", True) => 532\n        digitSum(\"woArBld\", True) => 552     \n        digitSum(\"aAaaaXa\", True) => 485\n    \"\"\"\n", "canonical_solution": "\n    if s == \"\": return 0\n    if lower:\n        return sum(ord(char) if char.islower() else 0 for char in s)\n    else:\n        return sum(ord(char) if char.isupper() else 0 for char in s)", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(\"\", False) == 0, \"Error\"\n    assert candidate(\"abAB\", False) == 131, \"Error\"\n    assert candidate(\"abcCd\", False) == 67, \"Error\"\n    assert candidate(\"helloE\", False) == 69, \"Error\"\n    assert candidate(\"woArBld\", False) == 131, \"Error\"\n    assert candidate(\"aAaaaXa\", False) == 153, \"Error\"\n    assert candidate(\"\", True) == 0, \"Error\"\n    assert candidate(\"abAB\", True) == 195, \"Error\"\n    assert candidate(\"abcCd\", True) == 394, \"Error\"\n    assert candidate(\"helloE\", True) == 532, \"Error\"\n    assert candidate(\"woArBld\", True) == 552, \"Error\"\n    assert candidate(\"aAaaaXa\", True) == 485, \"Error\"\n  \n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(\" How are yOu?\", False) == 151, \"Error\"\n    assert candidate(\"You arE Very Smart\", False) == 327, \"Error\"\n    assert candidate(\" How are yOu?\", True) == 780, \"Error\"\n    assert candidate(\"You arE Very Smart\", True) == 1211, \"Error\"", "entry_point": "digitSum", "question": "Write a function def digitSum(s, lower=False): to solve the following problem:\nTask\n    Write a function that takes a string as input and a boolean (lower) if lower is False it should \n    return the sum of the upper characters only ASCII codes. If lower is True it should \n    return the sum of the lower characters only ASCII codes.\n \n    Examples:\n        digitSum(\"\", False) => 0\n        digitSum(\"abAB\", False) => 131\n        digitSum(\"abcCd\", False) => 67\n        digitSum(\"helloE\", False) => 69\n        digitSum(\"woArBld\", False) => 131      \n        digitSum(\"aAaaaXa\", False) => 153\n        digitSum(\"\", True) => 0\n        digitSum(\"abAB\", True) => 195\n        digitSum(\"abcCd\", True) => 394\n        digitSum(\"helloE\", True) => 532\n        digitSum(\"woArBld\", True) => 552     \n        digitSum(\"aAaaaXa\", True) => 485\n", "context": "def digitSum(s, lower=False):"}
{"key": 67, "prompt": "\ndef fruit_distribution(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. The string not only represents the total number of \n    apples and oranges but also the number of mangoes that are spoiled.\n    Given three inputs - a string that represents the total number of the apples, oranges \n    and the spoiled mangoes, an integer that represents the total number of fruits (fresh + spoiled) \n    in the basket.\n    Return the number of the fresh mango fruits in the basket.\n    For example:\n    fruit_distribution(\"5 apples, 6 oranges and 3 spoiled mangoes\", 22) -> 22 - 5 - 6 - 3 = 8\n    fruit_distribution(\"0 apples, 1 oranges and 2 spoiled mangoes\", 5) -> 5 - 0 - 1 - 2 = 2\n    fruit_distribution(\"2 apples, 3 oranges and 10 spoiled mangoes\", 115) -> 115 - 2 - 3 - 10 = 100\n    fruit_distribution(\"100 apples, 1 oranges and 20 spoiled mangoes\", 145) -> 145 - 100 - 1 - 20 = 24\n    \"\"\"\n", "canonical_solution": "    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis[:3])", "test": "def check(candidate):\n\n    # Check some cases\n    assert candidate(\"5 apples, 6 oranges and 3 spoiled mangoes\", 22) == 8\n    assert candidate(\"10 apples, 10 oranges and 1 spoiled mangoes\", 32) == 11\n    assert candidate(\"0 apples, 1 oranges and 2 spoiled mangoes\", 5) == 2\n    assert candidate(\"1 apples, 1 oranges and 1 spoiled mangoes\",4) == 1\n    assert candidate(\"2 apples, 3 oranges and 10 spoiled mangoes\", 115) == 100\n    assert candidate(\"3 apples, 2 oranges and 5 spoiled mangoes\", 10) == 0\n    assert candidate(\"100 apples, 1 oranges and 20 spoiled mangoes\",140) == 19\n", "entry_point": "fruit_distribution", "question": "Write a function def fruit_distribution(s,n): to solve the following problem:\nIn this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. The string not only represents the total number of \n    apples and oranges but also the number of mangoes that are spoiled.\n    Given three inputs - a string that represents the total number of the apples, oranges \n    and the spoiled mangoes, an integer that represents the total number of fruits (fresh + spoiled) \n    in the basket.\n    Return the number of the fresh mango fruits in the basket.\n    For example:\n    fruit_distribution(\"5 apples, 6 oranges and 3 spoiled mangoes\", 22) -> 22 - 5 - 6 - 3 = 8\n    fruit_distribution(\"0 apples, 1 oranges and 2 spoiled mangoes\", 5) -> 5 - 0 - 1 - 2 = 2\n    fruit_distribution(\"2 apples, 3 oranges and 10 spoiled mangoes\", 115) -> 115 - 2 - 3 - 10 = 100\n    fruit_distribution(\"100 apples, 1 oranges and 20 spoiled mangoes\", 145) -> 145 - 100 - 1 - 20 = 24\n", "context": "def fruit_distribution(s,n):"}
{"key": 68, "prompt": "\n\ndef pluck(arr, arr2):\n    \"\"\"\n    \"Given two arrays [ arr1, arr2 ] representing different branches of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it, but from each array, you have to pluck a single node.\n    The plucked node should be the node with the smallest and largest even value respectively,\n    from arr1 and arr2 respectively. Assuming smallest value node in arr1 while largest even value node from arr2.\n    If multiple nodes with the same smallest/largest even value are found return the node that has smallest index from\n    respective array.\n\n    The plucked node should be returned in a list of lists, [ [smallest_value_arr1, its index_arr1 ],\n    [largest_value_arr2, its index_arr2 ]],\n\n    If there are no even values or the given array is empty, return an empty list respective to that array.\n\n    Example 1:\n        Input: [4,2,3], [6,8,10,1]\n        Output: [[2, 1], [10, 2]]\n        Explanation: From arr1, 2 has the smallest even value and smallest index, while from arr2,\n                      10 has the largest even value and its index is 2.\n\n    Example 2:\n        Input: [5,7], [1,3,2]\n        Output: [[], [2, 2]]\n        Explanation: In the first array, there are no even values, while from the second array, 2 is the largest \n                      even value and its index is 2. \n\n    Example 3:\n        Input: [], [4,6,3]\n        Output: [[], [6, 1]]\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2, 2], [2, 2, 2, 3]\n        Output: [[0, 1], [2, 0]] \n        Explanation: From arr1, 0 is the smallest value, but  there are two zeros, so we choose the first zero,\n                      which has the smallest index. From arr2, even though there are three 2's, we will choose the furthermost,\n                      i.e., the one with the largest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value <= 10**9\n    \"\"\"\n", "canonical_solution": "\n    res = []\n    if(len(arr) == 0): res.append([])\n    else:\n        evens1 = list(filter(lambda x: x%2 == 0, arr))\n        if(evens1 == []): res.append([])\n        else: res.append([min(evens1), arr.index(min(evens1))])\n    \n    if(len(arr2) == 0): res.append([])\n    else:\n        evens2 = list(filter(lambda x: x%2 == 0, arr2))\n        if(evens2 == []): res.append([])\n        else: res.append([max(evens2), len(arr2) - 1 - arr2[::-1].index(max(evens2))])\n    return res\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([4,2,3], [6,8,10,1]) == [[2,1], [10,2]], \"Error\"\n    assert candidate([5,7], [1,3,2]) == [[], [2,2]], \"Error\" \n    assert candidate([], [4,6,3]) == [[], [6,1]], \"Error\"\n    assert candidate([5, 0, 3, 0, 4, 2, 2], [2, 2, 2, 3]) == [[0, 1], [2, 2]], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([1, 2, 3, 0, 5, 3], [2, 2, 3, 7]) == [[0, 3], [2, 1]], \"Error\"\n    assert candidate([5, 4, 8, 4 ,8], [7, 6, 1]) == [[4, 1], [6, 1]], \"Error\"\n    assert candidate([7, 6, 7, 1], [5, 0, 3, 2, 5, 5]) == [[6, 1], [2, 3]], \"Error\"\n    assert candidate([7, 9, 7, 1], [1, 3, 5, 7]) == [[], []], \"Error\"\n\n\n", "entry_point": "pluck", "question": "Write a function def pluck(arr, arr2): to solve the following problem:\n\"Given two arrays [ arr1, arr2 ] representing different branches of a tree that has non-negative integer nodes\n    your task is to pluck one of the nodes and return it, but from each array, you have to pluck a single node.\n    The plucked node should be the node with the smallest and largest even value respectively,\n    from arr1 and arr2 respectively. Assuming smallest value node in arr1 while largest even value node from arr2.\n    If multiple nodes with the same smallest/largest even value are found return the node that has smallest index from\n    respective array.\n\n    The plucked node should be returned in a list of lists, [ [smallest_value_arr1, its index_arr1 ],\n    [largest_value_arr2, its index_arr2 ]],\n\n    If there are no even values or the given array is empty, return an empty list respective to that array.\n\n    Example 1:\n        Input: [4,2,3], [6,8,10,1]\n        Output: [[2, 1], [10, 2]]\n        Explanation: From arr1, 2 has the smallest even value and smallest index, while from arr2,\n                      10 has the largest even value and its index is 2.\n\n    Example 2:\n        Input: [5,7], [1,3,2]\n        Output: [[], [2, 2]]\n        Explanation: In the first array, there are no even values, while from the second array, 2 is the largest \n                      even value and its index is 2. \n\n    Example 3:\n        Input: [], [4,6,3]\n        Output: [[], [6, 1]]\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2, 2], [2, 2, 2, 3]\n        Output: [[0, 1], [2, 0]] \n        Explanation: From arr1, 0 is the smallest value, but  there are two zeros, so we choose the first zero,\n                      which has the smallest index. From arr2, even though there are three 2's, we will choose the furthermost,\n                      i.e., the one with the largest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value <= 10**9\n", "context": "def pluck(arr, arr2):"}
{"key": 69, "prompt": "\n\n\ndef search_lst(lst1, lst2):\n    '''\n    You are given two non-empty lists (lst1 and lst2) of positive integers. \n    In both lists return the greatest integer that is greater than zero, \n    and has a frequency greater than or equal to the value of the integer itself \n    in its own list. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist in either of the lists, return -1.\n    \n    Examples:\n        search_lst([4, 1, 2, 2, 3, 1], [1, 2, 2, 3, 3, 3]) == (2,3)\n        search_lst([5, 5, 5, 5, 1], [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5]) == (1,4)\n        search_lst([3, 3, 3, 3], [5, 5, 4, 4, 4]) == (3, -1)\n    '''\n", "canonical_solution": "    def freq_search(lst):\n        frq = [0] * (max(lst) + 1)\n        for i in lst:\n            frq[i] += 1;\n\n        ans = -1\n        for i in range(1, len(frq)):\n            if frq[i] >= i:\n                ans = i\n        \n        return ans\n    \n    return (freq_search(lst1), freq_search(lst2))", "test": "\n\ndef check(candidate):\n\n    # manually generated tests\n    assert candidate([5, 5, 5, 5, 1], [1, 2, 3, 3, 3]) == (1,3)\n    assert candidate([4, 1, 4, 1, 4, 4], [1, 2, 2, 3, 4, 4]) == (4,2)\n    assert candidate([3, 3, 3, 3], [5, 5, 4, 4, 4]) == (3,-1)\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8], [5, 5, 5, 5, 1]) == (8,1)\n    assert candidate([2, 3, 3, 2, 2], [1, 4, 4, 1, 1, 1]) == (2,1)\n\n    # automatically generated tests\n    assert candidate([2, 2, 2, 3, 4, 4], [1, 2, 3, 3, 3]) == (2,3)\n    assert candidate([5, 5, 5, 5, 1], [1, 2, 3, 3, 3]) == (1,3)\n    assert candidate([4, 1, 4, 1, 4, 4], [1, 2, 2, 3, 4, 4]) == (4,2)\n    assert candidate([3, 3, 3, 3], [5, 5, 4, 4, 4]) == (3,-1)\n    assert candidate([8, 8, 8, 8, 8, 8, 8, 8], [5, 5, 5, 5, 1]) == (8,1)\n\n\n", "entry_point": "search_lst", "question": "Write a function def search_lst(lst1, lst2): to solve the following problem:\nYou are given two non-empty lists (lst1 and lst2) of positive integers. \n    In both lists return the greatest integer that is greater than zero, \n    and has a frequency greater than or equal to the value of the integer itself \n    in its own list. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist in either of the lists, return -1.\n    \n    Examples:\n        search_lst([4, 1, 2, 2, 3, 1], [1, 2, 2, 3, 3, 3]) == (2,3)\n        search_lst([5, 5, 5, 5, 1], [1, 2, 2, 3, 3, 3, 4, 4, 4, 4, 5]) == (1,4)\n        search_lst([3, 3, 3, 3], [5, 5, 4, 4, 4]) == (3, -1)\n", "context": "def search_lst(lst1, lst2):"}
{"key": 70, "prompt": "def strange_sort_list(lst):\n    '''\n    Given list of integers, return list in the strange order.\n    \n    Step 1:\n    From the beginning of the list, take a set of the next three integers.\n    \n    Step 2:\n    Sort this set in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n    \n    Step 3:\n    Replace the original three integers with the new set from step 2.\n    \n    Step 4:\n    Repeat from step 1 until the end of the list.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4, 5]) == [1, 3, 2, 4, 5]\n    strange_sort_list([5, 5, 5, 5, 3, 3, 2, 2]) == [5, 5, 5, 3, 5, 3, 2, 2]\n    strange_sort_list([]) == []\n    '''\n", "canonical_solution": "\n    for i in range(0, len(lst), 3):\n        temp_lst = lst[i:i+3]\n\n        res, switch = [], True\n        while temp_lst:\n            res.append(min(temp_lst) if switch else max(temp_lst))\n            temp_lst.remove(res[-1])\n            switch = not switch\n\n        lst[i:i+3] = res\n    return lst", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5]) == [1, 3, 2, 4, 5]\n    assert candidate([5, 6, 7, 8, 9]) == [5, 7, 6, 8, 9]\n    assert candidate([1, 2, 3, 4, 5, 6]) == [1, 3, 2, 4, 6, 5]\n    assert candidate([5, 6, 7, 8, 9, 1, 2]) == [5, 7, 6, 1, 9, 8, 2 ]\n    assert candidate([5, 5, 5, 5, 3, 3, 2, 2]) == [5, 5, 5, 3, 5, 3, 2, 2]\n    assert candidate([]) == []\n    assert candidate([1,2,3,4,5,6,7,8]) == [1, 3, 2, 4, 6, 5, 7, 8]\n    assert candidate([0,2,2,2,5,5,-5,-5]) == [0, 2, 2, 2, 5, 5, -5, -5]\n    assert candidate([111111]) == [111111]\n", "entry_point": "strange_sort_list", "question": "Write a function def strange_sort_list(lst): to solve the following problem:\nGiven list of integers, return list in the strange order.\n    \n    Step 1:\n    From the beginning of the list, take a set of the next three integers.\n    \n    Step 2:\n    Sort this set in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n    \n    Step 3:\n    Replace the original three integers with the new set from step 2.\n    \n    Step 4:\n    Repeat from step 1 until the end of the list.\n\n    Examples:\n    strange_sort_list([1, 2, 3, 4, 5]) == [1, 3, 2, 4, 5]\n    strange_sort_list([5, 5, 5, 5, 3, 3, 2, 2]) == [5, 5, 5, 3, 5, 3, 2, 2]\n    strange_sort_list([]) == []\n", "context": "def strange_sort_list(lst):"}
{"key": 71, "prompt": "\n\n\ndef triangle_area_and_perimeter(a, b, c):\n    \"\"\"\n    Given the lengths of the three sides of a triangle. Return the area and the perimeter of\n    the triangle with area being rounded off to 2 decimal points and perimeter as an integer. \n    Return the output as a list [area, perimeter].\n    If the three sides do not form a valid triangle, return -1 for both area and perimeter \n    [area, perimeter]. Area and perimeter are set to -1 if any of the sides is less than or equal to 0.\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area_and_perimeter(3, 4, 5) == [6.00, 12]\n    triangle_area_and_perimeter(1, 2, 10) == [-1, -1]\n    \"\"\"\n", "canonical_solution": "\n\n    if a <= 0 or b <= 0 or c <= 0 or a + b <= c or a + c <= b or b + c <= a:\n        return [-1, -1]\n    perimeter = a + b + c\n    s = perimeter/2    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return [area, perimeter]\n\n", "test": "\n\ndef check(candidate):\n\n    assert candidate(3, 4, 5) == [6.00, 12], \"Check simple case 1\"\n    assert candidate(1, 2, 10) == [-1, -1], \"Check invalid case\"\n    assert candidate(4, 8, 5) == [8.18, 17], \"Check simple case 2\"\n    assert candidate(2, 2, 2) == [1.73, 6], \"Check Equilateral triangle\"\n    assert candidate(1, 2, 3) == [-1, -1], \"Check case where triangle cannot be formed\"\n    assert candidate(10, 5, 7) == [16.25, 22], \"Check different sides of triangle\"\n    assert candidate(2, 6, 3) == [-1, -1], \"Check case with sides less than 3rd side\"\n    \n    assert candidate(0, 1, 1) == [-1, -1], \"Check edge case where one side is zero\"\n    assert candidate(1, 1, 1) == [0.43, 3], \"Check Equilateral triangle of unit length\"\n    assert candidate(2, -1, 10) == [-1, -1], \"Check edge case where one side is negative\"\n\n\n", "entry_point": "triangle_area_and_perimeter", "question": "Write a function def triangle_area_and_perimeter(a, b, c): to solve the following problem:\nGiven the lengths of the three sides of a triangle. Return the area and the perimeter of\n    the triangle with area being rounded off to 2 decimal points and perimeter as an integer. \n    Return the output as a list [area, perimeter].\n    If the three sides do not form a valid triangle, return -1 for both area and perimeter \n    [area, perimeter]. Area and perimeter are set to -1 if any of the sides is less than or equal to 0.\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    triangle_area_and_perimeter(3, 4, 5) == [6.00, 12]\n    triangle_area_and_perimeter(1, 2, 10) == [-1, -1]\n", "context": "def triangle_area_and_perimeter(a, b, c):"}
{"key": 72, "prompt": " \n\ndef will_it_fly_advanced(q,w,const_below):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list), the sum of its elements is less than or equal to the maximum possible weight w, and all of its elements are less or equal to the constant const_below.\n\n    Example:\n    will_it_fly_advanced([1, 2, 1], 5, 2) \u279e True \n    # 1+2+1 is less than the maximum possible weight, it's balanced, and all elements are less or equal to const_below = 2.\n\n    will_it_fly_advanced([3, 2, 3], 1, 5) \u279e False\n    # it's balanced, and all elements are less or equal to const_below = 5 but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly_advanced([3, 2, 3], 9, 2) \u279e False\n    # 3+2+3 is less than the maximum possible weight, and it's balanced, but 3> const_below = 2.\n\n    will_it_fly_advanced([3], 5, 3) \u279e True\n    # 3 is less than the maximum possible weight, it's balanced, and all elements are equal to const_below = 3.\n    '''\n", "canonical_solution": "\n\n    if sum(q) > w:\n        return False\n\n    if max(q) > const_below:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] != q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 2, 3], 9, 3) is True\n    assert candidate([1, 2, 1], 5, 2) is True\n    assert candidate([3], 5, 3) is True\n    assert candidate([3, 2, 3], 1, 5) is False\n    assert candidate([3, 2, 3], 9, 2) is False\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3], 6, 3) is False\n    assert candidate([5], 5, 6) is True\n    assert candidate([3, 5], 8, 4) is False\n", "entry_point": "will_it_fly_advanced", "question": "Write a function def will_it_fly_advanced(q,w,const_below): to solve the following problem:\nWrite a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list), the sum of its elements is less than or equal to the maximum possible weight w, and all of its elements are less or equal to the constant const_below.\n\n    Example:\n    will_it_fly_advanced([1, 2, 1], 5, 2) \u279e True \n    # 1+2+1 is less than the maximum possible weight, it's balanced, and all elements are less or equal to const_below = 2.\n\n    will_it_fly_advanced([3, 2, 3], 1, 5) \u279e False\n    # it's balanced, and all elements are less or equal to const_below = 5 but 3+2+3 is more than the maximum possible weight.\n\n    will_it_fly_advanced([3, 2, 3], 9, 2) \u279e False\n    # 3+2+3 is less than the maximum possible weight, and it's balanced, but 3> const_below = 2.\n\n    will_it_fly_advanced([3], 5, 3) \u279e True\n    # 3 is less than the maximum possible weight, it's balanced, and all elements are equal to const_below = 3.\n", "context": "def will_it_fly_advanced(q,w,const_below):"}
{"key": 73, "prompt": "\n\ndef smallest_change_k_steps(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, find the minimum number of elements that\n    need to be changed to make the array palindromic by only replacing k elements with any other number of your choice. \n    After that, return the possibility of making the array palindromic within k steps. If it's possible, \n    return True and the number of steps needed, if not, return False and -1. \n    \n    A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change_k_steps([1,2,3,5,4,7,9,6], 4) == (True, 4)\n    smallest_change_k_steps([1,2,3,5,4,7,9,6], 3) == (False, -1)\n    smallest_change_k_steps([1, 2, 3, 4, 3, 2, 2], 3) == (True, 1)\n    smallest_change_k_steps([1, 2, 3, 2, 1], 0) == (True, 0)\n    \"\"\"\n", "canonical_solution": "\n\n    ans = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[len(arr) - i - 1]:\n            ans += 1\n    if ans <= k:\n        return (True, ans)\n    else:\n        return (False, -1)\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,5,4,7,9,6], 4) == (True, 4)\n    assert candidate([1,2,3,5,4,7,9,6], 3) == (False, -1)\n    assert candidate([1, 2, 3, 4, 3, 2, 2], 3) == (True, 1)\n    assert candidate([1, 4, 2], 2) == (True, 1)\n    assert candidate([1, 4, 4, 2], 1) == (True, 1)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, 2, 1], 0) == (True, 0)\n    assert candidate([3, 1, 1, 3], 0) == (True, 0)\n    assert candidate([1], 0) == (True, 0)\n    assert candidate([0, 1], 1) == (True, 1)\n    assert candidate([0, 1], 0) == (False, -1)\n\n", "entry_point": "smallest_change_k_steps", "question": "Write a function def smallest_change_k_steps(arr, k): to solve the following problem:\nGiven an array arr of integers and a positive integer k, find the minimum number of elements that\n    need to be changed to make the array palindromic by only replacing k elements with any other number of your choice. \n    After that, return the possibility of making the array palindromic within k steps. If it's possible, \n    return True and the number of steps needed, if not, return False and -1. \n    \n    A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    smallest_change_k_steps([1,2,3,5,4,7,9,6], 4) == (True, 4)\n    smallest_change_k_steps([1,2,3,5,4,7,9,6], 3) == (False, -1)\n    smallest_change_k_steps([1, 2, 3, 4, 3, 2, 2], 3) == (True, 1)\n    smallest_change_k_steps([1, 2, 3, 2, 1], 0) == (True, 0)\n", "context": "def smallest_change_k_steps(arr, k):"}
{"key": 74, "prompt": "\ndef total_match_nb(lst1, lst2, n):\n    '''\n    Given two lists of strings and an integer n, write a function that returns the list that has \n    total number of chars in the all strings of the list less than n. If no list meets the condition, return an empty list.\n    If both lists have the same total number of characters and are less than n, return the first list.\n\n    Examples\n    total_match_nb([], [], 5) \u279e []\n    total_match_nb(['hi', 'admin'], ['hI', 'Hi'], 10) \u279e ['hI', 'Hi']\n    total_match_nb(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'], 20) \u279e ['hi', 'admin']\n    total_match_nb(['hi', 'admin'], ['hI', 'hi', 'hi'], 10) \u279e ['hI', 'hi', 'hi']\n    total_match_nb(['4'], ['1', '2', '3', '4', '5'], 5) \u279e ['4']\n    total_match_nb(['hi', 'admin'], ['hI', 'Hi'], 5) \u279e ['hI', 'Hi']\n    total_match_nb(['hi', 'admin'], ['hI', 'hi', 'hii'], 10) \u279e ['hi', 'admin']\n    '''\n", "canonical_solution": "\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 < n and l1 <= l2:\n        return lst1\n    elif l2 < n:\n        return lst2\n    else:\n        return []\n\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([], [], 5) == []\n    assert candidate(['hi', 'admin'], ['hI', 'Hi'], 10) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'], 20) == ['hi', 'admin']\n    assert candidate(['4'], ['1', '2', '3', '4', '5'], 5) == ['4']\n    assert candidate(['hi', 'admin'], ['hI', 'Hi'], 5) == ['hI', 'Hi']\n    assert candidate(['hi', 'admin'], ['hI', 'hi', 'hii'], 10) == ['hi', 'admin']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([], ['this'], 5) == []\n    assert candidate(['this'], [], 5) == []\n    assert candidate(['this'], ['this', 'this'], 10) == ['this']\n    assert candidate(['this', 'this'], ['this'], 20) == ['this']\n\n", "entry_point": "total_match_nb", "question": "Write a function def total_match_nb(lst1, lst2, n): to solve the following problem:\nGiven two lists of strings and an integer n, write a function that returns the list that has \n    total number of chars in the all strings of the list less than n. If no list meets the condition, return an empty list.\n    If both lists have the same total number of characters and are less than n, return the first list.\n\n    Examples\n    total_match_nb([], [], 5) \u279e []\n    total_match_nb(['hi', 'admin'], ['hI', 'Hi'], 10) \u279e ['hI', 'Hi']\n    total_match_nb(['hi', 'admin'], ['hi', 'hi', 'admin', 'project'], 20) \u279e ['hi', 'admin']\n    total_match_nb(['hi', 'admin'], ['hI', 'hi', 'hi'], 10) \u279e ['hI', 'hi', 'hi']\n    total_match_nb(['4'], ['1', '2', '3', '4', '5'], 5) \u279e ['4']\n    total_match_nb(['hi', 'admin'], ['hI', 'Hi'], 5) \u279e ['hI', 'Hi']\n    total_match_nb(['hi', 'admin'], ['hI', 'hi', 'hii'], 10) \u279e ['hi', 'admin']\n", "context": "def total_match_nb(lst1, lst2, n):"}
{"key": 75, "prompt": "\n\n\ndef is_multiply_n_primes(a, n):\n    \"\"\"Write a function that returns true if the given number a is the multiplication of n prime numbers\n    and false otherwise.\n    Knowing that (a) is less than 1000 and (n) is less than 10.  \n    Example:\n    is_multiply_n_primes(30, 2) == False\n    30 is the product of 2, 3, 5, so there are 3 prime factors\n    is_multiply_n_primes(30, 3) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n", "canonical_solution": "    def is_prime(i):\n        if i == 1: return False\n        for m in range(2, int(i**0.5)+1):\n            if i % m == 0:\n                return False\n        return True\n\n    count = 0\n    for i in range(2, 1001):\n        if not is_prime(i): continue\n        while a % i == 0 and is_prime(i):\n            a /= i\n            count += 1\n        if a == 1 or count > n: break\n\n    if count == n and a == 1: \n        return True\n    else:\n        return False", "test": "\n\ndef check(candidate):\n    assert candidate(5, 1) == True\n    assert candidate(30, 2) == False\n    assert candidate(138, 3) == True\n    assert candidate(1000, 4) == False\n    assert candidate(97, 1) == True\n    assert candidate(3 * 5 * 7, 3) == True\n    assert candidate(3 * 5 * 7 * 11, 4) == True\n    assert candidate(3 * 5 * 7 * 11 * 13, 5) == True\n    assert candidate(2 * 2 * 2, 3) == True\n    assert candidate(2 * 2 * 2, 2) == False\n\n", "entry_point": "is_multiply_n_primes", "question": "Write a function def is_multiply_n_primes(a, n): to solve the following problem:\nWrite a function that returns true if the given number a is the multiplication of n prime numbers\n    and false otherwise.\n    Knowing that (a) is less than 1000 and (n) is less than 10.  \n    Example:\n    is_multiply_n_primes(30, 2) == False\n    30 is the product of 2, 3, 5, so there are 3 prime factors\n    is_multiply_n_primes(30, 3) == True\n    30 = 2 * 3 * 5\n", "context": "def is_multiply_n_primes(a, n):"}
{"key": 76, "prompt": "\n\n\ndef is_power_of_x(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x can be expressed \n    as the power of number n. If the number `x` cannot be expressed as the power of `n` the function \n    should return False, if n^m = x for some integer m then the function should return the value of m.\n    For example:\n    is_power_of_x(64, 8) => 2. Because 8^2 = 64\n    is_power_of_x(9, 3) => 2. Because 3^2 = 9\n    is_power_of_x(5, 5) => 1. Because 5^1 = 5\n    is_power_of_x(2, 16) => False. Because There is no integer m such that 16^m = 2\n    is_power_of_x(9, 2) => False. Because There is no integer m such that 2^m = 9\n    \"\"\"\n", "canonical_solution": "\n\n    m = 0 \n    if x == 1: \n        return 0 \n    if n == 1: \n        return False \n    while x > 1: \n        if x % n != 0: \n            return False \n        x = x // n \n        m += 1 \n    return m \n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(16, 2)== 4, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(256, 2)== 8, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(81, 3)== 4, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(25, 5)== 2, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(16, 4)== 2, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(28, 2)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(130, 4)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(12, 6)== False, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 1)== 0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 16)== False, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(64, 8)== 2, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(100, 10)== 2, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "is_power_of_x", "question": "Write a function def is_power_of_x(x, n): to solve the following problem:\nYour task is to write a function that returns true if a number x can be expressed \n    as the power of number n. If the number `x` cannot be expressed as the power of `n` the function \n    should return False, if n^m = x for some integer m then the function should return the value of m.\n    For example:\n    is_power_of_x(64, 8) => 2. Because 8^2 = 64\n    is_power_of_x(9, 3) => 2. Because 3^2 = 9\n    is_power_of_x(5, 5) => 1. Because 5^1 = 5\n    is_power_of_x(2, 16) => False. Because There is no integer m such that 16^m = 2\n    is_power_of_x(9, 2) => False. Because There is no integer m such that 2^m = 9\n", "context": "def is_power_of_x(x, n):"}
{"key": 77, "prompt": "\ndef iscube_or_square(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this integer is either a cube or a square of some integer number and False otherwise.\n    Note: you may assume the input is always valid.\n    Section 1: return True if a is a perfect cube.\n    Section 2: return True if a is a perfect square.\n    Section 3: return False if a is neither a perfect cube nor square.\n    Examples:\n    iscube_or_square(1) ==> True (1 is both cube and square of 1)\n    iscube_or_square(4) ==> True (4 is a square of 2)\n    iscube_or_square(-1) ==> True (-1 is a cube of -1)\n    iscube_or_square(16) ==> True (16 is a square of 4)\n    iscube_or_square(0) ==> True (0 is both cube and square of 0)\n    iscube_or_square(10) ==> False (10 is neither a cube nor square)\n    '''\n", "canonical_solution": "    a = abs(a)\n    \n    # Section 1:\n    if int(round(a ** (1. / 3))) ** 3 == a:\n        return True\n    \n    # Section 2:\n    elif int(round(a ** .5)) ** 2 == a:\n        return True\n\n    # Section 3:\n    else:\n        return False", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(1) == True, \"First test error: \" + str(candidate(1))\n    assert candidate(4) == True, \"Second test error: \" + str(candidate(4))\n    assert candidate(-1) == True, \"Third test error: \" + str(candidate(-1))\n    assert candidate(16) == True, \"Fourth test error: \" + str(candidate(16))\n    assert candidate(10) == False, \"Fifth test error: \" + str(candidate(10))\n    assert candidate(1000) == True, \"Sixth test error: \" + str(candidate(1000))\n\n    # Check some edge cases that are easy to work out by hand \n    assert candidate(0) == True, \"1st edge test error: \" + str(candidate(0))\n    assert candidate(1728) == True, \"2nd edge test error: \" + str(candidate(1728))\n    assert candidate(1681) == True, \"3rd edge test error: \" + str(candidate(1681))\n    assert candidate(144) == True, \"4th edge test error: \" + str(candidate(144))\n    assert candidate(149) == False, \"5th edge test error: \" + str(candidate(149))\n", "entry_point": "iscube_or_square", "question": "Write a function def iscube_or_square(a): to solve the following problem:\nWrite a function that takes an integer a and returns True \n    if this integer is either a cube or a square of some integer number and False otherwise.\n    Note: you may assume the input is always valid.\n    Section 1: return True if a is a perfect cube.\n    Section 2: return True if a is a perfect square.\n    Section 3: return False if a is neither a perfect cube nor square.\n    Examples:\n    iscube_or_square(1) ==> True (1 is both cube and square of 1)\n    iscube_or_square(4) ==> True (4 is a square of 2)\n    iscube_or_square(-1) ==> True (-1 is a cube of -1)\n    iscube_or_square(16) ==> True (16 is a square of 4)\n    iscube_or_square(0) ==> True (0 is both cube and square of 0)\n    iscube_or_square(10) ==> False (10 is neither a cube nor square)\n", "context": "def iscube_or_square(a):"}
{"key": 78, "prompt": "\ndef hex_prime_key(str_list):\n    \"\"\"You have been tasked to write a function that receives \n    a list of hexadecimal numbers str_list as a strings and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty list, \n    and symbols A,B,C,D,E,F are always uppercase.\n    The function should return a list, where each element corresponds to the number of primes\n    in each string of the input list.\n    \n    Examples:\n    For str_list = [\"AB\", \"1077E\", \"ABED1A33\",\"123456789ABCDEF0\",\"2020\"] the output should be [1,2,4,6,2].\n    \"\"\"\n", "canonical_solution": "    primes = ('2', '3', '5', '7', 'B', 'D')\n    totals = []\n    for num in str_list:\n        total = 0\n        for i in range(0, len(num)):\n            if num[i] in primes:\n                total += 1\n        totals.append(total)\n    return totals", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"AB\",\"1077E\",\"ABED1A33\"]) == [1,2,4]\n    assert candidate([\"2020\",\"123456789ABCDEF0\",\"112233445566778899AABBCCDDEEFF00\"]) == [2,6,12]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([]) == []\n    assert candidate([\"\",\"\"]) == [0,0]\n", "entry_point": "hex_prime_key", "question": "Write a function def hex_prime_key(str_list): to solve the following problem:\nYou have been tasked to write a function that receives \n    a list of hexadecimal numbers str_list as a strings and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty list, \n    and symbols A,B,C,D,E,F are always uppercase.\n    The function should return a list, where each element corresponds to the number of primes\n    in each string of the input list.\n    \n    Examples:\n    For str_list = [\"AB\", \"1077E\", \"ABED1A33\",\"123456789ABCDEF0\",\"2020\"] the output should be [1,2,4,6,2].\n", "context": "def hex_prime_key(str_list):"}
{"key": 79, "prompt": "\n\ndef decimal_to_binary_hex(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to binary \n    and hexadecimal format. The function should return a dictionary, with each key representing \n    a type of format ('binary' or 'hexadecimal') and each value is a corresponding formatted string.\n    Each character in the binary string will be '0' or '1' with the extra characters 'db' at the \n    beginning and the end of the string to help with the format. The hexadecimal string will have \n    the prefix '0x'.\n    \n    Examples:\n    decimal_to_binary_hex(15) # returns {\"binary\": \"db1111db\", \"hexadecimal\": \"0xf\"}\n    decimal_to_binary_hex(32) # returns {\"binary\": \"db100000db\", \"hexadecimal\": \"0x20\"}\n    \"\"\"\n", "canonical_solution": "\n\n    return {\"binary\": \"db\"+bin(decimal)[2:]+\"db\", \"hexadecimal\": hex(decimal)}\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(0) == {\"binary\": \"db0db\", \"hexadecimal\": \"0x0\"}\n    assert candidate(32) == {\"binary\": \"db100000db\", \"hexadecimal\": \"0x20\"}\n    assert candidate(103) == {\"binary\": \"db1100111db\", \"hexadecimal\": \"0x67\"}\n    assert candidate(15) == {\"binary\": \"db1111db\", \"hexadecimal\": \"0xf\"}\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(255) == {\"binary\": \"db11111111db\", \"hexadecimal\": \"0xff\"}\n\n", "entry_point": "decimal_to_binary_hex", "question": "Write a function def decimal_to_binary_hex(decimal): to solve the following problem:\nYou will be given a number in decimal form and your task is to convert it to binary \n    and hexadecimal format. The function should return a dictionary, with each key representing \n    a type of format ('binary' or 'hexadecimal') and each value is a corresponding formatted string.\n    Each character in the binary string will be '0' or '1' with the extra characters 'db' at the \n    beginning and the end of the string to help with the format. The hexadecimal string will have \n    the prefix '0x'.\n    \n    Examples:\n    decimal_to_binary_hex(15) # returns {\"binary\": \"db1111db\", \"hexadecimal\": \"0xf\"}\n    decimal_to_binary_hex(32) # returns {\"binary\": \"db100000db\", \"hexadecimal\": \"0x20\"}\n", "context": "def decimal_to_binary_hex(decimal):"}
{"key": 80, "prompt": "\ndef is_extremely_happy(s):\n    \"\"\"\n    You are given a string s.\n    Your task is to check if the string is extremely happy or not.\n    A string is extremely happy if the string has at least 6 characters, none of the characters are repeating consecutively,\n    and every 3 consecutive letters are distinct and the next 3 letters are not the same as the previous 3.\n    Therefore, in one cycle, no letters can be repeated more than once.\n    For example:\n    is_extremely_happy(a) => False\n    is_extremely_happy(aa) => False\n    is_extremely_happy(abcd) => False\n    is_extremely_happy(aabb) => False\n    is_extremely_happy(adb) => False\n    is_extremely_happy(xyaopq) => True\n    \"\"\"\n", "canonical_solution": "\n    if len(s) < 6:\n        return False\n\n    for i in range(len(s) - 2):\n        if i + 3 < len(s):\n            first_batch = [s[i], s[i+1], s[i+2]]\n            second_batch = [s[i+3], s[i+4], s[i+5]] if i + 5 < len(s) else []\n            if len(first_batch) != len(set(first_batch)) or len(second_batch) != len(set(second_batch)) or first_batch == second_batch:\n                return False\n    return True\n", "test": "\ndef check(candidate):\n    # Check some simple cases\n    assert candidate(\"a\") == False , \"a\"\n    assert candidate(\"aa\") == False , \"aa\"\n    assert candidate(\"abcd\") == False , \"abcd\"\n    assert candidate(\"aabb\") == False , \"aabb\"\n    assert candidate(\"adb\") == False , \"adb\"\n    assert candidate(\"abca\") == False , \"abca\"\n    assert candidate(\"abcabc\") == False , \"abcabc\"\n    assert candidate(\"xyaopq\") == True , \"xyaopq\"\n    assert candidate(\"iqwrtyiop\") == True , \"iqwrtyiop\"\n    assert candidate(\"iqwrtyioi\") == False , \"iqwrtyioi\"\n", "entry_point": "is_extremely_happy", "question": "Write a function def is_extremely_happy(s): to solve the following problem:\nYou are given a string s.\n    Your task is to check if the string is extremely happy or not.\n    A string is extremely happy if the string has at least 6 characters, none of the characters are repeating consecutively,\n    and every 3 consecutive letters are distinct and the next 3 letters are not the same as the previous 3.\n    Therefore, in one cycle, no letters can be repeated more than once.\n    For example:\n    is_extremely_happy(a) => False\n    is_extremely_happy(aa) => False\n    is_extremely_happy(abcd) => False\n    is_extremely_happy(aabb) => False\n    is_extremely_happy(adb) => False\n    is_extremely_happy(xyaopq) => True\n", "context": "def is_extremely_happy(s):"}
{"key": 81, "prompt": "\n\ndef numerical_letter_grade_and_class_avg(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n    Furthermore, the teacher also wants to calculate the average GPA of the class.\n    Your function should return a tuple where the first element is the list \n    of letter grades and the second element is the average GPA of the class.\n\n    Example:\n    numerical_letter_grade_and_class_avg([4.0, 3, 1.7, 2, 3.5]) ==> (['A+', 'B', 'C-', 'C', 'A-'], 2.84)\n    \"\"\"\n", "canonical_solution": "    letter_grade = []\n    total = 0\n    for gpa in grades:\n        total += gpa\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E\")\n    if len(grades) > 0:    \n        average = round(total/len(grades), 2)\n    else:\n        average = 0    \n    return (letter_grade, average)", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([4.0, 3, 1.7, 2, 3.5]) == (['A+', 'B', 'C-', 'C', 'A-'], 2.84)\n    assert candidate([1.2]) == (['D+'], 1.2)\n    assert candidate([0.5]) == (['D-'], 0.5)\n    assert candidate([0.0]) == (['E'], 0)\n    assert candidate([1, 0.3, 1.5, 2.8, 3.3]) == (['D', 'D-', 'C-', 'B', 'B+'], 1.78)\n    assert candidate([0, 0.7]) == (['E', 'D-'], 0.35)\n\n    # Check an edge case where no grades are provided.\n    assert candidate([]) == ([], 0)\n\n    print(\"All checks pass.\")\n\n", "entry_point": "numerical_letter_grade_and_class_avg", "question": "Write a function def numerical_letter_grade_and_class_avg(grades): to solve the following problem:\nIt is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write\n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n    Furthermore, the teacher also wants to calculate the average GPA of the class.\n    Your function should return a tuple where the first element is the list \n    of letter grades and the second element is the average GPA of the class.\n\n    Example:\n    numerical_letter_grade_and_class_avg([4.0, 3, 1.7, 2, 3.5]) ==> (['A+', 'B', 'C-', 'C', 'A-'], 2.84)\n", "context": "def numerical_letter_grade_and_class_avg(grades):"}
{"key": 82, "prompt": "\n\ndef prime_length_substring(string, substring):\n    \"\"\"Write a function that takes a string and a substring as input. \n    The function should first check if the substring exists in the string. \n    If it does, the function should return 'substring found!' and check whether the \n    length of the substring is a prime number, returning True if it is and False \n    otherwise.\n    If the substring is not found in the string, the function should return\n    'substring not found!'. \n\n    Examples\n    prime_length_substring('Hello world', 'Hello') == ('substring found!', True)\n    prime_length_substring('abcdcba', 'abc') == ('substring found!', True)\n    prime_length_substring('kittens', 'cat') == ('substring not found!')\n    prime_length_substring('orange', 'a') == ('substring found!', False)\n\n    \"\"\"\n", "canonical_solution": "\n\n    if substring in string:\n        l = len(substring)\n        if l == 0 or l == 1:\n            return ('substring found!', False)\n        for i in range(2, l):\n            if l % i == 0:\n                return ('substring found!', False)\n        return ('substring found!', True)\n    else:\n        return 'substring not found!'\n", "test": "\n\ndef check(candidate):\n\n    assert candidate('Hello world', 'Hello') == ('substring found!', True)\n    assert candidate('abcdcba', 'abc') == ('substring found!', True)\n    assert candidate('kittens', 'cat') == ('substring not found!')\n    assert candidate('orange', 'a') == ('substring found!', False)\n    assert candidate('wow', 'ow') == ('substring found!', True)\n    assert candidate('world', 'l') == ('substring found!', False)\n    assert candidate('MadaM', 'ada') == ('substring found!', True)\n    assert candidate('Wow', 'w') == ('substring found!', False)\n    assert candidate('', 'a') == ('substring not found!')\n    assert candidate('HI', 'I') == ('substring found!', False)\n    assert candidate('go', 'go') == ('substring found!', True)\n    assert candidate('gogo', 'go') == ('substring found!', True)\n    assert candidate('aaaaaaaaaaaaaaa', 'aaa') == ('substring found!', True)\n\n    assert candidate('Madam', 'M') == ('substring found!', False)\n    assert candidate('0', '00') == ('substring not found!')\n\n", "entry_point": "prime_length_substring", "question": "Write a function def prime_length_substring(string, substring): to solve the following problem:\nWrite a function that takes a string and a substring as input. \n    The function should first check if the substring exists in the string. \n    If it does, the function should return 'substring found!' and check whether the \n    length of the substring is a prime number, returning True if it is and False \n    otherwise.\n    If the substring is not found in the string, the function should return\n    'substring not found!'. \n\n    Examples\n    prime_length_substring('Hello world', 'Hello') == ('substring found!', True)\n    prime_length_substring('abcdcba', 'abc') == ('substring found!', True)\n    prime_length_substring('kittens', 'cat') == ('substring not found!')\n    prime_length_substring('orange', 'a') == ('substring found!', False)\n", "context": "def prime_length_substring(string, substring):"}
{"key": 83, "prompt": "\n\ndef starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1, 2, or 3.\n    \"\"\"\n", "canonical_solution": "\n\n    if n == 1: return 1\n    return 54 * (10 ** (n - 2))\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(1) == 1\n    assert candidate(2) == 54\n    assert candidate(3) == 540\n    assert candidate(4) == 5400\n    assert candidate(5) == 54000\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "starts_one_ends", "question": "Write a function def starts_one_ends(n): to solve the following problem:\nGiven a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1, 2, or 3.\n", "context": "def starts_one_ends(n):"}
{"key": 84, "prompt": "\ndef solve(N):\n    \"\"\"Given a positive integer N, first find the sum of its digits. Make this sum part of \n       a list where each element denotes sum of digits of a number starting from 1 up to N.\n       Finally, convert this list of sums into binary format and return it.\n    \n    For example,\n        For N = 3, the sum of digits for 1 is 1, for 2 is 2 and for 3 is 3. \n        So, the list of sums will be [1, 2, 3] and in binary it will be ['1', '10', '11'].\n\n        For N = 5, the sum of digits for 1 is 1, for 2 is 2, for 3 is 3, for 4 is 4 and for 5 is 5. \n        So, the list of sums will be [1, 2, 3, 4, 5] and in binary it will be ['1', '10', '11', '100', '101'].\n\n    Variables:\n        @N integer: An positive integer.\n             Constraints: 0 \u2264 N \u2264 100.\n\n    Output:\n        a list of strings where each string is a binary number.\n    \"\"\"\n", "canonical_solution": "\n    return [bin(sum(int(i) for i in str(j)))[2:] for j in range(1, N+1)]\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(3) == ['1', '10', '11'], \"Error\"\n    assert candidate(5) == ['1', '10', '11', '100', '101'], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(2) == ['1', '10'], \"Error\"\n    assert candidate(7) == ['1', '10', '11', '100', '101', '110', '111'], \"Error\"\n", "entry_point": "solve", "question": "Write a function def solve(N): to solve the following problem:\nGiven a positive integer N, first find the sum of its digits. Make this sum part of \n       a list where each element denotes sum of digits of a number starting from 1 up to N.\n       Finally, convert this list of sums into binary format and return it.\n    \n    For example,\n        For N = 3, the sum of digits for 1 is 1, for 2 is 2 and for 3 is 3. \n        So, the list of sums will be [1, 2, 3] and in binary it will be ['1', '10', '11'].\n\n        For N = 5, the sum of digits for 1 is 1, for 2 is 2, for 3 is 3, for 4 is 4 and for 5 is 5. \n        So, the list of sums will be [1, 2, 3, 4, 5] and in binary it will be ['1', '10', '11', '100', '101'].\n\n    Variables:\n        @N integer: An positive integer.\n             Constraints: 0 \u2264 N \u2264 100.\n\n    Output:\n        a list of strings where each string is a binary number.\n", "context": "def solve(N):"}
{"key": 85, "prompt": "\n\n\ndef add(lst, n):\n    \"\"\"Given a non-empty list of integers lst and an integer n. add the even elements that are at odd indices in the list lst and then subtract the nth element from the result..\n\n    Examples:\n        add([4, 2, 6, 7], 1) ==> 2 - 2 = 0 \n    \"\"\"\n", "canonical_solution": "\n\n    return sum([lst[i] for i in range(1, len(lst), 2) if lst[i]%2 == 0]) - lst[n]\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([4, 88], 0) == 88 - 4\n    assert candidate([4, 5, 6, 7, 2, 122], 2) == 122 - 6\n    assert candidate([4, 0, 6, 7], 1) == 0 - 0\n    assert candidate([4, 4, 6, 8], 3) == 12 -8\n\n    # Check some edge cases that are easy to work out by hand. \n\n", "entry_point": "add", "question": "Write a function def add(lst, n): to solve the following problem:\nGiven a non-empty list of integers lst and an integer n. add the even elements that are at odd indices in the list lst and then subtract the nth element from the result..\n\n    Examples:\n        add([4, 2, 6, 7], 1) ==> 2 - 2 = 0\n", "context": "def add(lst, n):"}
{"key": 86, "prompt": "\ndef anti_shuffle_and_replace(s, rdict):\n    \"\"\"\n    Write a function anti_shuffle_and_replace() that takes two inputs - a string s and a replacement dictionary rdict.\n    \n    The function should first perform an operation similar to function 'anti_shuffle'. 'anti_shuffle' returns an ordered \n    version of string s, where all words (separated by space) are replaced by a new word with all the characters arranged \n    in ascending order based on ascii value keeping the order of words and spaces in the sentence.\n    \n    After performing 'anti_shuffle', the function should then replace the words (if present in rdict) based on the \n    key-value pairs provided in rdict.\n\n    For example:\n    anti_shuffle_and_replace('Hi', {}) returns 'Hi'\n    anti_shuffle_and_replace('hello',{'ehllo':'HELLO'}) returns 'HELLO'\n    anti_shuffle_and_replace('Hello World!!!', {'Hello':'HELLO', '!!!Wdlor':'WORLD!!!'}) returns 'HELLO WORLD!!!'\n    \"\"\"\n", "canonical_solution": "\n    s = ' '.join([''.join(sorted(list(i))) for i in s.split(' ')])\n    for k, v in rdict.items():\n        s = s.replace(k, v)\n    return s\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate('Hi', {}) == 'Hi'\n    assert candidate('hello', {'ehllo':'HELLO'}) == 'HELLO'\n    assert candidate('Hello World!!!', {'Hello':'HELLO', '!!!Wdlor':'WORLD!!!'}) == 'HELLO WORLD!!!'\n    assert candidate('Hi. My name is Mister Robot. How are you?', \n                     {'.Hi':'Hi.', 'My':'my', 'aemn':'name', 'is':'is', \n                      'Meirst':'Mister', '.Rboot':'Robot.', 'How':'How', \n                      'aer':'are', '?ouy':'you?'}) == 'Hi. my name is Mister Robot. How are you?'\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "anti_shuffle_and_replace", "question": "Write a function def anti_shuffle_and_replace(s, rdict): to solve the following problem:\nWrite a function anti_shuffle_and_replace() that takes two inputs - a string s and a replacement dictionary rdict.\n    \n    The function should first perform an operation similar to function 'anti_shuffle'. 'anti_shuffle' returns an ordered \n    version of string s, where all words (separated by space) are replaced by a new word with all the characters arranged \n    in ascending order based on ascii value keeping the order of words and spaces in the sentence.\n    \n    After performing 'anti_shuffle', the function should then replace the words (if present in rdict) based on the \n    key-value pairs provided in rdict.\n\n    For example:\n    anti_shuffle_and_replace('Hi', {}) returns 'Hi'\n    anti_shuffle_and_replace('hello',{'ehllo':'HELLO'}) returns 'HELLO'\n    anti_shuffle_and_replace('Hello World!!!', {'Hello':'HELLO', '!!!Wdlor':'WORLD!!!'}) returns 'HELLO WORLD!!!'\n", "context": "def anti_shuffle_and_replace(s, rdict):"}
{"key": 87, "prompt": "\n\ndef get_lst_coords(lst, x, y):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integers x, y, find all occurrences of both x and y in the list,\n    and return two lists of tuples. The first list should consist of tuples [(x1, y1), (x2, y2) ...] \n    and the second list [(z1, w1), (z2, w2) ...], such that each tuple is a coordinate (row, column),\n    starting with 0, where xi, zi and yi, wi are the row and column coordinates of x and y, respectively.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_lst_coords([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1, 2) should return ([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)],[(0, 1),(1, 1),(2, 1)])\n\n    get_lst_coords([], 1 ,2) should return ([],[])\n    \n    get_lst_coords([[], [1], [1, 2, 3]], 3, 1) should return ([(2, 2)],[(1, 0),(2, 0)])\n    \"\"\"\n", "canonical_solution": "    coords_x = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    coords_y = [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == y]\n    return sorted(sorted(coords_x, key=lambda x: x[1], reverse=True), key=lambda x: x[0]), sorted(sorted(coords_y, key=lambda x: x[1], reverse=True), key=lambda x: x[0])", "test": "\n\ndef check(candidate):\n    \n    # Check some simple cases\n    assert candidate([\n        [1,2,3,4,5,6],\n        [1,2,3,4,1,6],\n        [1,2,3,4,5,1]\n    ], 1, 2) == ([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)],[(0, 1),(1, 1),(2, 1)])\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([], 1 ,2) == ([],[])\n    assert candidate([[], [1], [1, 2, 3]], 3, 1) == ([(2, 2)],[(1, 0),(2, 0)])\n    assert candidate([[1,3]], 3, 1) == ([(0, 1)], [(0, 0)])\n    assert candidate([[1,1],[2,2]], 3, 4) == ([],[])\n\n    assert True\n\n", "entry_point": "get_lst_coords", "question": "Write a function def get_lst_coords(lst, x, y): to solve the following problem:\nYou are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integers x, y, find all occurrences of both x and y in the list,\n    and return two lists of tuples. The first list should consist of tuples [(x1, y1), (x2, y2) ...] \n    and the second list [(z1, w1), (z2, w2) ...], such that each tuple is a coordinate (row, column),\n    starting with 0, where xi, zi and yi, wi are the row and column coordinates of x and y, respectively.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_lst_coords([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1, 2) should return ([(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)],[(0, 1),(1, 1),(2, 1)])\n\n    get_lst_coords([], 1 ,2) should return ([],[])\n    \n    get_lst_coords([[], [1], [1, 2, 3]], 3, 1) should return ([(2, 2)],[(1, 0),(2, 0)])\n", "context": "def get_lst_coords(lst, x, y):"}
{"key": 88, "prompt": "\n\ndef sort_and_modify_array(array, step):\n    \"\"\"\n    Given an array of non-negative integers, return a new array that is a modified version of the sorted array.\n    \n    First, you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n    \n    Then, you will increase every number in the sorted array by the given 'step'.\n    \n    Note:\n    * don't change the given array.\n    \n    Examples:\n    * sort_and_modify_array([], 2) => []\n    * sort_and_modify_array([5], 3) => [8]\n    * sort_and_modify_array([2, 4, 3, 0, 1, 5], 1) => [1, 2, 3, 4, 5, 6]\n    * sort_and_modify_array([2, 4, 3, 0, 1, 5, 6], 2) => [8, 7, 6, 5, 4, 3, 2]\n    \"\"\"\n", "canonical_solution": "\n\n    return [x + step for x in (sorted(array, reverse= (array[0]+array[-1]) % 2 == 0) if array else [])]\n\n", "test": "\n\ndef check(candidate):\n    \n    assert candidate([], 2) == [], \"Error\"\n    assert candidate([5], 3) == [8], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5], 1) == [1, 2, 3, 4, 5, 6], \"Error\"\n    assert candidate([2, 4, 3, 0, 1, 5, 6], 2) == [8, 7, 6, 5, 4, 3, 2], \"Error\"\n    \n    assert candidate([2, 1], 1) == [2, 3], \"Error\"\n    assert candidate([15, 42, 87, 32 ,11, 0], 5) == [5, 16, 20, 37, 47, 92], \"Error\"\n    assert candidate([21, 14, 23, 11], 3) == [26, 24, 17, 14], \"Error\"\n    \n    \n", "entry_point": "sort_and_modify_array", "question": "Write a function def sort_and_modify_array(array, step): to solve the following problem:\nGiven an array of non-negative integers, return a new array that is a modified version of the sorted array.\n    \n    First, you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n    \n    Then, you will increase every number in the sorted array by the given 'step'.\n    \n    Note:\n    * don't change the given array.\n    \n    Examples:\n    * sort_and_modify_array([], 2) => []\n    * sort_and_modify_array([5], 3) => [8]\n    * sort_and_modify_array([2, 4, 3, 0, 1, 5], 1) => [1, 2, 3, 4, 5, 6]\n    * sort_and_modify_array([2, 4, 3, 0, 1, 5, 6], 2) => [8, 7, 6, 5, 4, 3, 2]\n", "context": "def sort_and_modify_array(array, step):"}
{"key": 89, "prompt": "def advanced_encrypt(s, step):\n    \"\"\"Create a function advanced_encrypt that takes a string and an integer step \n    as arguments and returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters shift down \n    by the step value multiplied by two places. \n    For example:\n    advanced_encrypt('hi', 2) returns 'lm'\n    advanced_encrypt('asdfghjkl', 1) returns 'cufhijlmn'\n    advanced_encrypt('gf',3) returns 'ml'\n    advanced_encrypt('et', 4) returns 'mb'\n    \"\"\"\n", "canonical_solution": "\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for letter in s:\n        if letter in alphabet:\n            out += alphabet[(alphabet.index(letter)+step*2) % 26]\n        else:\n            out += letter\n    return out", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('hi', 2) == 'lm', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('asdfghjkl', 1) == 'cufhijlmn', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('gf',3) == 'ml', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('et', 4) == 'mb', \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate('faewfawefaewg', 5) == 'pkogpkgopkogq', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('hellomyfriend', 6) == 'tqxxaykrduqzp', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh',7) == 'rlnrzabwztivawzitvzwvitbazwabitvzwabitvtiqitv', \"This prints if this assert fails 3 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('a',5) == 'k', \"This prints if this assert fails 2 (also good for debugging!)\"", "entry_point": "advanced_encrypt", "question": "Write a function def advanced_encrypt(s, step): to solve the following problem:\nCreate a function advanced_encrypt that takes a string and an integer step \n    as arguments and returns a string encrypted with the alphabet being rotated.\n    The alphabet should be rotated in a manner such that the letters shift down \n    by the step value multiplied by two places. \n    For example:\n    advanced_encrypt('hi', 2) returns 'lm'\n    advanced_encrypt('asdfghjkl', 1) returns 'cufhijlmn'\n    advanced_encrypt('gf',3) returns 'ml'\n    advanced_encrypt('et', 4) returns 'mb'\n", "context": "def advanced_encrypt(s, step):"}
{"key": 90, "prompt": "\n\n\ndef next_smallest(lst, k):\n    \"\"\"\n    You are given a list of integers and an integer k.\n    Write a function next_smallest() that returns the k-th smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5], 2) == 2\n    next_smallest([5, 1, 4, 3, 2], 3) == 3\n    next_smallest([], 1) == None\n    next_smallest([1, 1], 2) == None\n    \"\"\"\n", "canonical_solution": "\n\n    lst = sorted(set(lst))\n    return None if len(lst) < k else lst[k-1]\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4, 5], 2) == 2\n    assert candidate([5, 1, 4, 3, 2], 3) == 3\n    assert candidate([], 1) == None\n    assert candidate([1, 1], 2) == None\n    assert candidate([1,1,1,1,0], 2) == 1\n    assert candidate([1, 2, 3, 4, 5], 1) == 1\n    assert candidate([1, 0**0, 2, 3], 2) == 2\n    assert candidate([-35, 34, 12, -45], 2) == -35\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n\n", "entry_point": "next_smallest", "question": "Write a function def next_smallest(lst, k): to solve the following problem:\nYou are given a list of integers and an integer k.\n    Write a function next_smallest() that returns the k-th smallest element of the list.\n    Return None if there is no such element.\n    \n    next_smallest([1, 2, 3, 4, 5], 2) == 2\n    next_smallest([5, 1, 4, 3, 2], 3) == 3\n    next_smallest([], 1) == None\n    next_smallest([1, 1], 2) == None\n", "context": "def next_smallest(lst, k):"}
{"key": 91, "prompt": "\ndef is_bored(S, start):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word provided in \n    the 'start' parameter.\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\", \"Hello\")\n    1\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\", \"The\")\n    2\n    \"\"\"\n", "canonical_solution": "\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence.startswith(start) for sentence in sentences)\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Hello world\", \"Hello\") == 1, \"Test 1\"\n    assert candidate(\"Is the sky blue?\", \"Is\") == 1, \"Test 2\"\n    assert candidate(\"I love It !\", \"I\") == 1, \"Test 3\"\n    assert candidate(\"bIt\", \"b\") == 1, \"Test 4\"\n    assert candidate(\"I feel good today. I will be productive. will kill It\", \"I\") == 2, \"Test 5\"\n    assert candidate(\"You and I are going for a walk\", \"You\") == 1, \"Test 6\"\n\n    # Check some edge cases\n    assert candidate(\"This is a sentence. This is another sentence.\", \"This\") == 2, \"Test 7\"\n    assert candidate(\"Hello! How are you? I am fine. Thanks for asking.\", \"Hello\") == 1, \"Test 8\" \n\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n", "entry_point": "is_bored", "question": "Write a function def is_bored(S, start): to solve the following problem:\nYou'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word provided in \n    the 'start' parameter.\n    Sentences are delimited by '.', '?' or '!'.\n\n    For example:\n    >>> is_bored(\"Hello world\", \"Hello\")\n    1\n    >>> is_bored(\"The sky is blue. The sun is shining. I love this weather\", \"The\")\n    2\n", "context": "def is_bored(S, start):"}
{"key": 92, "prompt": "\n\ndef any_number(numbers):\n    '''\n    Create a function that takes a list of numbers.\n    Returns true if ANY one of the numbers is equal to the sum of any TWO other numbers in the list, and all numbers are integers.\n    Returns false in any other cases or if list is empty.\n    \n    Examples\n    any_number([5, 2, 7]) \u279e True\n    \n    any_number([3, 2, 2]) \u279e False\n\n    any_number([3, -2, 1]) \u279e True\n    \n    any_number([3.6, -2.2, 2]) \u279e False\n    \n    any_number([]) \u279e False\n\n    any_number([1, 2, 3, 4, 5, 9]) \u279e True  # 4 + 5 = 9\n\n    '''\n", "canonical_solution": "    if numbers==[]:\n        return False\n    for i in numbers:\n        if not isinstance(i,int):\n            return False\n\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            for k in range(len(numbers)):\n                if k!=i and k!=j and numbers[i]+numbers[j]==numbers[k]:\n                    return True\n    return False", "test": "\n\ndef check(candidate):\n\n    assert candidate([2, 3, 1])==True, \"Assert fails for case 1!\"\n    assert candidate([2.5, 2, 3])==False, \"Assert fails for case 2!\"\n    assert candidate([1.5, 5, 3.5])==False, \"Assert fails for case 3!\"\n    assert candidate([2, 6, 2])==False, \"Assert fails for case 4!\"\n    assert candidate([4, 2, 2])==True, \"Assert fails for case 5!\"\n    assert candidate([2.2, 2.2, 2.2])==False, \"Assert fails for case 6!\"\n    assert candidate([-4, 6, 2])==True, \"Assert fails for case 7!\"\n    assert candidate([2,1,1])==True, \"Assert fails for case 8!\"\n    assert candidate([3,4,7])==True, \"Assert fails for case 9!\"\n    assert candidate([3.0,4,7])==False, \"Assert fails for case 10!\"\n    assert candidate([])==False, \"Assert fails for case 11!\"\n    assert candidate([1, 2, 3, 4, 5, 9])==True, \"Assert fails for case 12!\"\n\n", "entry_point": "any_number", "question": "Write a function def any_number(numbers): to solve the following problem:\nCreate a function that takes a list of numbers.\n    Returns true if ANY one of the numbers is equal to the sum of any TWO other numbers in the list, and all numbers are integers.\n    Returns false in any other cases or if list is empty.\n    \n    Examples\n    any_number([5, 2, 7]) \u279e True\n    \n    any_number([3, 2, 2]) \u279e False\n\n    any_number([3, -2, 1]) \u279e True\n    \n    any_number([3.6, -2.2, 2]) \u279e False\n    \n    any_number([]) \u279e False\n\n    any_number([1, 2, 3, 4, 5, 9]) \u279e True  # 4 + 5 = 9\n", "context": "def any_number(numbers):"}
{"key": 93, "prompt": "def complex_encode(message, n):\n    \"\"\"\n    Write a function that takes a message and an integer n, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears n places ahead of that \n    vowel in the English alphabet. If the replacement character reaches 'z' or 'Z', it should wrap around to the \n    beginning of the alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> complex_encode('test', 2)\n    'TGST'\n    >>> complex_encode('This is a message', 3)\n    'tHLS LS D MHSSDGH'\n    \"\"\"\n", "canonical_solution": "    \n    import string\n    vowels = \"aeiouAEIOU\"\n    lower_alphabet = string.ascii_lowercase * 2\n    upper_alphabet = string.ascii_uppercase * 2\n    vowels_replace = {vowel: (lower_alphabet[lower_alphabet.index(vowel) + n] if vowel.islower() \n                              else upper_alphabet[upper_alphabet.index(vowel) + n]) for vowel in vowels}\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('TEST', 2) == 'tgst', \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate('Mudasir', 3) == 'mXDDSLR', \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate('YES', 4) == 'yis', \"This prints if this assert fails 3 (good for debugging!)\"\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('This is a message', 3) == 'tHLS LS D MHSSDGH', \"This prints if this assert fails 4 (also good for debugging!)\"\n    assert candidate(\"I DoNt KnOw WhAt tO WrItE\", 5) == 'n dTnT kNtW wHfT Tt wRnTj', \"This prints if this assert fails 5 (also good for debugging!)\"\n", "entry_point": "complex_encode", "question": "Write a function def complex_encode(message, n): to solve the following problem:\nWrite a function that takes a message and an integer n, and encodes in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears n places ahead of that \n    vowel in the English alphabet. If the replacement character reaches 'z' or 'Z', it should wrap around to the \n    beginning of the alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> complex_encode('test', 2)\n    'TGST'\n    >>> complex_encode('This is a message', 3)\n    'tHLS LS D MHSSDGH'\n", "context": "def complex_encode(message, n):"}
{"key": 94, "prompt": "\ndef find_large_prime_sum(lst, p):\n    \"\"\"\n    You are given a list of integers and a prime p.\n    You are to find the largest prime less than p in the input list and return the sum of its digits.\n    If no such prime exists, return -1.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3], p = 10; the output should be 7\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1], p = 4597; the output should be 5\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3], p = 163; the output should be 10 \n    For lst = [0,8,1,2,1,7], p = 5; the output should be 2\n    \"\"\"\n", "canonical_solution": "    def isPrime(n):\n        if n < 2:\n            return False\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return False\n        return True\n\n    prime_max = -1\n    for num in lst:\n        if num < p and isPrime(num) and num > prime_max:\n            prime_max = num\n\n    if prime_max != -1:\n        return sum(int(d) for d in str(prime_max))\n    else:\n        return -1", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3], 10) == 7, \"Failed on first case\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1], 4597) == 5, \"Failed on second case\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3], 163) == 10, \"Failed on third case\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,8,1,2,1,7], 5) == 2, \"Failed on fourth case\"\n    \n    # Check when there is no prime number in the list that is less than p.\n    assert candidate([11,22,33,44,55,66], 10) == -1, \"Failed on fifth case\"\n    \n    # Check when p is the smallest prime number.\n    assert candidate([2,3,5,7,11,13,17], 2) == -1, \"Failed on sixth case\"\n\n    assert candidate([8191], 8192) == 19, \"Failed on seventh case\"\n    assert candidate([8191, 123456, 127, 7], 10000) == 19, \"Failed on eighth case\"\n    assert candidate([127, 97, 8192], 100) == 16, \"Failed on ninth case\"\n", "entry_point": "find_large_prime_sum", "question": "Write a function def find_large_prime_sum(lst, p): to solve the following problem:\nYou are given a list of integers and a prime p.\n    You are to find the largest prime less than p in the input list and return the sum of its digits.\n    If no such prime exists, return -1.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3], p = 10; the output should be 7\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1], p = 4597; the output should be 5\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3], p = 163; the output should be 10 \n    For lst = [0,8,1,2,1,7], p = 5; the output should be 2\n", "context": "def find_large_prime_sum(lst, p):"}
{"key": 95, "prompt": "\n\ndef check_dict_case(dict, is_empty_valid):\n    \"\"\"\n    Given a dictionary and a boolean value, implement the following rules: \n    1. if the dictionary is empty \n        - return True if is_empty_valid is True\n        - return False if is_empty_valid is False\n    2. If not empty:\n        - return True if all keys are strings in lower case or all keys are strings in upper case\n        - return False otherwise.\n\n    Besides, if a key is not a string, return False regardless of the case of other keys.\n    \n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}, True) should return True.\n    check_dict_case({\"A\":\"Apple\", \"B\":\"Banana\"}, True) should return True.\n    check_dict_case({\"a\":\"apple\", \"B\":\"banana\"}, True) should return False.\n    check_dict_case({}, True) should return True.\n    check_dict_case({}, False) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\"}, True) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }, False) should return True.\n    \"\"\"\n", "canonical_solution": "\n\n    if len(dict.keys()) == 0:\n        return is_empty_valid\n    else:\n        state = \"start\"\n        for key in dict.keys():\n            if isinstance(key, str) == False:\n                return False\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    return False\n            elif (state == \"upper\" and not key.isupper()) or (state == \"lower\" and not key.islower()):\n                    return False\n        return True\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"a\":\"apple\", \"b\":\"banana\"}, True) == True, \"First test error: \" + str(candidate({\"a\":\"apple\", \"b\":\"banana\"}, True))\n    assert candidate({\"A\":\"Apple\", \"B\":\"Banana\"}, True) == True, \"Second test error: \" + str(candidate({\"A\":\"Apple\", \"B\":\"Banana\"}, True))\n    assert candidate({\"a\":\"apple\", \"B\":\"banana\"}, True) == False, \"Third test error: \" + str(candidate({\"a\":\"apple\", \"B\":\"banana\"}, True))\n    assert candidate({}, True) == True, \"Fourth test error: \" + str(candidate({}, True))\n    assert candidate({}, False) == False, \"Fifth test error: \" + str(candidate({}, False))\n    assert candidate({\"a\":\"apple\", 8:\"banana\"}, True) == False, \"Sixth test error: \" + str(candidate({\"a\":\"apple\", 8:\"banana\"}, True))\n    assert candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }, False) == True, \"Seventh test error: \" + str(candidate({\"STATE\":\"NC\", \"ZIP\":\"12345\" }, False))\n    assert candidate({\"state\":\"nc\", \"zip\":\"12345\" }, False) == True, \"Eight test error: \" + str(candidate({\"state\":\"nc\", \"zip\":\"12345\" }, False))\n\n", "entry_point": "check_dict_case", "question": "Write a function def check_dict_case(dict, is_empty_valid): to solve the following problem:\nGiven a dictionary and a boolean value, implement the following rules: \n    1. if the dictionary is empty \n        - return True if is_empty_valid is True\n        - return False if is_empty_valid is False\n    2. If not empty:\n        - return True if all keys are strings in lower case or all keys are strings in upper case\n        - return False otherwise.\n\n    Besides, if a key is not a string, return False regardless of the case of other keys.\n    \n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}, True) should return True.\n    check_dict_case({\"A\":\"Apple\", \"B\":\"Banana\"}, True) should return True.\n    check_dict_case({\"a\":\"apple\", \"B\":\"banana\"}, True) should return False.\n    check_dict_case({}, True) should return True.\n    check_dict_case({}, False) should return False.\n    check_dict_case({\"a\":\"apple\", 8:\"banana\"}, True) should return False.\n    check_dict_case({\"STATE\":\"NC\", \"ZIP\":\"12345\" }, False) should return True.\n", "context": "def check_dict_case(dict, is_empty_valid):"}
{"key": 96, "prompt": "\ndef count_between(m, n):\n    \"\"\"Implement a function that takes two non-negative integers m and n (m <= n) and returns an array of prime numbers between m and n (both inclusive).\n    for example:\n    count_between(1,5) => [2,3,5]\n    count_between(10,50) => [11, 13, 17, 19, 23, 29, 31, 37,41, 43, 47]\n    count_between(0,0) => []\n    count_between(20,30) => [23,29]\n    count_between(1,1) => []\n    count_between(15,15) => []\n    count_between(25,100) => [29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    \"\"\"\n", "canonical_solution": "    primes = []\n    for i in range(max(m, 2), n+1):\n        is_prime = all(i%j != 0 for j in range(2, int(i ** 0.5) + 1))\n        if is_prime:\n            primes.append(i)\n    return primes", "test": "\ndef check(candidate):\n    assert candidate(1,5) == [2,3,5]\n    assert candidate(10,50) == [11, 13, 17, 19, 23, 29, 31, 37,41, 43, 47]\n    assert candidate(0,0) == []\n    assert candidate(20,30) == [23,29]\n    assert candidate(1,1) == []\n    assert candidate(15,15) == []\n    assert candidate(25,100) == [29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n    assert candidate(89,90) == [89]\n    assert candidate(20,40) == [23,29,31,37]\n", "entry_point": "count_between", "question": "Write a function def count_between(m, n): to solve the following problem:\nImplement a function that takes two non-negative integers m and n (m <= n) and returns an array of prime numbers between m and n (both inclusive).\n    for example:\n    count_between(1,5) => [2,3,5]\n    count_between(10,50) => [11, 13, 17, 19, 23, 29, 31, 37,41, 43, 47]\n    count_between(0,0) => []\n    count_between(20,30) => [23,29]\n    count_between(1,1) => []\n    count_between(15,15) => []\n    count_between(25,100) => [29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]\n", "context": "def count_between(m, n):"}
{"key": 97, "prompt": "\n\n\ndef multiply(a, b, c, d):\n    \"\"\"Complete the function that takes four integers as input. The function should return \n    the product of the unit digits of the first two integers and the sum of the unit digits of the \n    last two integers. Assume the input is always valid.\n    Examples:\n    multiply(148, 412, 15, 23) should return 16 + (5+3) = 24.\n    multiply(19, 28, 34, 16) should return 72 + (4+6) = 82.\n    multiply(2020, 1851, 17, 33) should return 0 + (7+3) = 10.\n    multiply(14,-15, 22, 88) should return 20 + (2+8) = 30.\n    \"\"\"\n", "canonical_solution": "\n\n    return abs(a % 10) * abs(b % 10) + abs(c % 10) + abs(d % 10)\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(148, 412, 15, 23) == 24, \"First test error: \" + str(candidate(148, 412, 15, 23))                    \n    assert candidate(19, 28, 34, 16) == 82, \"Second test error: \" + str(candidate(19, 28, 34, 16))           \n    assert candidate(2020, 1851, 17, 33) == 10, \"Third test error: \" + str(candidate(2020, 1851, 17, 33))\n    assert candidate(14,-15, 22, 88) == 30, \"Fourth test error: \" + str(candidate(14,-15, 22, 88))      \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 1, 0, 1) == 1, \"1st edge test error: \" + str(candidate(0, 1, 0, 1))\n    assert candidate(0, 0, 0, 0) == 0, \"2nd edge test error: \" + str(candidate(0, 0, 0, 0))\n\n\n", "entry_point": "multiply", "question": "Write a function def multiply(a, b, c, d): to solve the following problem:\nComplete the function that takes four integers as input. The function should return \n    the product of the unit digits of the first two integers and the sum of the unit digits of the \n    last two integers. Assume the input is always valid.\n    Examples:\n    multiply(148, 412, 15, 23) should return 16 + (5+3) = 24.\n    multiply(19, 28, 34, 16) should return 72 + (4+6) = 82.\n    multiply(2020, 1851, 17, 33) should return 0 + (7+3) = 10.\n    multiply(14,-15, 22, 88) should return 20 + (2+8) = 30.\n", "context": "def multiply(a, b, c, d):"}
{"key": 98, "prompt": "\n\ndef count_upper_consonant(s):\n    \"\"\"\n    Given a string s, count the number of uppercase consonants in odd indices and \n    if it exceeds the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper_consonant('BaCBdEf') returns 1\n    count_upper_consonant('abcdefg') returns 0\n    count_upper_consonant('dBBE') returns 1\n    count_upper_consonant('BBEB') returns 1\n    count_upper_consonant('aBCdEf') returns 0\n    count_upper_consonant('dBBBE') returns 1\n    \"\"\"\n", "canonical_solution": "    consonants = \"BCDFGHJKLMNPQRSTVWXYZ\"\n    vowels = \"AEIOU\"\n    consonant_count = 0\n    vowel_count = 0\n    for i in range(0,len(s),2):\n        if s[i] in vowels:\n            vowel_count += 1\n    for i in range(1,len(s),2):\n        if s[i] in consonants:\n            consonant_count += 1      \n    return consonant_count > vowel_count", "test": "\n\ndef check(candidate):\n    assert candidate('BaCBdEf') == True\n    assert candidate('abcdefg') == False\n    assert candidate('dBBE')   == True\n    assert candidate('BBEB')   == True\n    assert candidate('aBCdEf') == False\n    assert candidate('dBBBE')  == True\n    assert candidate('B')      == False\n    assert candidate('U')      == False\n    assert candidate('')       == False\n    assert candidate('EEEE')   == False    \n    \n    assert True\n", "entry_point": "count_upper_consonant", "question": "Write a function def count_upper_consonant(s): to solve the following problem:\nGiven a string s, count the number of uppercase consonants in odd indices and \n    if it exceeds the number of uppercase vowels in even indices.\n    \n    For example:\n    count_upper_consonant('BaCBdEf') returns 1\n    count_upper_consonant('abcdefg') returns 0\n    count_upper_consonant('dBBE') returns 1\n    count_upper_consonant('BBEB') returns 1\n    count_upper_consonant('aBCdEf') returns 0\n    count_upper_consonant('dBBBE') returns 1\n", "context": "def count_upper_consonant(s):"}
{"key": 99, "prompt": "\ndef closest_integer_from_list(list_of_strings):\n    '''\n    Create a function that takes a list of strings, each representing a number, and finds \n    the closest integer for each number in the list. \n    The function should return a new list with the closest integers.\n    \n    If the number is equidistant from two integers, round it away from zero. \n\n    The original list should remain unchanged.\n    \n    Examples\n    >>> closest_integer_from_list([\"10\", \"15.3\", \"14.5\"])\n    [10, 15, 15]\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example, for \"14.5\", the function should\n    return 15 and for \"-14.5\", it should return -15.\n    '''\n", "canonical_solution": "\nfrom math import floor, ceil\n\ndef closest_integer_from_list(list_of_strings):\n    res_list = []\n\n    for value in list_of_strings:\n\n        if value.count('.') == 1:\n            # remove trailing zeros\n            while (value[-1] == '0'):\n                value = value[:-1]\n\n        num = float(value)\n        if value[-2:] == '.5':\n            if num > 0:\n                res_list.append(ceil(num))\n            else:\n                res_list.append(floor(num))\n        elif len(value) > 0:\n            res_list.append(int(round(num)))\n        else:\n            res_list.append(0)\n\n    return res_list\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"10\", \"15.3\", \"14.5\"]) == [10, 15, 15], \"Test Case 1\"\n    assert candidate([\"-15.5\", \"0.0\", \"16.7\"]) == [-16, 0, 17], \"Test Case 2\"\n    assert candidate([\"-9.5\", \"-8.5\", \"8.5\"]) == [-10, -9, 9], \"Test Case 3\"\n    assert candidate([]) == [], \"Test Case 4\"\n\n    # Check when list contains strings representing integer values\n    assert candidate([\"1\", \"2\", \"3\", \"4\"]) == [1, 2, 3, 4], \"Test Case 5\"\n    \n    # Check the case when the list includes zero\n    assert candidate([\"-5\", \"0\", \"5\"]) == [-5, 0, 5], \"Test Case 6\"\n    \n    # Check the case when the list includes negative and positive float numbers\n    assert candidate([\"-5.2\", \"0\", \"5.7\"]) == [-5, 0, 6], \"Test Case 7\"\n    \n    # Check the case when the list includes only one string value\n    assert candidate([\"-6.5\"]) == [-7], \"Test Case 8\"\n", "entry_point": "closest_integer_from_list", "question": "Write a function def closest_integer_from_list(list_of_strings): to solve the following problem:\nCreate a function that takes a list of strings, each representing a number, and finds \n    the closest integer for each number in the list. \n    The function should return a new list with the closest integers.\n    \n    If the number is equidistant from two integers, round it away from zero. \n\n    The original list should remain unchanged.\n    \n    Examples\n    >>> closest_integer_from_list([\"10\", \"15.3\", \"14.5\"])\n    [10, 15, 15]\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example, for \"14.5\", the function should\n    return 15 and for \"-14.5\", it should return -15.\n", "context": "def closest_integer_from_list(list_of_strings):"}
{"key": 100, "prompt": "\ndef make_pile_with_base(n, m):\n    \"\"\"\n    Given two positive integer n and m, you have to make a pile of n levels of stones.\n    The first level has an m number of stones.\n    The number of stones in the next level is:\n        - the next odd number if m is odd.\n        - the next even number if m is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_pile_with_base(3, 5)\n    [5, 7, 9]\n    \"\"\"\n", "canonical_solution": "    return [m + 2*i for i in range(n)]", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(3, 5) == [5, 7, 9], \"Test Case 1\"\n    assert candidate(4, 7) == [7, 9, 11, 13], \"Test Case 2\"\n    assert candidate(5, 1) == [1, 3, 5, 7, 9], \"Test Case 3\"\n    assert candidate(2, 4) == [4, 6], \"Test Case 4\"\n    assert candidate(1, 8) == [8], \"Test Case 5\" \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0, 0) == [], \"Edge case Test 1\"\n    assert candidate(1, 0) == [0], \"Edge case Test 2\"\n\n    print(\"All tests passed successfully!\")\n", "entry_point": "make_pile_with_base", "question": "Write a function def make_pile_with_base(n, m): to solve the following problem:\nGiven two positive integer n and m, you have to make a pile of n levels of stones.\n    The first level has an m number of stones.\n    The number of stones in the next level is:\n        - the next odd number if m is odd.\n        - the next even number if m is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> make_pile_with_base(3, 5)\n    [5, 7, 9]\n", "context": "def make_pile_with_base(n, m):"}
{"key": 101, "prompt": "\ndef words_string(s, remove_punctuation=False, case_sensitive=True):\n    \"\"\"\n    You will be given a string of words separated by commas, spaces or other \n    punctuation marks. Your task is to split the string into words and return a set \n    of the unique words.\n\n    If \"remove_punctuation\" argument is set to True, remove all punctuation from \n    the words before adding them to the set.\n\n    If \"case_sensitive\" argument is set to False, convert all words to lowercase \n    before adding them to the set.\n    \n    For example:\n    words_string(\"Hi, my, my, name is John!\") == {\"Hi\", \"my\", \"name\", \"is\", \"John!\"}\n    words_string(\"Hi, my, my, name is John!\", remove_punctuation=True) == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n    words_string(\"Hi, MY, my, name is John!\", case_sensitive=False) == {\"hi\", \"my\", \"name\", \"is\", \"john!\"}\n    words_string(\"Hi, MY, my, name is John!\", remove_punctuation=True, case_sensitive=False) == {\"hi\", \"my\", \"name\", \"is\", \"john\"}\n    \"\"\"\n", "canonical_solution": "\nimport string\n\ndef words_string(s, remove_punctuation=False, case_sensitive=True):\n    if not s:\n        return set()\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(' ')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    s_list = s_list.split()\n\n    if remove_punctuation:\n        s_list = [''.join(c for c in word if c not in string.punctuation) for word in s_list]\n        \n    if not case_sensitive:\n        s_list = [word.lower() for word in s_list]\n\n    return set(s_list)\n", "test": "\ndef check(candidate):\n    # Check some simple cases\n    assert candidate(\"Hi, my, my, name is John!\") == {\"Hi\", \"my\", \"name\", \"is\", \"John!\"}\n    assert candidate(\"Hi, my, my, name is John!\", remove_punctuation=True) == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n    assert candidate(\"Hi, MY, my, name is John!\", case_sensitive=False) == {\"hi\", \"my\", \"name\", \"is\", \"john!\"}\n    assert candidate(\"Hi, MY, my, name is John!\", remove_punctuation=True, case_sensitive=False) == {\"hi\", \"my\", \"name\", \"is\", \"john\"}\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\") == set()\n    assert candidate(\"ahmed, AhMed, AHMED\") == {\"ahmed\", \"AhMed\", \"AHMED\"}\n    assert candidate(\"ahmed, AhMed, AHMED\", case_sensitive=False) == {\"ahmed\"}\n    assert candidate(\"ahmed!, AhMed!, AHMED!\", remove_punctuation=True) == {\"ahmed\", \"AhMed\", \"AHMED\"}\n", "entry_point": "words_string", "question": "Write a function def words_string(s, remove_punctuation=False, case_sensitive=True): to solve the following problem:\nYou will be given a string of words separated by commas, spaces or other \n    punctuation marks. Your task is to split the string into words and return a set \n    of the unique words.\n\n    If \"remove_punctuation\" argument is set to True, remove all punctuation from \n    the words before adding them to the set.\n\n    If \"case_sensitive\" argument is set to False, convert all words to lowercase \n    before adding them to the set.\n    \n    For example:\n    words_string(\"Hi, my, my, name is John!\") == {\"Hi\", \"my\", \"name\", \"is\", \"John!\"}\n    words_string(\"Hi, my, my, name is John!\", remove_punctuation=True) == {\"Hi\", \"my\", \"name\", \"is\", \"John\"}\n    words_string(\"Hi, MY, my, name is John!\", case_sensitive=False) == {\"hi\", \"my\", \"name\", \"is\", \"john!\"}\n    words_string(\"Hi, MY, my, name is John!\", remove_punctuation=True, case_sensitive=False) == {\"hi\", \"my\", \"name\", \"is\", \"john\"}\n", "context": "def words_string(s, remove_punctuation=False, case_sensitive=True):"}
{"key": 102, "prompt": "\n\n\ndef find_largest_even_num(x, y, z):\n    \"\"\"This function takes three positive numbers x, y and z and returns the\n    biggest even integer number that is in the range [x, y] while divisible by z inclusive.\n    If there's no such number, then the function should return -1.\n    \n    \n\n    For example:\n    find_largest_even_num(6, 22, 4) = 20\n    find_largest_even_num(7, 21, 3) = 20\n    find_largest_even_num(15, 10, 3) = -1\n    \"\"\"\n", "canonical_solution": "\n\n    if x > y:\n        return -1\n    for i in range(y, x-1, -1):\n        if i % 2 == 0 and i % z == 0:\n            return i\n    return -1\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(6, 22, 4) == 20\n    assert candidate(7, 21, 3) == 18\n    assert candidate(15, 10, 3) == -1\n\n    # Check some advanced cases\n    assert candidate(3, 24, 5) == 20\n    assert candidate(23, 120, 7) == 112\n    assert candidate(33, 12345, 2) == 12344\n    assert candidate(16, 16, 2) == 16\n    assert candidate(16, 16, 17) == -1\n\n", "entry_point": "find_largest_even_num", "question": "Write a function def find_largest_even_num(x, y, z): to solve the following problem:\nThis function takes three positive numbers x, y and z and returns the\n    biggest even integer number that is in the range [x, y] while divisible by z inclusive.\n    If there's no such number, then the function should return -1.\n    \n    \n\n    For example:\n    find_largest_even_num(6, 22, 4) = 20\n    find_largest_even_num(7, 21, 3) = 20\n    find_largest_even_num(15, 10, 3) = -1\n", "context": "def find_largest_even_num(x, y, z):"}
{"key": 103, "prompt": "\nfrom typing import List\ndef cum_rounded_avg(lst: List[List[int]]):\n    \"\"\"\n    You are given a List of pairs of positive integers, each pair corresponding to n and m.\n    For each pair, you have to compute the average of the integers from n through m (including n and m).\n    Round the answer to the nearest integer and convert that to binary.\n    Append the results for each pair into a list.\n    If n is greater than m, append -1 to the list for that pair.\n    \n    Example:\n    cum_rounded_avg([[1, 5], [7, 5], [10, 20], [20, 33]]) => ['0b11', -1, '0b1111', '0b11010']\n    \"\"\"\n", "canonical_solution": "    res = []\n    for pair in lst:\n        n, m = pair[0], pair[1]\n        if m < n:\n            res.append(-1)\n            continue\n        summation = 0\n        for i in range(n, m+1):\n            summation += i\n        res.append(bin(round(summation/(m - n + 1))))\n    return res", "test": "\ndef check(candidate):\n    # Check some simple cases\n    assert candidate([[1, 5], [7, 5], [10, 20], [20, 33]])== ['0b11', -1, '0b1111', '0b11010']\n    assert candidate([[996, 997], [185, 546]]) == ['0b1111100100', '0b101101110']\n    assert candidate([[350, 902], [197, 233]]) == ['0b1001110010', '0b11010111']\n    assert candidate([[964, 977], [362, 496]]) == ['0b1111001010', '0b110101101']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([[5, 1], [5, 5]]) == [-1, '0b101']\n    assert candidate([[11, 7], [6, 12]]) == [-1, '0b1001']\n", "entry_point": "cum_rounded_avg", "question": "Write a function def cum_rounded_avg(lst: List[List[int]]): to solve the following problem:\nYou are given a List of pairs of positive integers, each pair corresponding to n and m.\n    For each pair, you have to compute the average of the integers from n through m (including n and m).\n    Round the answer to the nearest integer and convert that to binary.\n    Append the results for each pair into a list.\n    If n is greater than m, append -1 to the list for that pair.\n    \n    Example:\n    cum_rounded_avg([[1, 5], [7, 5], [10, 20], [20, 33]]) => ['0b11', -1, '0b1111', '0b11010']\n", "context": "from typing import List\ndef cum_rounded_avg(lst: List[List[int]]):"}
{"key": 104, "prompt": "\ndef unique_digits(x, y):\n    \"\"\"Given two lists of positive integers x and y.\n       First return a sorted list of all elements in x that don't have any even digit,\n       then return a sorted list of all elements that are both in x and y.\n\n    Note1: Returned lists should be sorted in increasing order.\n    \n    Note2: For those elements that are in both x and y, they should be unique, \n           meaning each of them should appear only once in the returned list.\n\n    For example:\n    >>> unique_digits([15, 33, 1422, 1], [1, 8, 15])\n    ([1, 15, 33], [1, 15])\n    >>> unique_digits([152, 323, 1422, 10], [323, 1, 2342])\n    ([], [323])\n    \"\"\"\n", "canonical_solution": "\n\n    odd_digit_elements = []\n    for i in x:\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n    odd_digit_elements.sort()\n\n    both_x_and_y_elements = list(set(x).intersection(set(y)))\n    both_x_and_y_elements.sort()\n\n    return odd_digit_elements, both_x_and_y_elements\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([15, 17, 1422, 1], [1, 8, 15]) == ([1, 15, 17], [1, 15])\n    assert candidate([152, 323, 1422, 10], [323, 1, 2342]) == ([], [323])\n    assert candidate([1233, 2030, 111, 151], [1233, 9, 111]) == ([111, 151], [111,1233])\n    assert candidate([135, 103, 31], [31, 135, 5]) == ([31, 135], [31, 135])\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "unique_digits", "question": "Write a function def unique_digits(x, y): to solve the following problem:\nGiven two lists of positive integers x and y.\n       First return a sorted list of all elements in x that don't have any even digit,\n       then return a sorted list of all elements that are both in x and y.\n\n    Note1: Returned lists should be sorted in increasing order.\n    \n    Note2: For those elements that are in both x and y, they should be unique, \n           meaning each of them should appear only once in the returned list.\n\n    For example:\n    >>> unique_digits([15, 33, 1422, 1], [1, 8, 15])\n    ([1, 15, 33], [1, 15])\n    >>> unique_digits([152, 323, 1422, 10], [323, 1, 2342])\n    ([], [323])\n", "context": "def unique_digits(x, y):"}
{"key": 105, "prompt": "def by_length_complex(arr, only_odd=False):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    \n    If only_odd flag is set to True, only consider odd numbers for sorting and replacing.\n\n    For example:\n        arr = [2, 1, 1, 4, 5, 8, 2, 3] and only_odd = False   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n        return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n        arr = [2, 1, 1, 4, 5, 8, 2, 3] and only_odd = True   \n            -> sort arr -> [1, 1, 3, 5] \n            -> reverse arr -> [5, 3, 1, 1]\n        return [\"Five\", \"Three\", \"One\", \"One\"]\n    \n    If the array is empty, return an empty array:\n        arr = []\n        return []\n    \n    If the array has any strange number ignore it:\n        arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n        return = ['One']\n    \"\"\"\n", "canonical_solution": "    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr, reverse=True)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            if only_odd and var%2 != 1:\n                continue\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr", "test": "\ndef check(candidate):\n\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3], False) == [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"], \"Error\"\n    assert candidate([]) == [], \"Error\"\n    assert candidate([1, -1 , 55]) == ['One'], \"Error\"\n    assert candidate([2, 1, 1, 4, 5, 8, 2, 3], True) == [\"Five\", \"Three\", \"One\", \"One\"], \"Error\"\n    assert candidate([9, 4, 8, 1, 7, 2], True) == [\"Nine\", \"Seven\", \"One\"]\n", "entry_point": "by_length_complex", "question": "Write a function def by_length_complex(arr, only_odd=False): to solve the following problem:\nGiven an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n    \n    If only_odd flag is set to True, only consider odd numbers for sorting and replacing.\n\n    For example:\n        arr = [2, 1, 1, 4, 5, 8, 2, 3] and only_odd = False   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n        return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n        arr = [2, 1, 1, 4, 5, 8, 2, 3] and only_odd = True   \n            -> sort arr -> [1, 1, 3, 5] \n            -> reverse arr -> [5, 3, 1, 1]\n        return [\"Five\", \"Three\", \"One\", \"One\"]\n    \n    If the array is empty, return an empty array:\n        arr = []\n        return []\n    \n    If the array has any strange number ignore it:\n        arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n        return = ['One']\n", "context": "def by_length_complex(arr, only_odd=False):"}
{"key": 106, "prompt": "\ndef g(n):\n    \"\"\" Implement the function g that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of square numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    g(5) == [1, 2, 14, 24, 55]\n    it has more steps than the previous one because you need to calculate square numbers too.\n    \"\"\"\n", "canonical_solution": "    ret = []\n    for i in range(1,n+1):\n        if i%2 == 0:\n            x = 1\n            for j in range(1,i+1): \n                x *= j\n            ret += [x]\n        else:\n            x = 0\n            for j in range(1,i+1): \n                x += j*j\n            ret += [x]\n    return ret", "test": "\ndef check(candidate):\n    assert candidate(5) == [1, 2, 14, 24, 55]\n    assert candidate(1) == [1]\n    assert candidate(3) == [1, 2, 14]\n    assert candidate(7) == [1, 2, 14, 24, 55, 720, 140]\n", "entry_point": "g", "question": "Write a function def g(n): to solve the following problem:\nImplement the function g that takes n as a parameter,\n    and returns a list of size n, such that the value of the element at index i is the factorial of i if i is even\n    or the sum of square numbers from 1 to i otherwise.\n    i starts from 1.\n    the factorial of i is the multiplication of the numbers from 1 to i (1 * 2 * ... * i).\n    Example:\n    g(5) == [1, 2, 14, 24, 55]\n    it has more steps than the previous one because you need to calculate square numbers too.\n", "context": "def g(n):"}
{"key": 107, "prompt": "\n\ndef even_odd_palindrome_in_range(m, n):\n    \"\"\"\n    Given two positive integers m and n. return a tuple that has the number of even and \n    odd integer palindromes that fall within the range of m and n, inclusive.\n\n    Example 1:\n\n        Input: m = 3, n = 10\n        Output: (3, 4)\n        Explanation:\n        Integer palindrome are 3, 4, 5, 6, 7, 8, 9. Three of them are even, and four of them are odd.\n\n    Example 2:\n\n        Input: m = 10, n = 30\n        Output: (1, 1)\n        Explanation:\n        Integer palindrome are 11, 22 which are even. One of them are even, and one of them are odd.\n\n    Note:\n        1 <= m <= n <= 10^3\n        the returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n", "canonical_solution": "    \n    def is_palindrome(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(m, n+1):\n        if i%2 == 1 and is_palindrome(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and is_palindrome(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)", "test": "def check(candidate):\n\n    assert candidate(123, 300) == (10, 7)\n    assert candidate(10, 30) == (1, 1)\n    assert candidate(3, 10) == (3, 4)\n    assert candidate(63, 100) == (2, 2)\n    assert candidate(25, 50) == (1, 1)\n    assert candidate(19, 38) == (1, 1)\n    assert candidate(9, 20) == (0, 2), \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate(1, 1) == (0, 1), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "even_odd_palindrome_in_range", "question": "Write a function def even_odd_palindrome_in_range(m, n): to solve the following problem:\nGiven two positive integers m and n. return a tuple that has the number of even and \n    odd integer palindromes that fall within the range of m and n, inclusive.\n\n    Example 1:\n\n        Input: m = 3, n = 10\n        Output: (3, 4)\n        Explanation:\n        Integer palindrome are 3, 4, 5, 6, 7, 8, 9. Three of them are even, and four of them are odd.\n\n    Example 2:\n\n        Input: m = 10, n = 30\n        Output: (1, 1)\n        Explanation:\n        Integer palindrome are 11, 22 which are even. One of them are even, and one of them are odd.\n\n    Note:\n        1 <= m <= n <= 10^3\n        the returned tuple has the number of even and odd integer palindromes respectively.\n", "context": "def even_odd_palindrome_in_range(m, n):"}
{"key": 108, "prompt": "\ndef count_nums_two(arr1, arr2):\n    \"\"\"\n    Write a function count_nums_two which takes two arrays of integers. Your task is to\n    concatenate these arrays and then return the number of elements in the new array which\n    have a sum of its digits > 0. A potential complexity is introduced for negative numbers \n    where the first digit will be considered negative:\n    e.g. -123 would have signed digits -1, 2, and 3. Also, when there is repetition in \n    the numbers from the two arrays, do not consider them twice.\n    Usage is as follows:\n    >>> count_nums_two([], [1, 2, 3]) == 3\n    >>> count_nums_two([-1, 11, -11], [1, -1]) == 2\n    >>> count_nums_two([1], [1, 1, 2]) == 2\n    \"\"\"\n", "canonical_solution": "    def digits_sum(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n)\n\n    new_arr = list(set(arr1 + arr2))\n    return len(list(filter(lambda x: x > 0, [digits_sum(i) for i in new_arr])))\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([], []) == 0\n    assert candidate([-1, -2, 0], [1, 2]) == 2\n    assert candidate([1, 1, 2, -2, 3, 4, 5], [1, 2, 3, -2]) == 5\n    assert candidate([1, 6, 9, -6, 0, 1, 5], [-6, -9]) == 4\n    assert candidate([1, 100, 98, -7, 1, -1], [-100, 1, -7]) == 3\n    assert candidate([12, 23, 34, -45, -56, 0], [12, -45, 0]) == 5\n    assert candidate([-0, 1**0], [1**0, -0]) == 1\n    assert candidate([1], [1]) == 1\n\n    # Check the edge cases\n    assert candidate([-1, -1, -1], [-1, -1, -1]) == 0\n    assert candidate([0, 0, 0], [0, 0, 0]) == 0\n    assert candidate([100, 100, 100], [100, 100, 100]) == 1\n\n    assert count_nums_two([], [1, 2, 3]) == 3\n    assert count_nums_two([-1, 11, -11], [1, -1]) == 2\n    assert count_nums_two([1], [1, 1, 2]) == 2", "entry_point": "count_nums_two", "question": "Write a function def count_nums_two(arr1, arr2): to solve the following problem:\nWrite a function count_nums_two which takes two arrays of integers. Your task is to\n    concatenate these arrays and then return the number of elements in the new array which\n    have a sum of its digits > 0. A potential complexity is introduced for negative numbers \n    where the first digit will be considered negative:\n    e.g. -123 would have signed digits -1, 2, and 3. Also, when there is repetition in \n    the numbers from the two arrays, do not consider them twice.\n    Usage is as follows:\n    >>> count_nums_two([], [1, 2, 3]) == 3\n    >>> count_nums_two([-1, 11, -11], [1, -1]) == 2\n    >>> count_nums_two([1], [1, 1, 2]) == 2\n", "context": "def count_nums_two(arr1, arr2):"}
{"key": 109, "prompt": "def move_one_or_two_balls(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operations on the given array:\n        You are allowed to perform right shift operation any number of times\n        and/or\n        You are allowed to swap any two elements in the array once.\n\n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operations\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\n    move_one_or_two_balls([3, 4, 5, 1, 2])==True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_or_two_balls([3, 5, 4, 1, 2])==True\n    Explanation: By swapping elements at index 1 and 2, and 2 right shift operations non-decreasing order can\n                 be achieved for the given array.\n    \"\"\"\n", "canonical_solution": "    def move_one_ball(arr):\n        if len(arr)==0:\n            return True\n        sorted_array=sorted(arr)\n        my_arr=[]\n        \n        min_value=min(arr)\n        min_index=arr.index(min_value)\n        my_arr=arr[min_index:]+arr[0:min_index]\n        for i in range(len(arr)):\n            if my_arr[i]!=sorted_array[i]:\n                return False\n        return True\n\n    n = len(arr)\n    import copy\n    if move_one_ball(arr):\n        return True\n    for i in range(0,n):\n        new_arr = copy.deepcopy(arr)\n        j = (i+1)%n\n        new_arr[i],new_arr[j]=new_arr[j],new_arr[i]\n        if move_one_ball(new_arr):\n            return True\n    return False", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([3, 4, 5, 1, 2])==True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([3, 5, 10, 1, 2])==True, \"This prints if this assert fails 2\"\n    assert candidate([4, 3, 1, 2])==True, \"This prints if this assert fails 3\"\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([3, 5, 4, 1, 2])==True, \"This prints if this assert fails 4 (also good for debugging!)\"\n    assert candidate([5, 7, 2, 1, 6])==False, \"This prints if this assert fails 5\"\n    assert candidate([])==True", "entry_point": "move_one_or_two_balls", "question": "Write a function def move_one_or_two_balls(arr): to solve the following problem:\nWe have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operations on the given array:\n        You are allowed to perform right shift operation any number of times\n        and/or\n        You are allowed to swap any two elements in the array once.\n\n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operations\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n\n    move_one_or_two_balls([3, 4, 5, 1, 2])==True\n    Explanation: By performing 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    move_one_or_two_balls([3, 5, 4, 1, 2])==True\n    Explanation: By swapping elements at index 1 and 2, and 2 right shift operations non-decreasing order can\n                 be achieved for the given array.\n", "context": "def move_one_or_two_balls(arr):"}
{"key": 110, "prompt": "\n\ndef multi_exchange(lst1, lst2, lst3):\n    \"\"\"In this problem, you will implement a function that takes three lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between any two lists to make lst1 a list of only even numbers and lst3 a list of only odd numbers. \n    lst2 serves as an intermediate to facilitate the exchange. \n    There is no limit on the number of exchanged elements between the lists. \n    If it is possible to exchange elements to make all the elements of lst1 \n    to be even and all elements of lst3 to be odd, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    multi_exchange([1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    multi_exchange([1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 2, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n", "canonical_solution": "\n\n    odd1, even1 = 0, 0\n    odd3, even3 = 0, 0\n    even2, odd2 = 0, 0\n    for i in lst1:\n        if i%2 == 1:\n            odd1 += 1\n    for i in lst3:\n        if i%2 == 0:\n            even3 += 1\n    for i in lst2:\n        if i%2 == 0:\n            even2 += 1\n        else:\n            odd2 += 1\n    if even2 >= odd1 and odd2 >= even3:\n        return \"YES\"\n    return \"NO\"\n            \n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]) == \"YES\"\n    assert candidate([1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 2, 4]) == \"NO\"\n    assert candidate([1, 2, 3, 4], [2, 1, 4, 3], [1, 3, 5, 7]) == \"YES\" \n    assert candidate([5, 7, 3], [2, 6, 4], [2, 4, 6]) == \"NO\"\n    assert candidate([1, 1, 1], [2, 2, 2], [3, 3, 3]) == \"YES\" \n    assert candidate([3, 2, 6, 1, 8, 9], [3, 5, 5, 1, 1, 1], [2, 4, 6, 8, 10, 12]) == \"NO\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([100, 200], [200, 200], [101, 201]) == \"YES\"\n    assert candidate([1, 3], [2, 2], [2, 2]) == \"NO\"\n\n\n", "entry_point": "multi_exchange", "question": "Write a function def multi_exchange(lst1, lst2, lst3): to solve the following problem:\nIn this problem, you will implement a function that takes three lists of numbers,\n    and determines whether it is possible to perform an exchange of elements\n    between any two lists to make lst1 a list of only even numbers and lst3 a list of only odd numbers. \n    lst2 serves as an intermediate to facilitate the exchange. \n    There is no limit on the number of exchanged elements between the lists. \n    If it is possible to exchange elements to make all the elements of lst1 \n    to be even and all elements of lst3 to be odd, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    multi_exchange([1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    multi_exchange([1, 2, 3, 4], [1, 2, 3, 4], [1, 2, 2, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n", "context": "def multi_exchange(lst1, lst2, lst3):"}
{"key": 111, "prompt": "def extended_histogram(test,delimiter):\n    \"\"\"Given a string representing a space separated lowercase letters and another string representing delimiter, \n    return a dictionary of the letter with the most repetition and containing the corresponding count.\n    \n    If the delimiter string is empty, use a space as default delimiter. \n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    extended_histogram('a-b-c', '-') == {'a': 1, 'b': 1, 'c': 1}\n    extended_histogram('a,b,b,a', ',') == {'a': 2, 'b': 2}\n    extended_histogram('a:b:c:a:b', ':') == {'a': 2, 'b': 2}\n    extended_histogram('bbba', '') == {'b': 3}\n    extended_histogram('', ':') == {}\n\n    \"\"\"\n", "canonical_solution": "\n\n    dict1={}\n    #delimiter = \" \" if delimiter==\"\" else delimiter \n    if delimiter==\"\":\n        list1 = list(test)\n    else:\n        list1=test.split(delimiter)\n    t=0\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                dict1[i]=t\n    return dict1\n", "test": "def check(candidate):\n\n    assert candidate('a-b-b-a', '-') == {'a':2,'b': 2}, \"Assertion failed 1\"\n    assert candidate('a:b:c:a:b', ':') == {'a': 2, 'b': 2}, \"Assertion failed 2\"\n    assert candidate('k!l!m!l!k', '!') == {'k': 2, 'l': 2}, \"Assertion failed 3\"\n    assert candidate('abac', '') == {'a': 2}, \"Assertion failed 4\"\n    assert candidate('', ':') == {}, \"Assertion failed 5\"\n    assert candidate('xxxy', '') == {'x': 3}, \"Assertion failed 6\"\n    \n    # Check edge cases that are easily worked out by hand.\n    assert candidate('hahahaha', '') == {'h': 4, 'a': 4}, \"Assertion failed 7\"\n    assert candidate('m', ':') == {'m': 1}, \"Assertion failed 8\"", "entry_point": "extended_histogram", "question": "Write a function def extended_histogram(test,delimiter): to solve the following problem:\nGiven a string representing a space separated lowercase letters and another string representing delimiter, \n    return a dictionary of the letter with the most repetition and containing the corresponding count.\n    \n    If the delimiter string is empty, use a space as default delimiter. \n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    extended_histogram('a-b-c', '-') == {'a': 1, 'b': 1, 'c': 1}\n    extended_histogram('a,b,b,a', ',') == {'a': 2, 'b': 2}\n    extended_histogram('a:b:c:a:b', ':') == {'a': 2, 'b': 2}\n    extended_histogram('bbba', '') == {'b': 3}\n    extended_histogram('', ':') == {}\n", "context": "def extended_histogram(test,delimiter):"}
{"key": 112, "prompt": "\n\ndef reverse_delete_divide(s,c,i):\n    \"\"\"Task\n    We are given three inputs: two strings s and c, and an integer i.\n    \n    First, you have to delete all the characters in s that are equal to any character in c.\n    Then, check if the resultant string is a palindrome. A string is called palindrome \n    if it reads the same backward as forward.\n    \n    After that, you should divide the length of the resultant string by the input integer i. \n    \n    You should return a tuple containing the result string, True/False for the check, and the \n    quotient of the division.\n    \n    Example\n    For s = \"abcde\", c = \"ae\", i = 2 the result should be ('bcd',False, 1.5)\n    For s = \"abcdef\", c = \"b\", i = 2 the result should be ('acdef',False,2.5)\n    For s = \"abcdedcba\", c = \"ab\", i = 3 the result should be ('cdedc',True,1.6666666666666667)\n    \"\"\"\n", "canonical_solution": "\n\n    s = ''.join([char for char in s if char not in c])\n    return (s, s[::-1] == s, len(s)/i)", "test": "def check(candidate):\n    epsilon = 0.000001 # set very small epsilon for float comparisons\n\n    result = candidate(\"abcde\",\"ae\",2)\n    assert result[0] == 'bcd' \n    assert result[1] == False\n    assert abs(result[2]-1.5) < epsilon\n\n    result = candidate(\"abcdef\", \"b\", 2)\n    assert result[0] == 'acdef'\n    assert result[1] == False\n    assert abs(result[2]-2.5) < epsilon\n    \n    result = candidate(\"abcdedcba\",\"ab\",3)\n    assert result[0] == 'cdedc'\n    assert result[1] == True\n    assert abs(result[2]-1.6666666666666667) < epsilon\n\n    result = candidate(\"dwik\",\"w\",2)\n    assert result[0] == 'dik'\n    assert result[1] == False\n    assert abs(result[2]-1.5) < epsilon\n\n    result = candidate(\"a\",\"a\",1)\n    assert result[0] == ''\n    assert result[1] == True\n    assert abs(result[2]-0.0) < epsilon\n\n    result = candidate(\"abcdedcba\",\"\",2)\n    assert result[0] == 'abcdedcba'\n    assert result[1] == True\n    assert abs(result[2]-4.5) < epsilon\n\n    result = candidate(\"abcdedcba\",\"v\",3)\n    assert result[0] == 'abcdedcba'\n    assert result[1] == True\n    assert abs(result[2]-3.0) < epsilon\n\n    result = candidate(\"vabba\",\"v\",2)\n    assert result[0] == 'abba'\n    assert result[1] == True\n    assert abs(result[2]-2.0) < epsilon\n\n    result = candidate(\"mamma\",\"mia\",2)\n    assert result[0] == ''\n    assert result[1] == True\n    assert abs(result[2]-0.0) < epsilon\n", "entry_point": "reverse_delete_divide", "question": "Write a function def reverse_delete_divide(s,c,i): to solve the following problem:\nTask\n    We are given three inputs: two strings s and c, and an integer i.\n    \n    First, you have to delete all the characters in s that are equal to any character in c.\n    Then, check if the resultant string is a palindrome. A string is called palindrome \n    if it reads the same backward as forward.\n    \n    After that, you should divide the length of the resultant string by the input integer i. \n    \n    You should return a tuple containing the result string, True/False for the check, and the \n    quotient of the division.\n    \n    Example\n    For s = \"abcde\", c = \"ae\", i = 2 the result should be ('bcd',False, 1.5)\n    For s = \"abcdef\", c = \"b\", i = 2 the result should be ('acdef',False,2.5)\n    For s = \"abcdedcba\", c = \"ab\", i = 3 the result should be ('cdedc',True,1.6666666666666667)\n", "context": "def reverse_delete_divide(s,c,i):"}
{"key": 113, "prompt": "\n\n\ndef odd_count_more(lst, fst, scd):\n    \"\"\"Given a list of strings, where each string consists of only digits, a string indicating 'first replacement' and a string indicating 'second replacement', return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.this is a middle message. the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input.\n    The first sentence of odd elements should use the 'first replacement', while the second sentence should use the 'second replacement'.\n\n    >>> odd_count_more(['1234567'],\"fst\",\"scd\")\n    [\"the number of odd elements 4fst the str4ng 4 of the 4nput.this is a middle message.the number of odd elements 4scd the str4ng 4 of the 4nput.\"]\n    >>> odd_count_more(['3',\"11111111\"],\"one\",\"two\")\n    [\"the number of odd elements 1one the str1ng 1 of the 1nput.this is a middle message.the number of odd elements 1two the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8one the str8ng 8 of the 8nput.this is a middle message.the number of odd elements 8two the str8ng 8 of the 8nput.\"]\n    \"\"\"\n", "canonical_solution": "\n\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) +fst+ \" the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.this is a middle message.the number of odd elements \" + str(n) +scd+ \" the str\"+ str(n) +\"ng \"+ str(n) +\" of the \"+ str(n) +\"nput.\")\n    return res\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert(candidate(['1234567'],\"fst\",\"scd\") == [\"the number of odd elements 4fst the str4ng 4 of the 4nput.this is a middle message.the number of odd elements 4scd the str4ng 4 of the 4nput.\"]), \"Test 1 failed\"\n    assert(candidate(['3',\"11111111\"],\"one\",\"two\") == [\"the number of odd elements 1one the str1ng 1 of the 1nput.this is a middle message.the number of odd elements 1two the str1ng 1 of the 1nput.\", \"the number of odd elements 8one the str8ng 8 of the 8nput.this is a middle message.the number of odd elements 8two the str8ng 8 of the 8nput.\"]), \"Test 2 failed\"\n    assert candidate(['271', '137', '314'],\"A\",\"B\") == [\n        'the number of odd elements 2A the str2ng 2 of the 2nput.this is a middle message.the number of odd elements 2B the str2ng 2 of the 2nput.',\n        'the number of odd elements 3A the str3ng 3 of the 3nput.this is a middle message.the number of odd elements 3B the str3ng 3 of the 3nput.',\n        'the number of odd elements 2A the str2ng 2 of the 2nput.this is a middle message.the number of odd elements 2B the str2ng 2 of the 2nput.'\n    ], \"Test 3 failed\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert(True), \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "odd_count_more", "question": "Write a function def odd_count_more(lst, fst, scd): to solve the following problem:\nGiven a list of strings, where each string consists of only digits, a string indicating 'first replacement' and a string indicating 'second replacement', return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.this is a middle message. the number of odd elements in the string i of the input.\" where all the i's should be replaced by the number of odd digits in the i'th string of the input.\n    The first sentence of odd elements should use the 'first replacement', while the second sentence should use the 'second replacement'.\n\n    >>> odd_count_more(['1234567'],\"fst\",\"scd\")\n    [\"the number of odd elements 4fst the str4ng 4 of the 4nput.this is a middle message.the number of odd elements 4scd the str4ng 4 of the 4nput.\"]\n    >>> odd_count_more(['3',\"11111111\"],\"one\",\"two\")\n    [\"the number of odd elements 1one the str1ng 1 of the 1nput.this is a middle message.the number of odd elements 1two the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8one the str8ng 8 of the 8nput.this is a middle message.the number of odd elements 8two the str8ng 8 of the 8nput.\"]\n", "context": "def odd_count_more(lst, fst, scd):"}
{"key": 114, "prompt": "\n\ndef detailed_minSubArraySum(nums):\n    \"\"\"\n    In the given array of integers, find and return:\n    - Minimum sum of any non-empty subarray \n    - Indices of starting and ending element of subarray in a tuple\n    Example\n    detailed_minSubArraySum([2, 3, 4, 1, 2, 4]) == (1,(3,3))\n    detailed_minSubArraySum([-1, -2, -3]) == (-6, (0,2))\n    \"\"\"\n", "canonical_solution": "\n\n    max_sum = 0\n    s = 0\n    indices = (0,0)\n    min_start = 0\n    for i, num in enumerate(nums):\n        s += -num\n        if (s < 0):\n            s = 0\n            min_start = i+1\n        if s > max_sum :\n            max_sum = s\n            indices = (min_start,i)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n        indices = (nums.index(-max_sum), nums.index(-max_sum))\n    min_sum = -max_sum\n    return (min_sum, indices)\n\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([2, 3, 4, 1, 2, 4]) == (1,(3,3)), \"Test case 1 failed\"\n    assert candidate([-1, -2, -3]) == (-6, (0,2)), \"Test case 2 failed\"\n    assert candidate([-1, -2, -3, 2, -10]) == (-14, (0,4)), \"Test case 3 failed\"\n    assert candidate([-9999999999999999]) == (-9999999999999999, (0,0)), \"Test case 4 failed\"\n    assert candidate([0, 10, 20, 1000000]) == (0, (0,0)), \"Test case 5 failed\"\n    assert candidate([-1, -2, -3, 10, -5]) == (-6, (0,2)), \"Test case 6 failed\"\n    assert candidate([100, -1, -2, -3, 10, -5]) == (-6, (1,3)), \"Test case 7 failed\"\n    \n    # Check edge cases.\n    assert candidate([-10]) == (-10, (0,0)), \"Test case 8 failed\"\n    assert candidate([7]) == (7, (0,0)), \"Test case 9 failed\"\n    assert candidate([1, -1]) == (-1, (1,1)), \"Test case 10 failed\"\n", "entry_point": "detailed_minSubArraySum", "question": "Write a function def detailed_minSubArraySum(nums): to solve the following problem:\nIn the given array of integers, find and return:\n    - Minimum sum of any non-empty subarray \n    - Indices of starting and ending element of subarray in a tuple\n    Example\n    detailed_minSubArraySum([2, 3, 4, 1, 2, 4]) == (1,(3,3))\n    detailed_minSubArraySum([-1, -2, -3]) == (-6, (0,2))\n", "context": "def detailed_minSubArraySum(nums):"}
{"key": 115, "prompt": "\n\ndef max_fill(grid, capacity, steps):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Now, the twist is, every time you lower the bucket, before pulling it up and emptying it, \n    you have to wait for the given steps to pass. You want to calculate the time it will take to empty the wells.\n    The time is calculated as (Number of times the bucket is lowered)*steps.\n    Output the total time taken to empty the wells.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n            steps: 2\n        Output: 12\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n            steps: 3\n        Output: 15\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n            steps: 10\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n        * 1 <= steps <= 10\n    \"\"\"\n", "canonical_solution": "\n\n    return steps*sum([math.ceil(sum(arr)/capacity) for arr in grid])\n\n", "test": "\n\ndef check(candidate):\n\n    assert candidate([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1, 2) == 12, \"Error\"\n    assert candidate([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2, 3) == 15, \"Error\"\n    assert candidate([[0,0,0], [0,0,0]], 5, 10) == 0, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 2, 4) == 16, \"Error\"\n    assert candidate([[1,1,1,1], [1,1,1,1]], 9, 5) == 10, \"Error\"\n\n", "entry_point": "max_fill", "question": "Write a function def max_fill(grid, capacity, steps): to solve the following problem:\nYou are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Now, the twist is, every time you lower the bucket, before pulling it up and emptying it, \n    you have to wait for the given steps to pass. You want to calculate the time it will take to empty the wells.\n    The time is calculated as (Number of times the bucket is lowered)*steps.\n    Output the total time taken to empty the wells.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n            steps: 2\n        Output: 12\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n            steps: 3\n        Output: 15\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n            steps: 10\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n        * 1 <= steps <= 10\n", "context": "def max_fill(grid, capacity, steps):"}
{"key": 116, "prompt": "\n\ndef sort_two_arrays(arr1, arr2):\n    \"\"\"\n    This function is a variant of the last question, but this time you have two arrays of non-negative integers.\n    Your task is to sort the two arrays separately according to the number of ones in their binary representation \n    in ascending order. After sorting, concatenate the two arrays together \n    (with the elements of second array following those of the first).\n    Similarly, for similar number of ones, sort based on decimal value.\n\n    >>> sort_two_arrays([1, 5, 2, 3, 4], [8, 6, 7, 9, 10]) == [1, 2, 3, 4, 5, 6, 8, 7, 9, 10]\n    >>> sort_two_arrays([], [-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_two_arrays([1, 0, 2, 3, 4], [0, 1, 2, 3, 4]) == [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n    \"\"\"\n", "canonical_solution": "    sorted_arr1 = sorted(sorted(arr1), key=lambda x: bin(x)[2:].count('1'))\n    sorted_arr2 = sorted(sorted(arr2), key=lambda x: bin(x)[2:].count('1'))\n    return sorted_arr1 + sorted_arr2", "test": "\ndef check(candidate):\n    assert candidate([1,5,2,3,4], [1,0,2,3,4]) == [1, 2, 4, 3, 5, 0, 1, 2, 4, 3]\n    assert candidate([],[-2,-3,-4,-5,-6]) == [-4, -2, -6, -5, -3]\n    assert candidate([1,0,2,3,4],[1,0,2,3,4]) == [0, 1, 2, 4, 3, 0, 1, 2, 4, 3]\n    assert candidate([],[]) == []\n    assert candidate([2,5,77,4,5,3,5,7,2,3,4],[3,6,44,12,32,5]) == [2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77, 32, 3, 5, 6, 12, 44]\n    assert candidate([3,6,44,12,32,5],[2,4,8,16,32]) == [32, 3, 5, 6, 12, 44, 2, 4, 8, 16, 32]\n    assert candidate([2,4,8,16,32],[2,5,77,4,5,3,5,7,2,3,4]) == [2, 4, 8, 16, 32, 2, 2, 4, 4, 3, 3, 5, 5, 5, 7, 77]\n    assert candidate([2,4,8,16,32],[2,4,8,16,32]) == [2, 4, 8, 16, 32, 2, 4, 8, 16, 32]\n", "entry_point": "sort_two_arrays", "question": "Write a function def sort_two_arrays(arr1, arr2): to solve the following problem:\nThis function is a variant of the last question, but this time you have two arrays of non-negative integers.\n    Your task is to sort the two arrays separately according to the number of ones in their binary representation \n    in ascending order. After sorting, concatenate the two arrays together \n    (with the elements of second array following those of the first).\n    Similarly, for similar number of ones, sort based on decimal value.\n\n    >>> sort_two_arrays([1, 5, 2, 3, 4], [8, 6, 7, 9, 10]) == [1, 2, 3, 4, 5, 6, 8, 7, 9, 10]\n    >>> sort_two_arrays([], [-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_two_arrays([1, 0, 2, 3, 4], [0, 1, 2, 3, 4]) == [0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n", "context": "def sort_two_arrays(arr1, arr2):"}
{"key": 117, "prompt": "\n\ndef select_words_and_freq(s, n, m):\n    \"\"\"Given a string s, a natural number n, and a natural number m. You have to write a function \n    that Returns a dictionary of all words from string s that contain exactly n consonants (as keys), \n    and how many times these words appear in the string s (as values), considering only the \n    words that appear at least m times.\n    If the string s is empty or no words fulfill the conditions then the function should return an empty dictionary.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words_and_freq(\"Mary had a little lamb lamb and Mary had a little dog\", 4, 2) ==> {\"little\":2}\n    select_words_and_freq(\"Mary had a lamb lamb and Mary had a dog\", 3, 2) ==> {\"Mary\": 2, \"lamb\": 2}\n    select_words_and_freq(\"simple white space\", 2, 1) ==> {}\n    select_words_and_freq(\"Hello Hello Hello world world world\", 4, 3) ==> {\"world\":3}\n    \"\"\"\n", "canonical_solution": "\n\n    from collections import defaultdict\n    cnt = defaultdict(int)\n    result = {}\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() not in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            cnt[word] += 1\n            if cnt[word] >= m:\n                result[word] = cnt[word]\n    return result\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(\"Mary had a little lamb lamb and Mary had a little dog\", 4, 2) == {\"little\":2}, \"First test error: \" + str(candidate(\"Mary had a little lamb lamb and Mary had a little dog\", 4, 2))      \n    assert candidate(\"Mary had a lamb lamb and Mary had a dog\", 3, 2) == {\"Mary\": 2, \"lamb\": 2}, \"Second test error: \" + str(candidate(\"Mary had a lamb lamb and Mary had a dog\", 3, 2))  \n    assert candidate(\"simple white space\", 2, 1) == {}, \"Third test error: \" + str(candidate(\"simple white space\", 2, 1))      \n    assert candidate(\"Hello Hello Hello world world world\", 4, 3) == {\"world\":3}, \"Fourth test error: \" + str(candidate(\"Hello Hello Hello world world world\", 4, 3))  \n\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(\"\", 2, 1) == {}, \"1st edge test error: \" + str(candidate(\"\", 2, 1))\n    assert candidate(\"b b c c d d e f f f\", 1, 2) == {\"b\": 2, \"c\": 2, \"d\": 2, \"f\": 3}, \"2nd edge test error: \" + str(candidate(\"b b c c d d e f f f\", 1, 2))\n", "entry_point": "select_words_and_freq", "question": "Write a function def select_words_and_freq(s, n, m): to solve the following problem:\nGiven a string s, a natural number n, and a natural number m. You have to write a function \n    that Returns a dictionary of all words from string s that contain exactly n consonants (as keys), \n    and how many times these words appear in the string s (as values), considering only the \n    words that appear at least m times.\n    If the string s is empty or no words fulfill the conditions then the function should return an empty dictionary.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    select_words_and_freq(\"Mary had a little lamb lamb and Mary had a little dog\", 4, 2) ==> {\"little\":2}\n    select_words_and_freq(\"Mary had a lamb lamb and Mary had a dog\", 3, 2) ==> {\"Mary\": 2, \"lamb\": 2}\n    select_words_and_freq(\"simple white space\", 2, 1) ==> {}\n    select_words_and_freq(\"Hello Hello Hello world world world\", 4, 3) ==> {\"world\":3}\n", "context": "def select_words_and_freq(s, n, m):"}
{"key": 118, "prompt": "\n\n\ndef get_closest_vowel(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive). If the vowel is \n    uppercase, return \"Uppercase\", if it is lowercase, return \"Lowercase\". If the vowel \n    does not exist, return \"\". \n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel that met the above condition. \n\n    You may assume that \n    - the given string contains English letters or ASCII symbols only\n    - if the string contains non-alphanumeric characters, they are considered \n      consonants.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> {'vowel': 'u', 'case': 'Lowercase'}\n    get_closest_vowel(\"FULL\") ==> {'vowel': 'U', 'case': 'Uppercase'}\n    get_closest_vowel(\"quick\") ==> {\"vowel\": \"\", \"case\": \"\"}\n    get_closest_vowel(\"ab\") ==> {\"vowel\": \"\", \"case\": \"\"}\n\n    \"\"\"\n", "canonical_solution": "\n    if len(word) < 3:\n        return {\"vowel\": \"\", \"case\": \"\"}\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word) - 2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                if word[i].islower():\n                    case = \"Lowercase\"\n                elif word[i].isupper():\n                    case = \"Uppercase\"\n                else:\n                    case = \"None\"\n                return {\"vowel\": word[i], \"case\": case}\n    return {\"vowel\": \"\", \"case\": \"\"}", "test": "\ndef check(candidate):\n\n    assert candidate(\"yogurt\") == {'vowel': 'u', 'case': 'Lowercase'}\n    assert candidate(\"FULL\") == {'vowel': 'U', 'case': 'Uppercase'}\n    assert candidate(\"easy\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"eAsy\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"ali\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"bad\") == {'vowel': 'a', 'case': 'Lowercase'}\n    assert candidate(\"most\") == {'vowel': 'o', 'case': 'Lowercase'}\n    assert candidate(\"ab\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"ba\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"quick\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"anime\") == {'vowel': 'i', 'case': 'Lowercase'}\n    assert candidate(\"Asia\") == {\"vowel\": \"\", \"case\": \"\"}\n    assert candidate(\"Above\") == {'vowel': 'o', 'case': 'Lowercase'}", "entry_point": "get_closest_vowel", "question": "Write a function def get_closest_vowel(word): to solve the following problem:\nYou are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive). If the vowel is \n    uppercase, return \"Uppercase\", if it is lowercase, return \"Lowercase\". If the vowel \n    does not exist, return \"\". \n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel that met the above condition. \n\n    You may assume that \n    - the given string contains English letters or ASCII symbols only\n    - if the string contains non-alphanumeric characters, they are considered \n      consonants.\n\n    Example:\n    get_closest_vowel(\"yogurt\") ==> {'vowel': 'u', 'case': 'Lowercase'}\n    get_closest_vowel(\"FULL\") ==> {'vowel': 'U', 'case': 'Uppercase'}\n    get_closest_vowel(\"quick\") ==> {\"vowel\": \"\", \"case\": \"\"}\n    get_closest_vowel(\"ab\") ==> {\"vowel\": \"\", \"case\": \"\"}\n", "context": "def get_closest_vowel(word):"}
{"key": 119, "prompt": "import itertools\n\ndef match_parens(lst, n):\n    '''\n    You are given a list of n strings, each string consists of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate any number of these strings in\n    any order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')'], 2) == 'Yes'\n    match_parens([')', ')'], 2) == 'No'\n    '''\n", "canonical_solution": "    def check(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    perm = itertools.permutations(lst, n)\n    for combination in list(perm):\n        S = ''.join(combination)\n        if check(S):\n            return 'Yes'\n    return 'No'", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(['()(', ')'], 2) == 'Yes'\n    assert candidate([')', ')'], 2) == 'No'\n    assert candidate(['(()(())', '())())'], 2) == 'No'\n    assert candidate([')())', '(()()('], 2) == 'Yes'\n    assert candidate(['(())))', '(()())(('], 2) == 'Yes'\n    assert candidate(['()', '())'], 2) == 'No'\n    assert candidate(['(()(', '()))()'], 2) == 'Yes'\n    assert candidate(['((((', '((())'], 2) == 'No'\n    assert candidate([')(()', '(()('], 2) == 'No'\n    assert candidate([')(', ')('], 2) == 'No'\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(['(', ')'], 2) == 'Yes'\n    assert candidate([')', '('], 2) == 'Yes' \n\n    # Testing with more strings and longer length\n    assert candidate([')', ')', ')', '('], 4) == 'No'\n    assert candidate(['(', ')', '(', ')'], 4) == 'Yes'\n    assert candidate(['(', '(', ')', ')'], 4) == 'Yes'", "entry_point": "match_parens", "question": "Write a function def match_parens(lst, n): to solve the following problem:\nYou are given a list of n strings, each string consists of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate any number of these strings in\n    any order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')'], 2) == 'Yes'\n    match_parens([')', ')'], 2) == 'No'\n", "context": "import itertools\n\ndef match_parens(lst, n):"}
{"key": 120, "prompt": "\n\ndef maximum(arr, k):\n    \"\"\"\n    Given an array arr of integers, return a sorted list of length k with the \n    maximum k numbers divided by 2. \n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-2.0, -1.5, 2.5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [2.0, 2.0]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [1.0]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n", "canonical_solution": "\n\n    if k == 0:\n        return []\n    arr.sort()\n    ans = [i/2 for i in arr[-k:]]\n    return ans\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([-3, -4, 5], 3) == [-2.0, -1.5, 2.5]\n    assert candidate([4, -4, 4], 2) == [2.0, 2.0]\n    assert candidate([-3, 2, 1, 2, -1, -2, 1], 1) == [1.0]\n    assert candidate([123, -123, 20, 0 , 1, 2, -3], 3) == [1.0, 10.0, 61.5]\n    assert candidate([-123, 20, 0 , 1, 2, -3], 4) == [0, 0.5, 1.0, 10.0]\n    assert candidate([5, 15, 0, 3, -13, -8, 0], 7) == [-6.5, -4.0, 0, 0, 1.5, 2.5, 7.5]\n    assert candidate([-1, 0, 2, 5, 3, -10], 2) == [1.5, 2.5]\n    assert candidate([1, 0, 5, -7], 1) == [2.5]\n    assert candidate([4, -4], 2) == [-2.0, 2.0]\n    assert candidate([-10, 10], 2) == [-5.0, 5.0]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 2, 3, -23, 243, -400, 0], 0) == []\n\n\n", "entry_point": "maximum", "question": "Write a function def maximum(arr, k): to solve the following problem:\nGiven an array arr of integers, return a sorted list of length k with the \n    maximum k numbers divided by 2. \n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-2.0, -1.5, 2.5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [2.0, 2.0]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [1.0]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n", "context": "def maximum(arr, k):"}
{"key": 121, "prompt": "\n\ndef solution(lst, num):\n    \"\"\"\n    Given a non-empty list of integers, perform following operations:\n    1. Take all odd elements that occurs at even positions.\n    2. Multiply all these odd elements in even positions with a given number.\n    3. Sum up all the modified elements.\n    \n    Parameters:\n    lst : List to process.\n    num : Number to Multiply\n    \n    Returns:\n    Integer : Return the sum of all the modified elements.\n\n    Examples:\n    solution([5, 8, 7, 1], 2) ==> 24\n    solution([3, 3, 3, 3, 3], 3) ==> 27\n    solution([30, 13, 24, 321], 5) ==> 0\n    \"\"\"\n", "canonical_solution": "\n\n    return sum([num*x for idx, x in enumerate(lst) if idx%2 == 0 and x%2 == 1])\n\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([5, 8, 7, 1], 2) == 24\n    assert candidate([3, 3, 3, 3, 3], 3) == 27\n    assert candidate([30, 13, 24, 321], 5) == 0\n    assert candidate([5, 9], 4) == 20\n    assert candidate([2, 4, 8], 3) == 0\n    assert candidate([30, 13, 23, 32], 7) == 161\n    assert candidate([3, 13, 2, 9], 2) == 6\n", "entry_point": "solution", "question": "Write a function def solution(lst, num): to solve the following problem:\nGiven a non-empty list of integers, perform following operations:\n    1. Take all odd elements that occurs at even positions.\n    2. Multiply all these odd elements in even positions with a given number.\n    3. Sum up all the modified elements.\n    \n    Parameters:\n    lst : List to process.\n    num : Number to Multiply\n    \n    Returns:\n    Integer : Return the sum of all the modified elements.\n\n    Examples:\n    solution([5, 8, 7, 1], 2) ==> 24\n    solution([3, 3, 3, 3, 3], 3) ==> 27\n    solution([30, 13, 24, 321], 5) ==> 0\n", "context": "def solution(lst, num):"}
{"key": 122, "prompt": "\ndef add_elements(arr, k, d):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, integer d, return\n    the sum of the elements with at most d digits from the first k elements of arr. If there are\n    numbers with negative value, treat them as positive for the purpose of considering digit count.\n\n    Example:\n\n        Input: arr = [111,21,-3,4000,5,6,7,8,9], k = 4, d = 2\n        Output: 24 # sum of 21 + 3 (consider -3 as 3 for digit count)\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n        3. 1 <= d <= 3\n    \"\"\"\n", "canonical_solution": "\n    return sum(elem for elem in arr[:k] if len(str(abs(elem))) <= d)\n", "test": "\ndef check(candidate):\n    # Check some simple cases\n    assert candidate([1,-2,-3,41,57,76,87,88,99], 3, 2) == -4\n    assert candidate([111,121,3,4000,5,6], 2, 1) == 0\n    assert candidate([11,21,3,90,5,6,7,8,9], 4, 2) == 125\n    assert candidate([111,21,3,4000,5,6,7,8,9], 4, 2) == 24, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1], 1, 1) == 1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([123], 1, 1) == 0, \"This prints if this assert fails 3 (also good for debugging!)\"\n", "entry_point": "add_elements", "question": "Write a function def add_elements(arr, k, d): to solve the following problem:\nGiven a non-empty array of integers arr and an integer k, integer d, return\n    the sum of the elements with at most d digits from the first k elements of arr. If there are\n    numbers with negative value, treat them as positive for the purpose of considering digit count.\n\n    Example:\n\n        Input: arr = [111,21,-3,4000,5,6,7,8,9], k = 4, d = 2\n        Output: 24 # sum of 21 + 3 (consider -3 as 3 for digit count)\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n        3. 1 <= d <= 3\n", "context": "def add_elements(arr, k, d):"}
{"key": 123, "prompt": "\n\n\ndef get_odd_collatz_steps(n):\n    \"\"\"\n    Given a positive integer n, return two lists. \n    1. A sorted list that has the odd numbers in collatz sequence.\n    2. A list of all steps that the sequence has to take to reach one from n.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz_steps(5) returns ([1, 5], [5, 16, 8, 4, 2, 1])  # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5 and the steps taken are [5, 16, 8, 4, 2, 1]\n    \"\"\"\n", "canonical_solution": "    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    steps = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n/2\n        else:\n            n = n*3 + 1\n\n        steps.append(int(n))\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz), steps", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(14) == ([1, 5, 7, 11, 13, 17], [14, 7, 22, 11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1])\n    assert candidate(5) == ([1, 5], [5, 16, 8, 4, 2, 1])\n    assert candidate(12) == ([1, 3, 5], [12, 6, 3, 10, 5, 16, 8, 4, 2, 1])\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1) == ([1], [1]), \"Check for base case failed\"\n\n", "entry_point": "get_odd_collatz_steps", "question": "Write a function def get_odd_collatz_steps(n): to solve the following problem:\nGiven a positive integer n, return two lists. \n    1. A sorted list that has the odd numbers in collatz sequence.\n    2. A list of all steps that the sequence has to take to reach one from n.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    get_odd_collatz_steps(5) returns ([1, 5], [5, 16, 8, 4, 2, 1])  # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5 and the steps taken are [5, 16, 8, 4, 2, 1]\n", "context": "def get_odd_collatz_steps(n):"}
{"key": 124, "prompt": "from datetime import datetime\ndef valid_date_ext(date, check_future_dates = False):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    Now, add the following additional rules to make the problem more challenging:\n    5. If 'check_future_dates' is True. Return False for all the dates in the future with comparison to current time.\n    6. Check leap years i.e. February can have 29 days in leap years only.\n\n    for example: \n    valid_date_ext('03-11-2080', True) => False (Assuming at the time of function execution 2080 is a future year)\n\n    valid_date_ext('15-01-2012') => False\n\n    valid_date_ext('02-29-2100', False) => False (2100 is not a leap year)\n\n    valid_date_ext('06-04-2020') => True\n\n    valid_date_ext('06/04/2020') => False\n    \"\"\"\n", "canonical_solution": "    try:\n        date = date.strip()\n        month, day, year = date.split('-')\n        month, day, year = int(month), int(day), int(year)\n        today = datetime.now()\n        if month < 1 or month > 12:\n            return False\n        if check_future_dates and year > today.year or (year == today.year and (month > today.month or (month == today.month and day > today.day))):\n            return False\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            leap_year = True\n        else:\n            leap_year = False\n        if month in [1,3,5,7,8,10,12] and (day < 1 or day > 31):\n            return False\n        if month in [4,6,9,11] and (day < 1 or day > 30):\n            return False\n        if month == 2 and (day < 1 or day > 29 or (day == 29 and not leap_year)):\n            return False\n    except:\n        return False\n\n    return True", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate('03-11-2000') == True\n\n    assert candidate('15-01-2012') == False\n\n    assert candidate('02-29-2100', False) == False\n\n    assert candidate('06-04-2020') == True\n\n    assert candidate('03-11-2080', True) == False\n\n    assert candidate('04-0-2040') == False\n\n    assert candidate('01-01-2007') == True\n\n    assert candidate('06/04/2020') == False\n\n    assert candidate('') == False\n\n    assert candidate('06-06-2005') == True\n\n    assert candidate('21-31-2000') == False\n\n    assert candidate('04-12-2003') == True\n", "entry_point": "valid_date_ext", "question": "Write a function def valid_date_ext(date, check_future_dates = False): to solve the following problem:\nYou have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    Now, add the following additional rules to make the problem more challenging:\n    5. If 'check_future_dates' is True. Return False for all the dates in the future with comparison to current time.\n    6. Check leap years i.e. February can have 29 days in leap years only.\n\n    for example: \n    valid_date_ext('03-11-2080', True) => False (Assuming at the time of function execution 2080 is a future year)\n\n    valid_date_ext('15-01-2012') => False\n\n    valid_date_ext('02-29-2100', False) => False (2100 is not a leap year)\n\n    valid_date_ext('06-04-2020') => True\n\n    valid_date_ext('06/04/2020') => False\n", "context": "from datetime import datetime\ndef valid_date_ext(date, check_future_dates = False):"}
{"key": 125, "prompt": "\n\ndef advanced_split_words(txt, split_char=None):\n    '''\n    Given a string of words, this function will perform different tasks based on input:\n    - If the string contains spaces, it will split the string on spaces.\n    - If there are no spaces but it contains commas, it will split the string on commas.\n    - If there are no spaces or commas but it contains the character input by the user in split_char, then it will split the string on that character.\n    - If none of the above are provided in the string, the function will return the number of lower-case letters with odd indices in the alphabet (ord('a') = 0, ord('b') = 1, ... ord('z') = 25)\n\n    Examples:\n\n    advanced_split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    advanced_split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    advanced_split_words(\"Hello-world!\", \"-\") \u279e [\"Hello\", \"world!\"]\n    advanced_split_words(\"abcdef\") \u279e 3\n    '''\n", "canonical_solution": "    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.split(\",\")\n    elif split_char and split_char in txt:\n        return txt.split(split_char)\n    else:\n        return len([i for i in txt if i.islower() and (ord(i)-ord('a'))%2 != 0])", "test": "\n\ndef check(candidate):\n    assert candidate(\"Hello world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello,world!\") == [\"Hello\",\"world!\"]\n    assert candidate(\"Hello-world!\", \"-\") == [\"Hello\",\"world!\"]\n    assert candidate(\"abcdef\") == 3\n    assert candidate(\"aaabb\") == 2\n    assert candidate(\"abc,dfe\", \",\") == [\"abc\",\"dfe\"]\n    assert candidate(\"abc;dfe\", \";\") == [\"abc\",\"dfe\"]\n    assert candidate(\"abc dfe\") == [\"abc\",\"dfe\"]\n    assert candidate(\"abcDfe\") == 2\n    assert candidate(\"\") == 0\n\n", "entry_point": "advanced_split_words", "question": "Write a function def advanced_split_words(txt, split_char=None): to solve the following problem:\nGiven a string of words, this function will perform different tasks based on input:\n    - If the string contains spaces, it will split the string on spaces.\n    - If there are no spaces but it contains commas, it will split the string on commas.\n    - If there are no spaces or commas but it contains the character input by the user in split_char, then it will split the string on that character.\n    - If none of the above are provided in the string, the function will return the number of lower-case letters with odd indices in the alphabet (ord('a') = 0, ord('b') = 1, ... ord('z') = 25)\n\n    Examples:\n\n    advanced_split_words(\"Hello world!\") \u279e [\"Hello\", \"world!\"]\n    advanced_split_words(\"Hello,world!\") \u279e [\"Hello\", \"world!\"]\n    advanced_split_words(\"Hello-world!\", \"-\") \u279e [\"Hello\", \"world!\"]\n    advanced_split_words(\"abcdef\") \u279e 3\n", "context": "def advanced_split_words(txt, split_char=None):"}
{"key": 126, "prompt": "\ndef is_sorted_advanced(lst, ascending=True, allow_duplicates=False):\n    '''\n    Modify the previous list sorting function with two additional parameters: \n    - \"ascending\" (default is True), which indicates whether the list should be in ascending (True) or \n      descending (False) order. \n    - \"allow_duplicates\" (default is False), which if True allows duplicate values in the list, but if \n      False disallows duplicates.\n    \n    Note: Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted_advanced([5]) \u279e True\n    is_sorted_advanced([5, 4, 3, 2, 1], ascending=False) \u279e True\n    is_sorted_advanced([1, 2, 3, 4, 5]) \u279e True\n    is_sorted_advanced([1, 3, 2, 4, 5]) \u279e False\n    is_sorted_advanced([1, 2, 3, 4, 5, 5], allow_duplicates=True) \u279e True\n    is_sorted_advanced([1, 2, 3, 4, 5, 5]) \u279e False\n    '''\n", "canonical_solution": "\n    if not allow_duplicates and len(lst) != len(set(lst)):\n        return False\n    if ascending:\n        return all(lst[i] <= lst[i + 1] for i in range(len(lst) - 1))\n    else:\n        return all(lst[i] >= lst[i + 1] for i in range(len(lst) - 1))\n", "test": "\ndef check(candidate):\n    assert candidate([5]) == True\n    assert candidate([5, 4, 3, 2, 1], ascending=False) == True\n    assert candidate([1, 2, 3, 4, 5]) == True\n    assert candidate([1, 3, 2, 4, 5]) == False\n    assert candidate([1, 2, 3, 4, 5, 5], allow_duplicates=True) == True\n    assert candidate([1, 2, 3, 4, 5, 5]) == False\n    assert candidate([3, 2, 1]) == False\n    assert candidate([3, 2, 1], ascending=False) == True\n    assert candidate([], ascending=False) == True\n    assert candidate([1], allow_duplicates=True) == True\n    assert candidate([1, 1, 1, 1, 1, 1], allow_duplicates=True) == True\n    assert candidate([1, 1, 1, 1, 1, 1], allow_duplicates=False) == False\n", "entry_point": "is_sorted_advanced", "question": "Write a function def is_sorted_advanced(lst, ascending=True, allow_duplicates=False): to solve the following problem:\nModify the previous list sorting function with two additional parameters: \n    - \"ascending\" (default is True), which indicates whether the list should be in ascending (True) or \n      descending (False) order. \n    - \"allow_duplicates\" (default is False), which if True allows duplicate values in the list, but if \n      False disallows duplicates.\n    \n    Note: Assume no negative numbers and only integers.\n\n    Examples\n    is_sorted_advanced([5]) \u279e True\n    is_sorted_advanced([5, 4, 3, 2, 1], ascending=False) \u279e True\n    is_sorted_advanced([1, 2, 3, 4, 5]) \u279e True\n    is_sorted_advanced([1, 3, 2, 4, 5]) \u279e False\n    is_sorted_advanced([1, 2, 3, 4, 5, 5], allow_duplicates=True) \u279e True\n    is_sorted_advanced([1, 2, 3, 4, 5, 5]) \u279e False\n", "context": "def is_sorted_advanced(lst, ascending=True, allow_duplicates=False):"}
{"key": 127, "prompt": "\ndef intersection_extended(interval1, interval2, interval3):\n    \"\"\"You are given three intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these three \n    intervals is a prime number, and,, whether this prime number is in the Fibonacci sequence.\n    For example, the intersection of the intervals (1, 4), (2, 5) and (3,6) is (3,4)\n    which its length is 1, a prime number but not in Fibonacci sequence.\n    If the length of the intersection is a prime number and is in the Fibonacci sequence, return \"YES\",\n    otherwise, return \"NO\".\n    If the three intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection_extended((1, 2), (2, 3), (3,4)) ==> \"NO\"\n    intersection_extended((-1, 1), (0, 4), (-2,2)) ==> \"NO\"\n    intersection_extended((-3, -1), (-5, 5), (-7,7))  ==> \"YES\"\n    \"\"\"\n", "canonical_solution": "    def is_prime(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n    \n    def is_fibonacci(n):\n        a = 0\n        b = 1\n        while (a <= n):\n            if (a == n):\n                return True\n            a, b = b, a + b\n        return False\n\n    l = max(interval1[0], interval2[0], interval3[0])\n    r = min(interval1[1], interval2[1], interval3[1])\n    length = r - l\n    if length > 0 and is_prime(length) and is_fibonacci(length):\n        return \"YES\"\n    return \"NO\"", "test": "\ndef check(candidate):\n    assert candidate((1, 2), (2, 3), (3,4)) == \"NO\"\n    assert candidate((-1, 1), (0, 4), (-2,2)) == \"NO\"\n    assert candidate((-3, -1), (-5, 5), (-7,7)) == \"YES\"\n    assert candidate((-2, 2), (-4, 0), (-6,-1)) == \"NO\"\n    assert candidate((-4, 6), (-2, 8), (0, 10)) == \"NO\"\n", "entry_point": "intersection_extended", "question": "Write a function def intersection_extended(interval1, interval2, interval3): to solve the following problem:\nYou are given three intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of intersection of these three \n    intervals is a prime number, and,, whether this prime number is in the Fibonacci sequence.\n    For example, the intersection of the intervals (1, 4), (2, 5) and (3,6) is (3,4)\n    which its length is 1, a prime number but not in Fibonacci sequence.\n    If the length of the intersection is a prime number and is in the Fibonacci sequence, return \"YES\",\n    otherwise, return \"NO\".\n    If the three intervals don't intersect, return \"NO\".\n\n\n    [input/output] samples:\n    intersection_extended((1, 2), (2, 3), (3,4)) ==> \"NO\"\n    intersection_extended((-1, 1), (0, 4), (-2,2)) ==> \"NO\"\n    intersection_extended((-3, -1), (-5, 5), (-7,7))  ==> \"YES\"\n", "context": "def intersection_extended(interval1, interval2, interval3):"}
{"key": 128, "prompt": "\ndef prod_signs_modified(arr, power):\n    \"\"\"\n    You are given an array arr of integers and value of power.\n    You need to return sum of magnitudes of each integer raised to given power, \n    multiplied by product of all signs of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs_modified([1, 2, 2, -4],2) == -25\n    >>> prod_signs_modified([0, 1],3) == 0\n    >>> prod_signs_modified([],2) == None\n    \"\"\"\n", "canonical_solution": "\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([pow(abs(i), power) for i in arr])\n", "test": "\ndef check(candidate):\n    # Check some sample cases\n    assert candidate([1, 2, 2, -4], 2) == -25, \"This prints if this assert fails 1\"\n    assert candidate([0, 1], 3) == 0, \"This prints if this assert fails 2\"\n    assert candidate([1, 1, 1, 2, 3, -1, 1], 1 ) == -10, \" This prints if this assert fails 3\"\n    assert candidate([2, 4,1, 2, -1, -1, 9], 1) == 20, \"This prints if this assert fails 4\"\n    assert candidate([-1, 1, -1, 1], 3) == 4, \"This prints if this assert fails 5\"\n    assert candidate([-1, 1, 1, 1], 2) == -4, \"This prints if this assert fails 6\"\n    assert candidate([-1, 1, 1, 0], 3) == 0, \"This prints if this assert fails 7\"\n    assert candidate([], 2) == None, \"This prints if this assert fails 8\"\n\n    # Check some cases that are easy to work out by hand.\n    assert candidate([1,2,3,4,5], 2) == 55, \"This prints if this assert fails 9\"\n\n    # Check some edge cases\n    assert candidate([0,0,0,0,0], 2) == 0, \"This prints if this assert fails 10\"\n", "entry_point": "prod_signs_modified", "question": "Write a function def prod_signs_modified(arr, power): to solve the following problem:\nYou are given an array arr of integers and value of power.\n    You need to return sum of magnitudes of each integer raised to given power, \n    multiplied by product of all signs of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> prod_signs_modified([1, 2, 2, -4],2) == -25\n    >>> prod_signs_modified([0, 1],3) == 0\n    >>> prod_signs_modified([],2) == None\n", "context": "def prod_signs_modified(arr, power):"}
{"key": 129, "prompt": "\n\ndef minPath(grid, k, steps):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range \n    [1, N * N] inclusive appears exactly once on the cells of the grid.\n\n    Now you have to find the minimum path of length k + steps in the grid.\n    You can start from any cell, and in each step you can move to any of\n    the neighbor cells,in other words, you can go to cells which share an \n    edge with you current cell.\n\n    Please note that a path of length k + steps means visiting exactly k + \n    steps cells (not necessarily distinct). Here, steps is a non-negative \n    integer ( steps >= 0 and steps <= N*N-k)\n\n    You CANNOT go off the grid.\n    A path A (of length k + steps) is considered less than a path B (of length k + steps) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k+steps)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3, steps = 2\n        Output: [1, 2, 1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1, steps = 3\n        Output: [1, 4, 1, 4]\n    \"\"\"\n", "canonical_solution": "\n\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i - 1][j])\n\n                if j != 0:\n                    temp.append(grid[i][j - 1])\n\n                if i != n - 1:\n                    temp.append(grid[i + 1][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j + 1])\n\n                val = min(temp)\n                \n    totalLength = k+steps\n    ans = []\n    for i in range(totalLength):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n\n", "test": "\n\ndef check(candidate):\n    \n    assert candidate([[1, 2, 3], [4, 5, 6], [7, 8, 9]], 3, 2) == [1, 2, 1, 2, 1]\n    assert candidate([[5, 9, 3], [4, 1, 6], [7, 8, 2]], 1, 3) == [1, 4, 1, 4]\n    assert candidate([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]], 4, 2) == [1, 2, 1, 2, 1, 2]\n    assert candidate([[6, 4, 13, 10], [5, 7, 12, 1], [3, 16, 11, 15], [8, 14, 9, 2]], 3, 4) == [1, 10, 1, 10, 1, 10, 1]\n\n", "entry_point": "minPath", "question": "Write a function def minPath(grid, k, steps): to solve the following problem:\nGiven a grid with N rows and N columns (N >= 2) and a positive integer k,\n    each cell of the grid contains a value. Every integer in the range \n    [1, N * N] inclusive appears exactly once on the cells of the grid.\n\n    Now you have to find the minimum path of length k + steps in the grid.\n    You can start from any cell, and in each step you can move to any of\n    the neighbor cells,in other words, you can go to cells which share an \n    edge with you current cell.\n\n    Please note that a path of length k + steps means visiting exactly k + \n    steps cells (not necessarily distinct). Here, steps is a non-negative \n    integer ( steps >= 0 and steps <= N*N-k)\n\n    You CANNOT go off the grid.\n    A path A (of length k + steps) is considered less than a path B (of length k + steps) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k+steps)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3, steps = 2\n        Output: [1, 2, 1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1, steps = 3\n        Output: [1, 4, 1, 4]\n", "context": "def minPath(grid, k, steps):"}
{"key": 130, "prompt": "\n\n\ndef tetra(n):\n    \"\"\"The Fibonacci sequence and Tribonacci sequence are well-known to many, but did \n    you know about the Tetranacci sequence? It\u2019s a sequence similar to Fibonacci and \n    Tribonacci, but instead of adding the last two or three numbers to get the next one, \n    we add the last four numbers.\n\n    This is how the Tetranacci sequence is defined:\n    tetra(0) = 0\n    tetra(1) = 1\n    tetra(2) = 1 \n    tetra(3) = 2\n    tetra(n) = tetra(n - 1) + tetra(n - 2) + tetra(n - 3) + tetra(n - 4) for n > 3\n\n    For example:\n    tetra(4) = tetra(3) + tetra(2) + tetra(1) + tetra(0) = 2 + 1 + 1 + 0 = 4\n    tetra(5) = tetra(4) + tetra(3) + tetra(2) + tetra(1) = 4 + 2 + 1 + 1 = 8\n\n    You are given a non-negative integer number n, you have to return a list of the \n    first n + 1 numbers of the Tetranacci sequence.\n\n    Examples:\n    tetra(4) = [0, 1, 1, 2, 4]\n    \"\"\"\n", "canonical_solution": "\n\n    if n == 0:\n        return [0]\n    elif n == 1:\n        return [0, 1]\n    elif n == 2:\n        return [0, 1, 1]\n    elif n == 3:\n        return [0, 1, 1, 2]\n\n    my_tetr = [0, 1, 1, 2]\n    for i in range(4, n + 1):\n        my_tetr.append(my_tetr[i - 1] + my_tetr[i - 2] + my_tetr[i - 3] + my_tetr[i - 4])\n    return my_tetr\n\n", "test": "\n\ndef check(candidate):\n    assert candidate(4) == [0, 1, 1, 2, 4]\n    assert candidate(5) == [0, 1, 1, 2, 4, 8]\n    assert candidate(6) == [0, 1, 1, 2, 4, 8, 15]\n    assert candidate(7) == [0, 1, 1, 2, 4, 8, 15, 29]\n    assert candidate(8) == [0, 1, 1, 2, 4, 8, 15, 29, 56]\n    assert candidate(9) == [0, 1, 1, 2, 4, 8, 15, 29, 56, 108]\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(0) == [0]\n    assert candidate(1) == [0, 1]\n    assert candidate(2) == [0, 1, 1]\n    assert candidate(3) == [0, 1, 1, 2]\n\n", "entry_point": "tetra", "question": "Write a function def tetra(n): to solve the following problem:\nThe Fibonacci sequence and Tribonacci sequence are well-known to many, but did \n    you know about the Tetranacci sequence? It\u2019s a sequence similar to Fibonacci and \n    Tribonacci, but instead of adding the last two or three numbers to get the next one, \n    we add the last four numbers.\n\n    This is how the Tetranacci sequence is defined:\n    tetra(0) = 0\n    tetra(1) = 1\n    tetra(2) = 1 \n    tetra(3) = 2\n    tetra(n) = tetra(n - 1) + tetra(n - 2) + tetra(n - 3) + tetra(n - 4) for n > 3\n\n    For example:\n    tetra(4) = tetra(3) + tetra(2) + tetra(1) + tetra(0) = 2 + 1 + 1 + 0 = 4\n    tetra(5) = tetra(4) + tetra(3) + tetra(2) + tetra(1) = 4 + 2 + 1 + 1 = 8\n\n    You are given a non-negative integer number n, you have to return a list of the \n    first n + 1 numbers of the Tetranacci sequence.\n\n    Examples:\n    tetra(4) = [0, 1, 1, 2, 4]\n", "context": "def tetra(n):"}
{"key": 131, "prompt": "\ndef multi_digits(n, m):\n    \"\"\"\n    Given two positive integers n and m, return the product of the odd digits of n \n    raised to the power of m.\n    Return 0 if all digits are even.\n    \n    For example:\n    multi_digits(1, 3)  == 1\n    multi_digits(4, 5)  == 0\n    multi_digits(235, 2) == 225\n    \"\"\"\n", "canonical_solution": "    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product *= int_digit**m\n            odd_count += 1\n    if odd_count == 0:\n        return 0\n    else:\n        return product", "test": "\ndef check(candidate):\n    assert candidate(5, 2) == 25\n    assert candidate(54, 3) == 125\n    assert candidate(120, 10) == 1\n    assert candidate(5014, 3) == 125\n    assert candidate(98765, 2) == 99225\n    assert candidate(5576543, 1) == 2625\n    assert candidate(2468, 2) == 0\n", "entry_point": "multi_digits", "question": "Write a function def multi_digits(n, m): to solve the following problem:\nGiven two positive integers n and m, return the product of the odd digits of n \n    raised to the power of m.\n    Return 0 if all digits are even.\n    \n    For example:\n    multi_digits(1, 3)  == 1\n    multi_digits(4, 5)  == 0\n    multi_digits(235, 2) == 225\n", "context": "def multi_digits(n, m):"}
{"key": 132, "prompt": "\n\n\ndef is_nested_advanced(string):\n    '''\n    Create a function that takes a string as input which contains only two types of brackets- square and round.\n    The function should check two conditions:\n    1. Return True if and only if there is a valid subsequence of square brackets where at least one bracket in the subsequence is nested.\n    2. It should also check if all round brackets are balanced.\n    \n    If both conditions are satisfied, return True, else return False.\n    \n    Examples:\n    is_nested_advanced('[[]]()') \u279e True\n    is_nested_advanced('([])]]]]]][([[[[[])]') \u279e False\n    is_nested_advanced('[()]') \u279e False\n    is_nested_advanced('[([])]') \u279e True\n    '''\n", "canonical_solution": "\n    opening_square = []\n    closing_square = []\n    opening_round = 0\n    closing_round = 0\n\n    for i in range(len(string)):\n        if string[i] == '[':\n            opening_square.append(i)\n        elif string[i] == ']':\n            closing_square.append(i)\n        elif string[i] == '(':\n            opening_round += 1\n        elif string[i] == ')':\n            closing_round += 1\n\n    if opening_round != closing_round:\n        return False\n\n    closing_square.reverse()\n\n    cnt = 0\n    i = 0\n    l = len(closing_square)\n\n    for idx in opening_square:\n        if i < l and idx < closing_square[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2", "test": "\n\ndef check(candidate):\n\n    # Checking simple cases:\n    assert candidate('[[]]()') == True\n    assert candidate('([])]]]]]][[[[[])]') == False\n    assert candidate('[(])') == False\n    assert candidate('[([])]') == True\n    assert candidate('[()]') == False\n    assert candidate('[([])]') == True\n    assert candidate('[[[()]]]') == True\n\n    # Checking edge cases:\n    assert candidate('') == False\n    assert candidate('[[[[[[[[') == False\n    assert candidate(']]]]]]]]') == False\n    assert candidate('((((((') == False\n    assert candidate('))))))') == False\n    assert candidate(')(((') == False\n\n    print('All test cases passed')\n", "entry_point": "is_nested_advanced", "question": "Write a function def is_nested_advanced(string): to solve the following problem:\nCreate a function that takes a string as input which contains only two types of brackets- square and round.\n    The function should check two conditions:\n    1. Return True if and only if there is a valid subsequence of square brackets where at least one bracket in the subsequence is nested.\n    2. It should also check if all round brackets are balanced.\n    \n    If both conditions are satisfied, return True, else return False.\n    \n    Examples:\n    is_nested_advanced('[[]]()') \u279e True\n    is_nested_advanced('([])]]]]]][([[[[[])]') \u279e False\n    is_nested_advanced('[()]') \u279e False\n    is_nested_advanced('[([])]') \u279e True\n", "context": "def is_nested_advanced(string):"}
{"key": 133, "prompt": "\ndef sum_squares_and_cubes(lst):\n    \"\"\"\n    You are given a list of numbers.\n    You need to return the sum of squared and cubed numbers in the given list.\n    Round each element in the list to the upper int(Ceiling) first before processing it.\n    If the number is even, find the square of it. \n    If the number is odd, find the cube of it.\n\n    Examples:\n    For lst = [1,2,3] the output should be 1+4+27 = 32\n    For lst = [1,4,9] the output should be 1+16+729 = 746\n    For lst = [1,3,5,7] the output should be 1+27+125+343 = 496\n    For lst = [1.4,4.2,0] the output should be 4+125+0 = 129\n    For lst = [-2.4,1,1] the output should be 4+1+1 = 6\n    \"\"\"\n", "canonical_solution": "\n\n    import math\n    squared_cubed = 0\n    for i in lst:\n        num = math.ceil(i)\n        if num % 2 == 0:\n            squared_cubed += num**2\n        else:\n            squared_cubed += num**3\n    return squared_cubed\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3])==32, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.0,2,3])==32, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,3,5,7])==496, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1.4,4.2,0])==129, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-2.4,1,1])==6, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    assert candidate([100,1,15,2])==13380, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([10000,10000])==200000000, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,4.6,6.3])==467, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([-1.4,17.9,18.9,19.9])==7582, \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1])==-1, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate([-1,1,0])==0, \"This prints if this assert fails 2 (also good for debugging!)\"\n", "entry_point": "sum_squares_and_cubes", "question": "Write a function def sum_squares_and_cubes(lst): to solve the following problem:\nYou are given a list of numbers.\n    You need to return the sum of squared and cubed numbers in the given list.\n    Round each element in the list to the upper int(Ceiling) first before processing it.\n    If the number is even, find the square of it. \n    If the number is odd, find the cube of it.\n\n    Examples:\n    For lst = [1,2,3] the output should be 1+4+27 = 32\n    For lst = [1,4,9] the output should be 1+16+729 = 746\n    For lst = [1,3,5,7] the output should be 1+27+125+343 = 496\n    For lst = [1.4,4.2,0] the output should be 4+125+0 = 129\n    For lst = [-2.4,1,1] the output should be 4+1+1 = 6\n", "context": "def sum_squares_and_cubes(lst):"}
{"key": 134, "prompt": "\ndef check_if_last_char_is_a_letter_multiple(txt_list):\n    '''\n    Here we are extending our function from taking a single string \n    to a list of strings. The function should return a list of True and\n    False values in respective order if the last character of a each given \n    string in the list is an alphabetical character and is not a part of \n    a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter_multiple([\"apple pie\",\"apple pi e\",\"apple pi e \",\"\"]) \n    \u279e [False,True,False,False] \n    check_if_last_char_is_a_letter_multiple([\"eeeee\", \"A\", \"Pumpkin pie\",\"Pumpkin pie 1\"]) \n    \u279e [False,True,False,False]\n    '''\n", "canonical_solution": "    results = []\n    for txt in txt_list:\n        check = txt.split(' ')[-1]\n        results.append(True if len(check) == 1 and (97 <= ord(check.lower()) <= 122) else False)\n    return results", "test": "\ndef check(candidate):\n    assert candidate([\"apple\",\"apple pi e\",\"eeeee\"]) == [False,True,False]\n    assert candidate([\"eeeee\", \"A\", \"Pumpkin pie \",\"Pumpkin pie 1\"]) == [False,True,False,False]\n    assert candidate([\"\", \"eeeee e \",\"apple pie\",\"apple pi e \"]) == [False,False,False,False]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "check_if_last_char_is_a_letter_multiple", "question": "Write a function def check_if_last_char_is_a_letter_multiple(txt_list): to solve the following problem:\nHere we are extending our function from taking a single string \n    to a list of strings. The function should return a list of True and\n    False values in respective order if the last character of a each given \n    string in the list is an alphabetical character and is not a part of \n    a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    check_if_last_char_is_a_letter_multiple([\"apple pie\",\"apple pi e\",\"apple pi e \",\"\"]) \n    \u279e [False,True,False,False] \n    check_if_last_char_is_a_letter_multiple([\"eeeee\", \"A\", \"Pumpkin pie\",\"Pumpkin pie 1\"]) \n    \u279e [False,True,False,False]\n", "context": "def check_if_last_char_is_a_letter_multiple(txt_list):"}
{"key": 135, "prompt": "def largest_breaking_index(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it - if no such element exists then return -1. \n    Additionally if there is an element which is exactly five greater than the element immediately following it, \n    the function should return the index of this element. If no such element exists return -1. \n    The function should prioritize returning the second condition over the first. If neither conditions are met return -1. \n    array will not contain duplicate values.\n\n    Examples:\n    largest_breaking_index([1,2,4,3,5]) = 3\n    largest_breaking_index([1,2,7]) = 1\n    \"\"\"\n", "canonical_solution": "    ind1 = -1\n    ind2 = -1\n    i = 1\n    while i < len(arr):\n        if arr[i] < arr[i - 1]:\n            ind1 = i\n        if arr[i - 1] == arr[i] + 5:\n            ind2 = i - 1\n        i += 1\n    if ind2 != -1:\n        return ind2\n    elif ind1 != -1:\n        return ind1\n    else:\n        return -1", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,4,3,5])==3\n    assert candidate([1,8,3])==1\n    assert candidate([1,6,2,5,6,7,8,9,10])== 2\n    assert candidate([2,3,9,5,7])== 3\n\n    # Check some edge case: empty list.\n    assert candidate([])==-1", "entry_point": "largest_breaking_index", "question": "Write a function def largest_breaking_index(arr): to solve the following problem:\nCreate a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it - if no such element exists then return -1. \n    Additionally if there is an element which is exactly five greater than the element immediately following it, \n    the function should return the index of this element. If no such element exists return -1. \n    The function should prioritize returning the second condition over the first. If neither conditions are met return -1. \n    array will not contain duplicate values.\n\n    Examples:\n    largest_breaking_index([1,2,4,3,5]) = 3\n    largest_breaking_index([1,2,7]) = 1\n", "context": "def largest_breaking_index(arr):"}
{"key": 136, "prompt": "\n\ndef largest_smallest_integers_duplicates(lst):\n    '''\n\tCreate a function that returns a tuple (a, b, c, d), where 'a' is\n    the largest of negative integers, 'b' is the second largest of negative integers,\n    'c' is the smallest of positive integers, and 'd' is the second smallest positive integers in a list.\n    If there is no second negative or second positive integer, return them as None.\n    If there is no negative or positive integers, also return them as None.\n\n    Examples:\n    largest_smallest_integers_duplicates([2, 4, 1, 3, 5, 7]) == (None, None, 1, 2)\n    largest_smallest_integers_duplicates([]) == (None, None, None, None)\n    largest_smallest_integers_duplicates([0]) == (None, None, None, None)\n    largest_smallest_integers_duplicates([1, 10, -1, -10]) == (-1, -10, 1, 10)\n    largest_smallest_integers_duplicates([-3, -2, -5, 1, 3, 5]) == (-2, -3, 1, 3)\n    '''\n", "canonical_solution": "    smallest = sorted(list(filter(lambda x: x<0, lst)))\n    largest = sorted(list(filter(lambda x: x>0, lst)))\n    return (smallest[-1] if len(smallest)>=1 else None, smallest[-2] if len(smallest)>=2 else None, largest[0] if len(largest)>=1 else None, largest[1] if len(largest)>=2 else None)", "test": "\n\ndef check(candidate):\n    # Check some simple cases\n    assert candidate([2, 4, 1, 3, 5, 7]) == (None, None, 1, 2)\n    assert candidate([2, 4, 1, 3, 5, 7, 0]) == (None, None, 1, 2)\n    assert candidate([1, 3, 2, 4, 5, 6, -2, -3]) == (-2, -3, 1, 2)\n    assert candidate([4, 5, 3, 6, 2, 7, -7, -8]) == (-7, -8, 2, 3)\n    assert candidate([7, 3, 8, 4, 9, 2, 5, -9, -10]) == (-9, -10, 2, 3)\n    assert candidate([]) == (None, None, None, None)\n    assert candidate([0]) == (None, None, None, None)\n    assert candidate([-1, -3, -5, -6]) == (-1, -3, None, None)\n    assert candidate([-1, -3, -5, -6, 0]) == (-1, -3, None, None)\n    assert candidate([-6, -4, -4, -3, 1, 2]) == (-3, -4, 1, 2)\n    assert candidate([-6, -4, -4, -3, -100, 1, 2]) == (-3, -4, 1, 2)\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1, 10, -1, -10]) == (-1, -10, 1, 10)\n    assert candidate([-3, -2, -5, 1, 3, 5]) == (-2, -3, 1, 3)\n    assert True\n\n", "entry_point": "largest_smallest_integers_duplicates", "question": "Write a function def largest_smallest_integers_duplicates(lst): to solve the following problem:\nCreate a function that returns a tuple (a, b, c, d), where 'a' is\n    the largest of negative integers, 'b' is the second largest of negative integers,\n    'c' is the smallest of positive integers, and 'd' is the second smallest positive integers in a list.\n    If there is no second negative or second positive integer, return them as None.\n    If there is no negative or positive integers, also return them as None.\n\n    Examples:\n    largest_smallest_integers_duplicates([2, 4, 1, 3, 5, 7]) == (None, None, 1, 2)\n    largest_smallest_integers_duplicates([]) == (None, None, None, None)\n    largest_smallest_integers_duplicates([0]) == (None, None, None, None)\n    largest_smallest_integers_duplicates([1, 10, -1, -10]) == (-1, -10, 1, 10)\n    largest_smallest_integers_duplicates([-3, -2, -5, 1, 3, 5]) == (-2, -3, 1, 3)\n", "context": "def largest_smallest_integers_duplicates(lst):"}
{"key": 137, "prompt": "\ndef compare_two(a1, b1, a2, b2):\n    \"\"\"\n    Create a function that takes two pairs of integers, floats, or strings representing\n    real numbers. For each pair, the function should return the larger variable in its given \n    variable type. For each pair, return None if the values are equal.\n    The function should return a list of two elements, corresponding to the larger (or equal) \n    variable of each pair.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_two(1, 2.5, 2, 3) \u279e [2.5, 3]\n    compare_two(1, \"2,3\", \"3.4\", 3) \u279e [\"2,3\", 3]\n    compare_two(\"5,1\", \"6\", 7, 8) \u279e [\"6\", 8]\n    compare_two(\"1\", 1, 2.5,\"3.2\") \u279e [None, \"3.2\"]\n    \"\"\"\n", "canonical_solution": "    temp_a1, temp_b1 = a1, b1\n    temp_a2, temp_b2 = a2, b2\n    \n    if isinstance(temp_a1, str): temp_a1 = temp_a1.replace(',','.')\n    if isinstance(temp_b1, str): temp_b1 = temp_b1.replace(',','.')\n    if isinstance(temp_a2, str): temp_a2 = temp_a2.replace(',','.')\n    if isinstance(temp_b2, str): temp_b2 = temp_b2.replace(',','.')\n    \n    if float(temp_a1) == float(temp_b1): result1 = None\n    else: result1 = a1 if float(temp_a1) > float(temp_b1) else b1\n\n    if float(temp_a2) == float(temp_b2): result2 = None\n    else: result2 = a2 if float(temp_a2) > float(temp_b2) else b2\n    \n    return [result1, result2]", "test": "\ndef check(candidate):\n    # Check some simple cases\n    assert candidate(1, 2, 3, 4) == [2, 4]\n    assert candidate(1, 2.5, 5, 6) == [2.5, 6]\n    assert candidate(2, 3, 7, 8) == [3, 8]\n    assert candidate(5, 6, 9, 10) == [6, 10]\n    assert candidate(1, \"2,3\", \"3,2\", 4) == [\"2,3\", 4]\n    assert candidate(\"5,1\", \"6\", 8, \"9,1\") == [\"6\", \"9,1\"]\n    assert candidate(\"1\", \"2\", 1.2, \"1.5\") == [\"2\", \"1.5\"]\n    assert candidate(\"1\", 1, 2.5, \"3.2\") == [None, \"3.2\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n", "entry_point": "compare_two", "question": "Write a function def compare_two(a1, b1, a2, b2): to solve the following problem:\nCreate a function that takes two pairs of integers, floats, or strings representing\n    real numbers. For each pair, the function should return the larger variable in its given \n    variable type. For each pair, return None if the values are equal.\n    The function should return a list of two elements, corresponding to the larger (or equal) \n    variable of each pair.\n    Note: If a real number is represented as a string, the floating point might be . or ,\n\n    compare_two(1, 2.5, 2, 3) \u279e [2.5, 3]\n    compare_two(1, \"2,3\", \"3.4\", 3) \u279e [\"2,3\", 3]\n    compare_two(\"5,1\", \"6\", 7, 8) \u279e [\"6\", 8]\n    compare_two(\"1\", 1, 2.5,\"3.2\") \u279e [None, \"3.2\"]\n", "context": "def compare_two(a1, b1, a2, b2):"}
{"key": 138, "prompt": "\n\ndef is_equal_to_sum_even_nums(n, num_count):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly \"num_count\" positive even numbers\n    Example\n    is_equal_to_sum_even_nums(4, 1) == True\n    is_equal_to_sum_even_nums(6, 2) == True\n    is_equal_to_sum_even_nums(8, 4) == True\n    is_equal_to_sum_even_nums(10, 5) == False\n    \"\"\"\n", "canonical_solution": "\n\n    return n%2 == 0 and n >= num_count*2\n\n", "test": "\n\ndef check(candidate):\n  assert candidate(4, 1) == True   \n  assert candidate(6, 2) == True\n  assert candidate(8, 4) == True\n  assert candidate(10, 10) == False\n  assert candidate(10, 5) == True\n  assert candidate(20, 13) == False\n  assert candidate(16, 2) == True\n  assert candidate(3, 1) == False\n\n", "entry_point": "is_equal_to_sum_even_nums", "question": "Write a function def is_equal_to_sum_even_nums(n, num_count): to solve the following problem:\nEvaluate whether the given number n can be written as the sum of exactly \"num_count\" positive even numbers\n    Example\n    is_equal_to_sum_even_nums(4, 1) == True\n    is_equal_to_sum_even_nums(6, 2) == True\n    is_equal_to_sum_even_nums(8, 4) == True\n    is_equal_to_sum_even_nums(10, 5) == False\n", "context": "def is_equal_to_sum_even_nums(n, num_count):"}
{"key": 139, "prompt": "\n\n\ndef super_special_factorial(n, m):\n    \"\"\"\n    The Super Brazilian Factorial is defined as:\n    super_brazilian_factorial(n, m) = (n!)^m * ((n-1)!)^m * ((n-2)!)^m * ... * ((1!)^m)\n    where n > 0 and m is a positive integer representing the power each number n is raised to before the factorial operation\n\n    For example:\n    >>> super_special_factorial(4, 2)\n    34456960000\n\n    The function will receive two integers as inputs and should return the super special factorial of these integers.\n    \"\"\"\n", "canonical_solution": "\n    fact_i = 1\n    super_special_fact = 1\n    for i in range(1, n+1):\n        fact_i *= (i**m)\n        super_special_fact *= fact_i\n    return super_special_fact", "test": "def check(candidate):\n    # Check some simple cases\n    assert candidate(4, 2) == 82944, \"Test 4, 2\"\n    assert candidate(3, 3) == 1728, \"Test 3, 3\"\n    assert candidate(2, 5) == 32, \"Test 2, 5\"\n    assert candidate(4, 1) == 288, \"Test 4\"\n    assert candidate(5, 1) == 34560, \"Test 5\"\n    assert candidate(7, 1) == 125411328000, \"Test 7\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 100) == 1, \"Test 1, 100\"", "entry_point": "super_special_factorial", "question": "Write a function def super_special_factorial(n, m): to solve the following problem:\nThe Super Brazilian Factorial is defined as:\n    super_brazilian_factorial(n, m) = (n!)^m * ((n-1)!)^m * ((n-2)!)^m * ... * ((1!)^m)\n    where n > 0 and m is a positive integer representing the power each number n is raised to before the factorial operation\n\n    For example:\n    >>> super_special_factorial(4, 2)\n    34456960000\n\n    The function will receive two integers as inputs and should return the super special factorial of these integers.\n", "context": "def super_special_factorial(n, m):"}
{"key": 140, "prompt": "\ndef complex_fix(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscore ('_'), \n    if a string has 2 consecutive spaces, replace them with double underscore ('__'), \n    if a string has more than 2 consecutives spaces, replace them with a single dash ('-'), \n    and if string has any digits, replace them with their word equivalent.\n    \n    complex_fix(\"Example\") => \"Example\"\n    complex_fix(\"Example 1\") => \"Example_one\"\n    complex_fix(\" Example 2\") => \"_Example_two\"\n    complex_fix(\" Example   3\") => \"_Example-three\"\n    complex_fix(\"  Example 1 2 3\") => \"__Example_one_two_three\"\n    \"\"\"\n", "canonical_solution": "    num_to_word = { '1': 'one','2': 'two','3': 'three', '4': 'four',  '5': 'five',\n                    '6': 'six','7': 'seven','8': 'eight', '9': 'nine', '0': 'zero'}\n\n    new_text = \"\"\n    i = 0\n    start, end = 0, 0\n    while i < len(text):\n        if text[i] == \" \":\n            end += 1\n        else:\n            if end - start > 2:\n                new_text += \"-\" + text[i]\n            elif end - start > 0:\n                new_text += \"_\" * (end - start) + text[i]\n            else:\n                new_text += text[i]\n            start, end = i + 1, i + 1\n        i += 1\n    if end - start > 2:\n        new_text += \"-\"\n    elif end - start > 0:\n        new_text += \"_\"\n\n    new_text = ''.join([num_to_word[ch] if ch.isdigit() else ch for ch in new_text])\n\n    return new_text", "test": "\ndef check(candidate):\n    # Check some cases\n    assert candidate(\"Example\") == \"Example\"\n    assert candidate(\"Hello Test1\") == \"Hello_Testone\"\n    \n    # Check edge cases that are easy to work out by hand.\n    assert candidate(\"Example  1\") == \"Example__one\"\n    assert candidate(\" Example 2\") == \"_Example_two\"\n    assert candidate(\" Example   3\") == \"_Example-three\"\n    assert candidate(\"  Example 1 2 3\") == \"__Example_one_two_three\"\n\n    print(\"All tests passed!\")\n\n# Run the check function with the provided solution\ncheck(complex_fix)\n", "entry_point": "complex_fix", "question": "Write a function def complex_fix(text): to solve the following problem:\nGiven a string text, replace all spaces in it with underscore ('_'), \n    if a string has 2 consecutive spaces, replace them with double underscore ('__'), \n    if a string has more than 2 consecutives spaces, replace them with a single dash ('-'), \n    and if string has any digits, replace them with their word equivalent.\n    \n    complex_fix(\"Example\") => \"Example\"\n    complex_fix(\"Example 1\") => \"Example_one\"\n    complex_fix(\" Example 2\") => \"_Example_two\"\n    complex_fix(\" Example   3\") => \"_Example-three\"\n    complex_fix(\"  Example 1 2 3\") => \"__Example_one_two_three\"\n", "context": "def complex_fix(text):"}
{"key": 141, "prompt": "\n\ndef file_check(file_data):\n    \"\"\"Create a function which takes a dictionary encompassing a file's metadata,\n    and returns 'Yes' if the the file's metadata is valid, and returns 'No' otherwise.\n    \n    The file's metadata is considered to be valid if and only if all the following conditions \n    are met:\n    \n    - 'file_name': Represents the file's name\n      * There should not be more than three digits ('0'-'9') in the file's name.\n      * The file's name contains exactly one dot '.'\n      * The substring before the dot should not be empty, and it starts with a letter from \n        the latin alphapet ('a'-'z' and 'A'-'Z').\n      * The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\n    - 'file_size': Represents the file's size in kilobytes. This should be a positive integer less than or equal to 8192 (denoting 8 gigabytes).\n    \n    Examples:\n    \n    file_check({\"file_name\": \"example.txt\", \"file_size\": 2048}) # => 'Yes'\n    file_check({\"file_name\": \"1example.dll\", \"file_size\": 6000}) # => 'No' (the name should start with a latin alphapet letter)\n    \"\"\"\n", "canonical_solution": "    file_name = file_data[\"file_name\"]\n    file_size = file_data[\"file_size\"]\n    \n    suf = ['txt', 'exe', 'dll']\n    lst = file_name.split(sep='.')\n    \n    if len(lst) != 2:\n        return 'No'\n    if not lst[1] in suf:\n        return 'No'\n    if len(lst[0]) == 0:\n        return 'No'\n    if not lst[0][0].isalpha():\n        return 'No'\n    t = len([x for x in lst[0] if x.isdigit()])\n    if t > 3:\n        return 'No'\n    \n    if not isinstance(file_size, int) or file_size <= 0 or file_size > 8192:\n        return 'No'\n    \n    return 'Yes'", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate({\"file_name\": \"example.txt\", \"file_size\": 2048}) == 'Yes'\n    assert candidate({\"file_name\": \"1example.dll\", \"file_size\": 6000}) == 'No'\n    \n    # Check some edge cases\n    assert candidate({\"file_name\": \".dll\", \"file_size\": 200}) == 'No'\n    assert candidate({\"file_name\": \"s.\", \"file_size\": 200}) == 'No'\n    \n    # Checking with file size\n    assert candidate({\"file_name\": \"example.txt\", \"file_size\": -2048}) == 'No'\n    assert candidate({\"file_name\": \"example.txt\", \"file_size\": '2048'}) == 'No'\n    assert candidate({\"file_name\": \"example.txt\", \"file_size\": 9000}) == 'No'\n\n", "entry_point": "file_check", "question": "Write a function def file_check(file_data): to solve the following problem:\nCreate a function which takes a dictionary encompassing a file's metadata,\n    and returns 'Yes' if the the file's metadata is valid, and returns 'No' otherwise.\n    \n    The file's metadata is considered to be valid if and only if all the following conditions \n    are met:\n    \n    - 'file_name': Represents the file's name\n      * There should not be more than three digits ('0'-'9') in the file's name.\n      * The file's name contains exactly one dot '.'\n      * The substring before the dot should not be empty, and it starts with a letter from \n        the latin alphapet ('a'-'z' and 'A'-'Z').\n      * The substring after the dot should be one of these: ['txt', 'exe', 'dll']\n\n    - 'file_size': Represents the file's size in kilobytes. This should be a positive integer less than or equal to 8192 (denoting 8 gigabytes).\n    \n    Examples:\n    \n    file_check({\"file_name\": \"example.txt\", \"file_size\": 2048}) # => 'Yes'\n    file_check({\"file_name\": \"1example.dll\", \"file_size\": 6000}) # => 'No' (the name should start with a latin alphapet letter)\n", "context": "def file_check(file_data):"}
{"key": 142, "prompt": "def advanced_sum_squares(lst1, lst2):\n    \"\"\"\n    This function will take two lists of integers. It will operate on both lists, independently as follows: \n    For all entries in the list, if its index is a multiple of 3, the function shall square the integer entry. If its index is a \n    multiple of 4 and not a multiple of 3, the function will cube the integer entry. Entries in the list whose indexes are not a multiple \n    of 3 or 4 are not changed. \n    Then the function will return the a list of two items. The first one will be the sum of all entries in the first list and the \n    second one is the sum of all entries in the second list.\n    \n    Examples:\n    For lst1 = [1,2,3], lst2 = [4,5,6] the output should be [6, 32]\n    For lst1 = [], lst2 = [1,2,3]  the output should be [0, 6]\n    For lst1 = [-1,-5,2,-1,-5], lst2=[]  the output should be [-126, 0]\n    \"\"\"\n", "canonical_solution": "\n    result1 =[]\n    result2 =[]\n    \n    for i in range(len(lst1)):\n        if i %3 == 0:\n            result1.append(lst1[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result1.append(lst1[i]**3)\n        else:\n            result1.append(lst1[i])\n\n    for i in range(len(lst2)):\n        if i %3 == 0:\n            result2.append(lst2[i]**2)\n        elif i % 4 == 0 and i%3 != 0:\n            result2.append(lst2[i]**3)\n        else:\n            result2.append(lst2[i])\n              \n    return [sum(result1), sum(result2)]", "test": "def check(candidate):\n\n    # Check some simple cases\n    \n    assert candidate([1,2,3], [4,5,6]) == [6, 27]\n    assert candidate([1,4,9], [8,7,6]) == [14, 77]\n    assert candidate([], [1,2,3]) == [0, 6]\n    assert candidate([-1,-5,2,-1,-5], []) == [-126, 0]\n    assert candidate([-56,-99,1,0,-2], [1,2,3,4,5,6,7,8,9]) == [3030, 939]\n    assert candidate([1,1,1,1,1,1,1,1,1], [-1,-1,-1,-1,-1,-1,-1,-1,-1]) == [9, -3]\n    assert candidate([-1,-1,-1,-1,-1,-1,-1,-1,-1],[-1,-5,2,-1,-5]) == [-3, -126]\n    ", "entry_point": "advanced_sum_squares", "question": "Write a function def advanced_sum_squares(lst1, lst2): to solve the following problem:\nThis function will take two lists of integers. It will operate on both lists, independently as follows: \n    For all entries in the list, if its index is a multiple of 3, the function shall square the integer entry. If its index is a \n    multiple of 4 and not a multiple of 3, the function will cube the integer entry. Entries in the list whose indexes are not a multiple \n    of 3 or 4 are not changed. \n    Then the function will return the a list of two items. The first one will be the sum of all entries in the first list and the \n    second one is the sum of all entries in the second list.\n    \n    Examples:\n    For lst1 = [1,2,3], lst2 = [4,5,6] the output should be [6, 32]\n    For lst1 = [], lst2 = [1,2,3]  the output should be [0, 6]\n    For lst1 = [-1,-5,2,-1,-5], lst2=[]  the output should be [-126, 0]\n", "context": "def advanced_sum_squares(lst1, lst2):"}
{"key": 143, "prompt": "\n\n\ndef words_in_sentences(sentences):\n    \"\"\"\n    You are given a list of strings representing sentences,\n    each sentence contains some words separated by a space,\n    and you have to return a list of strings, each string in the list corresponding to the sentences in the original list\n    that contains the words whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original sentence.\n\n    Example 1:\n        Input: sentences = [\"This is a test\", \"lets go for swimming\"]\n        Output: [\"is\", \"go for\"]\n\n    Example 2:\n        Input: sentences = [\"there is no place available here\", \"Hi I am Hussein\", \"go for it\"]\n        Output: [\"there is no place\", \"Hi am Hussein\", \"go for it\" ]\n\n    Constraints:\n        * 1 <= len(sentences) <= 100\n        * 1 <= len(sentence in sentences) <= 100\n        * sentence contains only letters\n    \"\"\"\n", "canonical_solution": "    result = []\n    for sentence in sentences:\n        new_lst = []\n        for word in sentence.split():\n            flg = 0\n            if len(word) == 1:\n                flg = 1\n            for i in range(2, len(word)):\n                if len(word)%i == 0:\n                    flg = 1\n            if flg == 0 or len(word) == 2:\n                new_lst.append(word)\n        result.append(\" \".join(new_lst))\n    return result", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"This is a test\", \"lets go for swimming\"]) == [\"is\", \"go for\"]\n    assert candidate([\"there is no place available here\", \"Hi I am Hussein\", \"go for it\"]) == [\"there is no place\", \"Hi am Hussein\", \"go for it\" ]\n   \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"here\"]) == [\"\"]\n    assert candidate([\"here is\"]) == [\"is\"]\n\n\n", "entry_point": "words_in_sentences", "question": "Write a function def words_in_sentences(sentences): to solve the following problem:\nYou are given a list of strings representing sentences,\n    each sentence contains some words separated by a space,\n    and you have to return a list of strings, each string in the list corresponding to the sentences in the original list\n    that contains the words whose lengths are prime numbers,\n    the order of the words in the new string should be the same as the original sentence.\n\n    Example 1:\n        Input: sentences = [\"This is a test\", \"lets go for swimming\"]\n        Output: [\"is\", \"go for\"]\n\n    Example 2:\n        Input: sentences = [\"there is no place available here\", \"Hi I am Hussein\", \"go for it\"]\n        Output: [\"there is no place\", \"Hi am Hussein\", \"go for it\" ]\n\n    Constraints:\n        * 1 <= len(sentences) <= 100\n        * 1 <= len(sentence in sentences) <= 100\n        * sentence contains only letters\n", "context": "def words_in_sentences(sentences):"}
{"key": 144, "prompt": "\ndef simplify_multiple(x_list, n_list):\n    \"\"\"\n    Your task is to implement a function that will simplify a list of fractions multiplied by another list of fractions.\n    The function should return a list of True and False, where True means the value of the multiplication \n    evaluates to a whole number, and False means it does not.\n    \n    Each of x_list and n_list is a list of string representations of fractions with the format,\n    <numerator>/<denominator>, where both numerator and denominator always are positive whole numbers.\n    The lengths of x_list and n_list are always the same.\n    \n    You could assume that all fractions in x_list and n_list are valid fractions and have non-zero denominators.\n    \n    simplify_multiple([\"1/5\", \"1/6\"], [\"5/1\", \"2/1\"]) = [True, False]\n    simplify_multiple([\"7/10\", \"2/10\"], [\"10/2\", \"50/10\"]) = [False, True]\n    simplify_multiple([\"2/4\"], [\"8/4\"]) = [True]\n\n    \"\"\"\n", "canonical_solution": "\n    result = []\n\n    for i in range(len(x_list)):\n        a, b = x_list[i].split('/')\n        c, d = n_list[i].split('/')\n        numerator = int(a) * int(c)\n        denominator = int(b) * int(d)\n        if (numerator/denominator) == int(numerator/denominator):\n            result.append(True)\n        else:\n            result.append(False)\n            \n    return result", "test": "\ndef check(candidate):\n\n    # Apply try-except to handle AssertionErrors\n    try:\n        assert candidate([\"1/5\", \"1/6\"], [\"5/1\", \"2/1\"]) == [True, False], 'test1'\n        assert candidate([\"7/10\", \"1/6\"], [\"10/2\", \"2/1\"]) == [False, False], 'test2'\n        assert candidate([\"1/5\", \"1/6\", \"2/10\"], [\"5/1\", \"2/1\", \"5/1\"]) == [True, False, True], 'test3'\n        assert candidate([\"2/4\"], [\"8/4\"]) == [True], 'test4'\n        assert candidate([\"1/5\", \"2/6\"], [\"5/1\", \"3/1\"]) == [True, True], 'test5'\n    except AssertionError as e:\n        print(f'Error: {str(e)}')\n", "entry_point": "simplify_multiple", "question": "Write a function def simplify_multiple(x_list, n_list): to solve the following problem:\nYour task is to implement a function that will simplify a list of fractions multiplied by another list of fractions.\n    The function should return a list of True and False, where True means the value of the multiplication \n    evaluates to a whole number, and False means it does not.\n    \n    Each of x_list and n_list is a list of string representations of fractions with the format,\n    <numerator>/<denominator>, where both numerator and denominator always are positive whole numbers.\n    The lengths of x_list and n_list are always the same.\n    \n    You could assume that all fractions in x_list and n_list are valid fractions and have non-zero denominators.\n    \n    simplify_multiple([\"1/5\", \"1/6\"], [\"5/1\", \"2/1\"]) = [True, False]\n    simplify_multiple([\"7/10\", \"2/10\"], [\"10/2\", \"50/10\"]) = [False, True]\n    simplify_multiple([\"2/4\"], [\"8/4\"]) = [True]\n", "context": "def simplify_multiple(x_list, n_list):"}
{"key": 145, "prompt": "\ndef order_by_points(nums):\n    \"\"\"\n    Write a function which sorts the given list of integers\n    in ascending order according to the sum and the product of their digits.\n    If the sum of the digits of two numbers are equal, then compare by the product.\n    If both sum and product are equal, order them based on their index in original list.\n    For negative numbers, consider their absolute values for the comparison.\n\n    For example:\n    >>> order_by_points([132, 231, 321]) == [132, 231, 321]\n    >>> order_by_points([]) == []\n    \"\"\"\n", "canonical_solution": "\n    def digits_sum_and_product(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg\n        return sum(n), prod(n)\n    \n    def prod(lst):\n        result = 1\n        for i in lst:\n            result *= i\n        return result\n\n    return sorted(nums, key=digits_sum_and_product)", "test": "def check(candidate):\n    # Check some simple cases\n    assert candidate([132, 231, 321]) == [132, 231, 321]\n    assert candidate([]) == []\n    assert candidate([1, 11, -1, -11, -12]) == [-1, -11, -12, 1, 11]\n    assert candidate([1234,423,463,145,2,423,423,53,6,37,3457,3,56,0,46]) == [0, 2, 3, 6, 53, 423, 423, 423, 145, 37, 1234, 46, 56, 463, 3457]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([10, 11, 20, 22]) == [10, 20, 11, 22]\n    assert candidate([-10, -11, -20, -22]) == [-20, -10, -22, -11]\n    assert candidate([-10, 11, -20, 22]) == [-20, -10, 11, 22]", "entry_point": "order_by_points", "question": "Write a function def order_by_points(nums): to solve the following problem:\nWrite a function which sorts the given list of integers\n    in ascending order according to the sum and the product of their digits.\n    If the sum of the digits of two numbers are equal, then compare by the product.\n    If both sum and product are equal, order them based on their index in original list.\n    For negative numbers, consider their absolute values for the comparison.\n\n    For example:\n    >>> order_by_points([132, 231, 321]) == [132, 231, 321]\n    >>> order_by_points([]) == []\n", "context": "def order_by_points(nums):"}
{"key": 146, "prompt": "def specialFilter(nums):\n    \"\"\"\n    Write a function that takes an array of numbers as input and returns \n    an array of elements in the array that are greater than 10 and less than 100 and divisible by 3, \n    both first and last digits of a number are odd (1, 3, 5, 7, 9).\n    \n    For example:\n    specialFilter([15, -73, 14, -15,18,33,99]) => [33, 99]\n    specialFilter([33, -2, -3, 45, 21, 109,105,93]) => [33,93]\n    \"\"\"\n", "canonical_solution": "    odd_digits = (1, 3, 5, 7, 9)\n    result = []\n    for num in nums:\n        if num > 10 and num<100 and num % 3 == 0:\n            number_as_string = str(num)\n            if int(number_as_string[0]) in odd_digits and int(number_as_string[-1]) in odd_digits:\n                result.append(num)\n    return result", "test": "def check(candidate):\n\n   # Check some simple cases\n    assert candidate([5, -2, 1, -5,18,33,99]) == [33,99]\n    assert candidate([33, -2, -3, 43, 21, 109,105,93]) == [33,93]\n    \n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([1]) == []               \n    assert candidate([]) == []  \n\n    # Check case with all elements are >= 100 or <= 10.\n    assert candidate([100, 101, 10, -1]) == []\n\n    # Check larger numbers.\n    assert candidate([1500, 11000, 17000, 33000, 99000]) == []\n\n    # Check mixed larger and smaller numbers.\n    assert candidate([1500, 105, 15, 99000, 93]) == [15,93]", "entry_point": "specialFilter", "question": "Write a function def specialFilter(nums): to solve the following problem:\nWrite a function that takes an array of numbers as input and returns \n    an array of elements in the array that are greater than 10 and less than 100 and divisible by 3, \n    both first and last digits of a number are odd (1, 3, 5, 7, 9).\n    \n    For example:\n    specialFilter([15, -73, 14, -15,18,33,99]) => [33, 99]\n    specialFilter([33, -2, -3, 45, 21, 109,105,93]) => [33,93]\n", "context": "def specialFilter(nums):"}
{"key": 147, "prompt": "\ndef get_max_triples(n, m):\n    \"\"\" \n    You are given two positive integers n and m. You have to create two integer arrays a and b of length n and m.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        For each j (1 \u2264 j \u2264 m), the value of b[j] = j^3 + (j-1)*(j+1).\n        Return the number of quadruplets (a[i], a[j], b[k],b[l]) of a and b where i < j, 1 \u2264 i,j \u2264 n and k < l, 1 \u2264 k,l \u2264 m, and\n    a[i] + a[j] + b[k]+ b[l] is a multiple of 9.\n\n    Examples :\n        Input: n = 5, m = 3\n        Output: 2\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        b = [1, 11, 35]\n        The valid quadruplets are (1,7,11,35) and (3, 21, 1, 11).\n    \"\"\"\n", "canonical_solution": "    A = [i*i - i + 1 for i in range(1,n+1)]\n    B = [j**3 + (j-1)*(j+1) for j in range(1,m+1)]\n    ans = []\n    for i in range(n):\n        for j in range(i+1,n):\n            for k in range(m):\n                for l in range(k+1,m):\n                    if (A[i]+A[j]+B[k]+B[l])%9 == 0:\n                        ans += [(A[i],A[j],B[k],B[l])]\n    return len(ans)", "test": "def check(candidate):\n    assert candidate(5, 3) == 2\n    assert candidate(6, 4) == 5\n    assert candidate(10, 6) == 54\n    assert candidate(50, 50) == 142432\n", "entry_point": "get_max_triples", "question": "Write a function def get_max_triples(n, m): to solve the following problem:\nYou are given two positive integers n and m. You have to create two integer arrays a and b of length n and m.\n        For each i (1 \u2264 i \u2264 n), the value of a[i] = i * i - i + 1.\n        For each j (1 \u2264 j \u2264 m), the value of b[j] = j^3 + (j-1)*(j+1).\n        Return the number of quadruplets (a[i], a[j], b[k],b[l]) of a and b where i < j, 1 \u2264 i,j \u2264 n and k < l, 1 \u2264 k,l \u2264 m, and\n    a[i] + a[j] + b[k]+ b[l] is a multiple of 9.\n\n    Examples :\n        Input: n = 5, m = 3\n        Output: 2\n        Explanation: \n        a = [1, 3, 7, 13, 21]\n        b = [1, 11, 35]\n        The valid quadruplets are (1,7,11,35) and (3, 21, 1, 11).\n", "context": "def get_max_triples(n, m):"}
{"key": 148, "prompt": "\ndef bf_extended(planet1, planet2, moons=False):\n    '''\n    Write a function that takes two planet names as strings planet1 and planet2,\n    and a boolean moons indicating whether the count of moons for each planet\n    should be included in the output.\n    \n    There are eight planets in our solar system: Mercury(0), Venus(0),\n    Earth(1), Mars(2), Jupiter(79), Saturn(82), Uranus(27), Neptune(14).\n    The numbers in parenthesis indicate the number of moons for each planet.\n    \n    If moons is False, the function should return a tuple containing all \n    planets whose orbits are located between the orbit of planet1 and the \n    orbit of planet2, sorted by the proximity to the sun.\n    \n    If moons is True, the function should return a list of tuples, where each tuple\n    contains a planet name and its moon count, for all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by\n    the proximity to the sun.\n    \n    The function should return an empty tuple or list if planet1 or planet2\n    are not correct planet names or if they're the same planet.\n    \n    Examples\n    bf_extended(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf_extended(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf_extended(\"Mercury\", \"Uranus\", True) ==> [(\"Venus\", 0), (\"Earth\", 1), (\"Mars\", 2), (\"Jupiter\", 79), (\"Saturn\", 82)]\n    '''\n", "canonical_solution": "    planet_data = ((\"Mercury\", 0), (\"Venus\", 0), (\"Earth\", 1), (\"Mars\", 2),\n                   (\"Jupiter\", 79), (\"Saturn\", 82), (\"Uranus\", 27), (\"Neptune\", 14))\n    planet_names = tuple(name for name, moon in planet_data)\n    if planet1 not in planet_names or planet2 not in planet_names or planet1 == planet2:\n        return [] if moons else ()\n        \n    planet1_index = planet_names.index(planet1)\n    planet2_index = planet_names.index(planet2)\n    \n    if moons:\n        if planet1_index < planet2_index:\n            return [planet_data[i] for i in range(planet1_index + 1, planet2_index)]\n        else:\n            return [planet_data[i] for i in range(planet2_index + 1, planet1_index)]\n    else:\n        if planet1_index < planet2_index:\n            return planet_names[planet1_index + 1: planet2_index]\n        else:\n            return planet_names[planet2_index + 1: planet1_index]", "test": "\ndef check(candidate):\n    assert candidate(\"Jupiter\", \"Neptune\") == (\"Saturn\", \"Uranus\")\n    assert candidate(\"Earth\", \"Mercury\") == (\"Venus\",)\n    assert candidate(\"Mercury\", \"Uranus\", True) == [(\"Venus\", 0), (\"Earth\", 1), (\"Mars\", 2), (\"Jupiter\", 79), (\"Saturn\", 82)]\n    assert candidate(\"Neptune\", \"Venus\", True) == [(\"Earth\", 1), (\"Mars\", 2), (\"Jupiter\", 79), (\"Saturn\", 82), (\"Uranus\", 27)]\n    assert candidate(\"Earth\", \"Earth\") == ()\n    assert candidate(\"Mars\", \"Earth\", True) == []\n    assert candidate(\"Jupiter\", \"Quaoar\", True) == []\n\ncheck(bf_extended)\n", "entry_point": "bf_extended", "question": "Write a function def bf_extended(planet1, planet2, moons=False): to solve the following problem:\nWrite a function that takes two planet names as strings planet1 and planet2,\n    and a boolean moons indicating whether the count of moons for each planet\n    should be included in the output.\n    \n    There are eight planets in our solar system: Mercury(0), Venus(0),\n    Earth(1), Mars(2), Jupiter(79), Saturn(82), Uranus(27), Neptune(14).\n    The numbers in parenthesis indicate the number of moons for each planet.\n    \n    If moons is False, the function should return a tuple containing all \n    planets whose orbits are located between the orbit of planet1 and the \n    orbit of planet2, sorted by the proximity to the sun.\n    \n    If moons is True, the function should return a list of tuples, where each tuple\n    contains a planet name and its moon count, for all planets whose orbits are \n    located between the orbit of planet1 and the orbit of planet2, sorted by\n    the proximity to the sun.\n    \n    The function should return an empty tuple or list if planet1 or planet2\n    are not correct planet names or if they're the same planet.\n    \n    Examples\n    bf_extended(\"Jupiter\", \"Neptune\") ==> (\"Saturn\", \"Uranus\")\n    bf_extended(\"Earth\", \"Mercury\") ==> (\"Venus\")\n    bf_extended(\"Mercury\", \"Uranus\", True) ==> [(\"Venus\", 0), (\"Earth\", 1), (\"Mars\", 2), (\"Jupiter\", 79), (\"Saturn\", 82)]\n", "context": "def bf_extended(planet1, planet2, moons=False):"}
{"key": 149, "prompt": "\n\ndef sorted_list_sum(lst, delete_odds=True, sort_by_len=True):\n    \"\"\"Write a function that accepts a list of strings and two boolean flags as parameters,\n    if delete_odds flag is True then it deletes the strings that have odd lengths from it,\n    if sort_by_len flag is True then it sort list by length otherwise sort it alphabetically\n    The resulted list should return in a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"], True, True) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"], True, False) => [\"ab\", \"cd\"]\n    \"\"\"\n", "canonical_solution": "\n\n    lst.sort()\n    new_lst = []\n    for i in lst:\n        if delete_odds:\n            if len(i)%2 == 0:\n                new_lst.append(i)\n        else:\n            new_lst.append(i)\n    if sort_by_len:\n        return sorted(new_lst, key=len)\n    else:\n        return new_lst\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([\"aa\", \"a\", \"aaa\"], True, True) == [\"aa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"], True, True) == [\"AI\", \"asdf\", \"school\"]\n    assert candidate([\"d\", \"b\", \"c\", \"a\"], True, False) == []\n    assert candidate([\"d\", \"dcba\", \"abcd\", \"a\"], True, True) == [\"abcd\", \"dcba\"]\n    \n    # Check when delete_odds flag is False \n    assert candidate([\"aa\", \"a\", \"aaa\"], False, True) == [\"a\", \"aa\", \"aaa\"]\n    assert candidate([\"school\", \"AI\", \"asdf\", \"b\"], False, True) == [\"b\", \"AI\", \"asdf\", \"school\"]\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([\"AI\", \"ai\", \"au\"], True, False) == [\"AI\", \"ai\", \"au\"]\n    assert candidate([\"a\", \"b\", \"b\", \"c\", \"c\", \"a\"], False, False) == [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\"]\n    assert candidate(['aaaa', 'bbbb', 'dd', 'cc'], True, True) == [\"cc\", \"dd\", \"aaaa\", \"bbbb\"]\n\n", "entry_point": "sorted_list_sum", "question": "Write a function def sorted_list_sum(lst, delete_odds=True, sort_by_len=True): to solve the following problem:\nWrite a function that accepts a list of strings and two boolean flags as parameters,\n    if delete_odds flag is True then it deletes the strings that have odd lengths from it,\n    if sort_by_len flag is True then it sort list by length otherwise sort it alphabetically\n    The resulted list should return in a sorted order,\n    The list is always a list of strings and never an array of numbers,\n    and it may contain duplicates.\n    The function should return a list of strings in sorted order.\n    You may assume that all words will have the same length.\n    For example:\n    assert list_sort([\"aa\", \"a\", \"aaa\"], True, True) => [\"aa\"]\n    assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"], True, False) => [\"ab\", \"cd\"]\n", "context": "def sorted_list_sum(lst, delete_odds=True, sort_by_len=True):"}
{"key": 150, "prompt": "\n\n\ndef x_or_y_or_z(n, x, y, z):\n    \"\"\"A simple program which should return the value of x if n is \n    a prime number, should return the value of y if n is an even number, and should return the value of z otherwise.\n\n    Examples:\n    for x_or_y_or_z(7, 34, 12, 20) == 34\n    for x_or_y_or_z(16, 8, 5, 30) == 5\n    for x_or_y_or_z(15, 10, 20, 25) == 25\n    \"\"\"\n", "canonical_solution": "\n\n    if n == 1:\n        return z\n    elif n % 2 == 0:\n        return y\n    for i in range(2, n):\n        if n % i == 0:\n            return z\n            break\n    else:\n        return x\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(7, 34, 12, 20) == 34\n    assert candidate(16, 8, 5, 30) == 5\n    assert candidate(15, 10, 20, 25) == 25\n    assert candidate(3, 33, 5212, 50) == 33\n    assert candidate(1259, 3, 52, 60) == 3\n    assert candidate(20, 1245, 583, 100) == 583\n    assert candidate(91, 56, 129, 200) == 200\n    assert candidate(18, 34, 1234, 500) == 1234\n    \n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(1, 2, 0, 1) == 1\n    assert candidate(2, 2, 0, 1) == 0\n    assert candidate(3, 1, 2, 3) == 1\n    assert candidate(100, 1, 2, 3) == 2\n    assert candidate(101, 1, 2, 3) == 1\n\n", "entry_point": "x_or_y_or_z", "question": "Write a function def x_or_y_or_z(n, x, y, z): to solve the following problem:\nA simple program which should return the value of x if n is \n    a prime number, should return the value of y if n is an even number, and should return the value of z otherwise.\n\n    Examples:\n    for x_or_y_or_z(7, 34, 12, 20) == 34\n    for x_or_y_or_z(16, 8, 5, 30) == 5\n    for x_or_y_or_z(15, 10, 20, 25) == 25\n", "context": "def x_or_y_or_z(n, x, y, z):"}
{"key": 151, "prompt": "\ndef advanced_sum(lst, n):\n    '''\n    Given a list of numbers (lst) and integer (n), returns the sum of (powers of n of \n    the numbers in the list that are odd. Ignore numbers that are negative or not integers.\n\n    advanced_sum([1, 3, 2, 0], 3) == 1 + 27 + 0 + 0 = 28\n    advanced_sum([-1, -2, 0], 2) == 0\n    advanced_sum([9, -2], 2) == 81\n    advanced_sum([0], 3) == 0  \n\n    If the input list is empty, return 0.\n    '''\n", "canonical_solution": "\n    return sum([i**n for i in lst if i > 0 and i%2!=0 and \".\" not in str(i)])\n", "test": "\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([], 2) == 0 , \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([5, 4], 2) == 25 , \"This prints if this assert fails 2 (good for debugging!)\"\n    assert candidate([0.1, 0.2, 0.3], 2) == 0 , \"This prints if this assert fails 3 (good for debugging!)\"\n    assert candidate([-10, -20, -30], 2) == 0 , \"This prints if this assert fails 4 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([-1, -2, 8], 2) == 0, \"This prints if this assert fails 5 (also good for debugging!)\"\n    assert candidate([0.2, 3, 5], 3) == 152, \"This prints if this assert fails 6 (also good for debugging!)\"\n    lst = list(range(-99, 100, 2))\n    odd_sum = sum([i**3 for i in lst if i%2!=0 and i > 0])\n    assert candidate(lst, 3) == odd_sum , \"This prints if this assert fails 7 (good for debugging!)\"\n", "entry_point": "advanced_sum", "question": "Write a function def advanced_sum(lst, n): to solve the following problem:\nGiven a list of numbers (lst) and integer (n), returns the sum of (powers of n of \n    the numbers in the list that are odd. Ignore numbers that are negative or not integers.\n\n    advanced_sum([1, 3, 2, 0], 3) == 1 + 27 + 0 + 0 = 28\n    advanced_sum([-1, -2, 0], 2) == 0\n    advanced_sum([9, -2], 2) == 81\n    advanced_sum([0], 3) == 0  \n\n    If the input list is empty, return 0.\n", "context": "def advanced_sum(lst, n):"}
{"key": 152, "prompt": "\n\ndef compare(game,guess, multipliers):\n    \"\"\"I think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n\n    Enhancing the previous problem: now you are given a third list: multipliers.\n    Let's make the competition more interesting: if someone guesses the result incorrectly, he will be penalized \n    not just by the difference, but by the difference times the corresponding multiplier! If guessed correctly,\n    again, the value is 0.\n\n    You are given 3 lists. The first one contains the actual scores, the second - the guessed scores, the third - multipliers.\n    All of the lists are of equal length. Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score multiplied by the corresponding \n    multiplier from the third list.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2],[1,2,3,4,5,6]) -> [0,0,0,0,15,18]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2],[1,2,3,5,6,4]) -> [4,8,3,0,0,24]\n    \"\"\"\n", "canonical_solution": "\n\n    return [abs(x-y)*z for x,y,z in zip(game,guess,multipliers)]\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate([1,2,3,4,5,1],[1,2,3,4,2,-2],[1,2,3,4,5,6])==[0,0,0,0,15,18], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([0,0,0,0,0,0],[0,0,0,0,0,0],[1,2,3,4,5,6])==[0,0,0,0,0,0], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3],[-1,-2,-3],[1,2,3])==[2,8,18], \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate([1,2,3,5],[-1,2,3,4],[1,2,3,5])==[2,0,0,5], \"This prints if this assert fails 1 (good for debugging!)\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate([0,5,0,0,0,4],[4,1,1,0,0,-2],[1,2,3,5,6,4])==[4,8,3,0,0,24], \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "compare", "question": "Write a function def compare(game,guess, multipliers): to solve the following problem:\nI think we all remember that feeling when the result of some long-awaited\n    event is finally known. The feelings and thoughts you have at that moment are\n    definitely worth noting down and comparing.\n\n    Enhancing the previous problem: now you are given a third list: multipliers.\n    Let's make the competition more interesting: if someone guesses the result incorrectly, he will be penalized \n    not just by the difference, but by the difference times the corresponding multiplier! If guessed correctly,\n    again, the value is 0.\n\n    You are given 3 lists. The first one contains the actual scores, the second - the guessed scores, the third - multipliers.\n    All of the lists are of equal length. Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n    the value is 0, and if not, the value is the absolute difference between the guess and the score multiplied by the corresponding \n    multiplier from the third list.\n    \n    \n    example:\n\n    compare([1,2,3,4,5,1],[1,2,3,4,2,-2],[1,2,3,4,5,6]) -> [0,0,0,0,15,18]\n    compare([0,5,0,0,0,4],[4,1,1,0,0,-2],[1,2,3,5,6,4]) -> [4,8,3,0,0,24]\n", "context": "def compare(game,guess, multipliers):"}
{"key": 153, "prompt": "\n\ndef Strongest_Extension(class_name, extensions, tool_name=None):\n    \"\"\"You will be given the name of a class (a string) and a list of extensions.\n    If provided, you will also be given the name of a tool (another string).\n    The extensions and the tool are to be used to load additional classes to the \n    class. \n\n    The strength of the extension/tool is as follows: Let CAP be the number of \n    the uppercase letters in the extension's/tool's name, and let SM be the \n    number of lowercase letters in the extension's/tool's name, the strength is \n    given by the fraction CAP - SM.\n\n    If the tool isn't provided, find the strongest extension and return a string \n    in this format: ClassName.StrongestExtensionName.\n    If the tool is provided, find the combination of strongest extension and the \n    tool, which gives the maximum strength and return a string in this \n    format: ClassName.ToolName+StrongestExtensionName.\n\n    Assume tool's strength is the sum of tool's own strength and strongest \n    extension's strength. \n\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n   \n    Example: Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    Example: Strongest_Extension('my_class', ['AA', 'Be', 'CC'], 'Tool') \n    == 'my_class.Tool+AA'\n    \"\"\"\n", "canonical_solution": "\n\n    strong = extensions[0]\n    my_val = len([x for x in extensions[0] if x.isalpha() and x.isupper()]) - len([x for x in extensions[0] if x.isalpha() and x.islower()])\n\n    if tool_name:\n        tool_val = len([x for x in tool_name if x.isalpha() and x.isupper()]) - len([x for x in tool_name if x.isalpha() and x.islower()]) \n        my_val += tool_val\n\n    for s in extensions:\n        val = len([x for x in s if x.isalpha() and x.isupper()]) - len([x for x in s if x.isalpha() and x.islower()])\n        if val > my_val - (tool_val if tool_name else 0):\n            strong = s\n            my_val = val + (tool_val if tool_name else 0)\n\n    ans = class_name + \".\" + (tool_name + \"+\" if tool_name else \"\") + strong\n    return ans\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate('Watashi', ['tEN', 'niNE', 'eIGHt8OKe']) == 'Watashi.eIGHt8OKe'\n    assert candidate('Boku123', ['nani', 'NazeDa', 'YEs.WeCaNe', '32145tggg']) == 'Boku123.YEs.WeCaNe'\n    assert candidate('__YESIMHERE', ['t', 'eMptY', 'nothing', 'zeR00', 'NuLl__', '123NoooneB321']) == '__YESIMHERE.NuLl__'\n    assert candidate('K', ['Ta', 'TAR', 't234An', 'cosSo'], 'ToolN') == 'K.ToolN+TAR'\n    assert candidate('__HAHA', ['Tab', '123', '781345', '-_-'], 'toolA') == '__HAHA.toolA+123'\n    assert candidate('YameRore', ['HhAas', 'okIWILL123', 'WorkOut', 'Fails', '-_-'], 'ToolB') == 'YameRore.ToolB+okIWILL123'\n    assert candidate('finNNalLLly', ['Die', 'NowW', 'Wow', 'WoW'], 'toolC') == 'finNNalLLly.toolC+WoW'\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate('_', ['Bb', '91245']) == '_.Bb'\n    assert candidate('Sp', ['671235', 'Bb'], 'ToolD') == 'Sp.ToolD+671235'\n\n", "entry_point": "Strongest_Extension", "question": "Write a function def Strongest_Extension(class_name, extensions, tool_name=None): to solve the following problem:\nYou will be given the name of a class (a string) and a list of extensions.\n    If provided, you will also be given the name of a tool (another string).\n    The extensions and the tool are to be used to load additional classes to the \n    class. \n\n    The strength of the extension/tool is as follows: Let CAP be the number of \n    the uppercase letters in the extension's/tool's name, and let SM be the \n    number of lowercase letters in the extension's/tool's name, the strength is \n    given by the fraction CAP - SM.\n\n    If the tool isn't provided, find the strongest extension and return a string \n    in this format: ClassName.StrongestExtensionName.\n    If the tool is provided, find the combination of strongest extension and the \n    tool, which gives the maximum strength and return a string in this \n    format: ClassName.ToolName+StrongestExtensionName.\n\n    Assume tool's strength is the sum of tool's own strength and strongest \n    extension's strength. \n\n    If there are two or more extensions with the same strength, you should\n    choose the one that comes first in the list.\n   \n    Example: Strongest_Extension('my_class', ['AA', 'Be', 'CC']) == 'my_class.AA'\n    Example: Strongest_Extension('my_class', ['AA', 'Be', 'CC'], 'Tool') \n    == 'my_class.Tool+AA'\n", "context": "def Strongest_Extension(class_name, extensions, tool_name=None):"}
{"key": 154, "prompt": "\ndef cycpattern_and_substring_check(a, b, c):\n    \"\"\"You are given 3 words: 'a', 'b' and 'c'. \n    You need to return True if the following conditions are met:\n        - the second word or any of its rotations is a substring in the first word, \n        - the third word is a substring in the first word.\n        if either of these conditions is not met, return False.\n        \n    cycpattern_and_substring_check(\"abcd\",\"abd\", \"cd\") => False\n    cycpattern_and_substring_check(\"hello\",\"ell\", \"o\") => True\n    cycpattern_and_substring_check(\"whassup\",\"psus\", \"up\") => False\n    cycpattern_and_substring_check(\"abab\",\"baa\", \"ab\") => True\n    cycpattern_and_substring_check(\"efef\",\"eeff\", \"ef\") => False\n    cycpattern_and_substring_check(\"himenss\",\"simen\", \"ss\") => True\n    \"\"\"\n", "canonical_solution": "\n    # b rotation and substring check\n    l = len(b)\n    pat = b + b\n    bstatus = False\n    for i in range(len(a) - l + 1):\n        for j in range(l + 1):\n            if a[i:i+l] == pat[j:j+l]:\n                bstatus = True\n    # c substring check\n    cstatus = False\n    if c in a:\n        cstatus = True\n    return bstatus and cstatus\n", "test": "\n\ndef check(candidate):\n\n    assert  candidate(\"xyzw\",\"xyw\", \"z\") == False , \"test #0\"\n    assert  candidate(\"yello\",\"ell\", \"o\") == True , \"test #1\"\n    assert  candidate(\"whattup\",\"ptut\", \"up\") == False , \"test #2\"\n    assert  candidate(\"efef\",\"fee\", \"e\") == True , \"test #3\"\n    assert  candidate(\"abab\",\"aabb\", \"a\") == False , \"test #4\"\n    assert  candidate(\"winemtt\",\"tinem\", \"t\") == True , \"test #5\"\n", "entry_point": "cycpattern_and_substring_check", "question": "Write a function def cycpattern_and_substring_check(a, b, c): to solve the following problem:\nYou are given 3 words: 'a', 'b' and 'c'. \n    You need to return True if the following conditions are met:\n        - the second word or any of its rotations is a substring in the first word, \n        - the third word is a substring in the first word.\n        if either of these conditions is not met, return False.\n        \n    cycpattern_and_substring_check(\"abcd\",\"abd\", \"cd\") => False\n    cycpattern_and_substring_check(\"hello\",\"ell\", \"o\") => True\n    cycpattern_and_substring_check(\"whassup\",\"psus\", \"up\") => False\n    cycpattern_and_substring_check(\"abab\",\"baa\", \"ab\") => True\n    cycpattern_and_substring_check(\"efef\",\"eeff\", \"ef\") => False\n    cycpattern_and_substring_check(\"himenss\",\"simen\", \"ss\") => True\n", "context": "def cycpattern_and_substring_check(a, b, c):"}
{"key": 155, "prompt": "def even_odd_prime_count(num):\n    \"\"\"\n    Given an integer, return a tuple that includes the count of even digits, \n    odd digits, and prime digits respectively.\n\n     Example:\n        even_odd_prime_count(-12) ==> (1, 1, 0)\n        even_odd_prime_count(123) ==> (1, 2, 2)\n        even_odd_prime_count(2357) ==> (0, 4, 4)\n    \"\"\"\n", "canonical_solution": "    \n    even_count = 0\n    odd_count = 0\n    prime_count = 0\n    prime_numbers = ['2','3','5','7']\n    for i in str(abs(num)):\n        if int(i) % 2 == 0:\n            even_count +=1\n        if int(i) % 2 != 0:\n            odd_count +=1\n        if i in prime_numbers:\n            prime_count += 1\n    return (even_count, odd_count, prime_count)", "test": "\ndef check(candidate):\n    assert candidate(7) == (0, 1, 1)\n    assert candidate(-78) == (1, 1, 1)\n    assert candidate(3452) == (2, 2, 3)\n    assert candidate(346211) == (3, 3, 2)\n    assert candidate(-345821) == (3, 3, 3)\n    assert candidate(-2) == (1, 0, 1)\n    assert candidate(-45347) == (2, 3, 3)\n    assert candidate(0) == (1, 0, 0)\n    assert candidate(2357) == (1, 3, 4)", "entry_point": "even_odd_prime_count", "question": "Write a function def even_odd_prime_count(num): to solve the following problem:\nGiven an integer, return a tuple that includes the count of even digits, \n    odd digits, and prime digits respectively.\n\n     Example:\n        even_odd_prime_count(-12) ==> (1, 1, 0)\n        even_odd_prime_count(123) ==> (1, 2, 2)\n        even_odd_prime_count(2357) ==> (0, 4, 4)\n", "context": "def even_odd_prime_count(num):"}
{"key": 156, "prompt": "\n\n\ndef int_to_comprehensive_roman(small_number, big_number):\n    \"\"\"\n    Given two positive integers, 'small_number' smaller or equal than 'big_number' (1 <= small_number <= big_number <= 5000), obtain their roman numeral \n\t\tequivalent as a string. For each number between 'small_number' and 'big_number' (inclusive), convert it into a lowercase roman numeral and return \n\t\tthem as a list of strings sorted in ascending order. \n\n    Examples:\n    >>> int_to_comprehensive_roman(1, 10) == ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x']\n    >>> int_to_comprehensive_roman(10, 15) == ['x', 'xi', 'xii', 'xiii', 'xiv', 'xv']\n    >>> int_to_comprehensive_roman(1, 1) == ['i']\n    \"\"\"\n", "canonical_solution": "\n\n    results = []\n    num = [1, 4, 5, 9, 10, 40, 50, 90, 100, 400, 500, 900, 1000, 4000] \n    sym = [\"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MMMM\"] \n    for number in range(small_number, big_number + 1):\n        i = 13\n        res = ''\n        while number > 0: \n            div = number // num[i] \n            number %= num[i] \n            while div: \n                res += sym[i] \n                div -= 1\n            i -= 1\n        results.append(res.lower())\n    return results\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(1, 10) == ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x']\n    assert candidate(10, 15) == ['x', 'xi', 'xii', 'xiii', 'xiv', 'xv']\n    assert candidate(1, 1) == ['i']\n    assert candidate(900, 905) == ['cm', 'cmi', 'cmii', 'cmiii', 'cmiv', 'cmv']\n    assert candidate(1000, 1000) == ['m']\n    assert candidate(4999, 5000) == ['mmmmcmxcix', 'mmmmm']\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True\n\n", "entry_point": "int_to_comprehensive_roman", "question": "Write a function def int_to_comprehensive_roman(small_number, big_number): to solve the following problem:\nGiven two positive integers, 'small_number' smaller or equal than 'big_number' (1 <= small_number <= big_number <= 5000), obtain their roman numeral \n\t\tequivalent as a string. For each number between 'small_number' and 'big_number' (inclusive), convert it into a lowercase roman numeral and return \n\t\tthem as a list of strings sorted in ascending order. \n\n    Examples:\n    >>> int_to_comprehensive_roman(1, 10) == ['i', 'ii', 'iii', 'iv', 'v', 'vi', 'vii', 'viii', 'ix', 'x']\n    >>> int_to_comprehensive_roman(10, 15) == ['x', 'xi', 'xii', 'xiii', 'xiv', 'xv']\n    >>> int_to_comprehensive_roman(1, 1) == ['i']\n", "context": "def int_to_comprehensive_roman(small_number, big_number):"}
{"key": 157, "prompt": "\n\ndef identify_triangle(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. \n    Return \"Right-angled triangle\" if the three sides form a right-angled triangle. \n    Return \"Equilateral triangle\" if it is an equilateral triangle where all sides are equal and all angles are 60 degrees.\n    Return \"Isosceles triangle\" if it is an isosceles triangle where two sides are equal and base angles are equal.\n    Return \"Scalene triangle\" if all sides are of different lengths and all angles are of different measures.\n    Return \"Not a triangle\" if the given sides can't form a triangle.\n    \n    Example:\n    identify_triangle(3, 4, 5) -> \"Right-angled triangle\"\n    identify_triangle(1, 1, 1) -> \"Equilateral triangle\"\n    identify_triangle(2, 2, 3) -> \"Isosceles triangle\"\n    identify_triangle(2, 3, 4) -> \"Scalene triangle\"\n    identify_triangle(3, 2, 7) -> \"Not a triangle\"\n    '''\n", "canonical_solution": "\n\n    # Conditions to check if it's a triangle\n    if (a+b > c) and (b+c > a) and (c+a > b):\n        # Check for right-angle triangle\n        if a*a == b*b + c*c or b*b == a*a + c*c or c*c == a*a + b*b:\n            return \"Right-angled triangle\"\n        # Check for equilateral triangle\n        elif a == b == c:\n            return \"Equilateral triangle\"\n        # Check for isosceles triangle\n        elif a == b or b == c or c == a:\n            return \"Isosceles triangle\"\n        # All else is scalene triangle\n        else:\n            return \"Scalene triangle\"\n    # If sides doesn't fit triangle properties\n    else:\n        return \"Not a triangle\"\n\n", "test": "\n\ndef check(candidate):\n\n    assert candidate(3, 4, 5) == \"Right-angled triangle\", \"assertion failed 1\"\n    assert candidate(1, 1, 1) == \"Equilateral triangle\", \"assertion failed 2\"\n    assert candidate(2, 2, 3) == \"Isosceles triangle\", \"assertion failed 3\"\n    assert candidate(2, 3, 4) == \"Scalene triangle\", \"assertion failed 4\"\n    assert candidate(3, 2, 7) == \"Not a triangle\", \"assertion failed 5\"\n\n", "entry_point": "identify_triangle", "question": "Write a function def identify_triangle(a, b, c): to solve the following problem:\nGiven the lengths of the three sides of a triangle. \n    Return \"Right-angled triangle\" if the three sides form a right-angled triangle. \n    Return \"Equilateral triangle\" if it is an equilateral triangle where all sides are equal and all angles are 60 degrees.\n    Return \"Isosceles triangle\" if it is an isosceles triangle where two sides are equal and base angles are equal.\n    Return \"Scalene triangle\" if all sides are of different lengths and all angles are of different measures.\n    Return \"Not a triangle\" if the given sides can't form a triangle.\n    \n    Example:\n    identify_triangle(3, 4, 5) -> \"Right-angled triangle\"\n    identify_triangle(1, 1, 1) -> \"Equilateral triangle\"\n    identify_triangle(2, 2, 3) -> \"Isosceles triangle\"\n    identify_triangle(2, 3, 4) -> \"Scalene triangle\"\n    identify_triangle(3, 2, 7) -> \"Not a triangle\"\n", "context": "def identify_triangle(a, b, c):"}
{"key": 158, "prompt": "\ndef find_max(words, n):\n    \"\"\"The function accepts a list of strings `words` and an integer `n`.\n    The list contains different words. The function should return the first `n` words with maximum\n    number of unique characters. If multiple strings have maximum number of unique\n    characters, they should be returned in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"], 2) should return [\"string\", \"name\"]\n    find_max([\"name\", \"enam\", \"game\"], 3) should return [\"enam\",\"game\",\"name\"]\n    \"\"\"\n", "canonical_solution": "\n    return sorted(words, key = lambda x: (-len(set(x)), x))[:n]\n", "test": "\ndef check(candidate):\n    # Check some simple cases\n    assert (candidate([\"name\", \"of\", \"string\"], 2) == [\"string\", \"name\"]), \"t1\"\n    assert (candidate([\"name\", \"enam\", \"game\"], 3) == [\"enam\", \"game\", \"name\"]), \"t2\"\n    assert (candidate([\"aaaaaaa\", \"bbbb\"], 2) == [\"aaaaaaa\", \"bbbb\"]), \"t3\"\n    # Check edge cases\n    assert (candidate([\"b\"], 1) == [\"b\"]), \"t4\"\n    assert (candidate([\"play\", \"play\", \"play\"], 3) == [\"play\", \"play\", \"play\"]), \"t5\"\n    # Check when n > len(words)\n    assert (candidate([\"play\", \"this\", \"game\"], 5) == [\"game\", \"play\", \"this\"]), \"t6\"\n", "entry_point": "find_max", "question": "Write a function def find_max(words, n): to solve the following problem:\nThe function accepts a list of strings `words` and an integer `n`.\n    The list contains different words. The function should return the first `n` words with maximum\n    number of unique characters. If multiple strings have maximum number of unique\n    characters, they should be returned in lexicographical order.\n\n    find_max([\"name\", \"of\", \"string\"], 2) should return [\"string\", \"name\"]\n    find_max([\"name\", \"enam\", \"game\"], 3) should return [\"enam\",\"game\",\"name\"]\n", "context": "def find_max(words, n):"}
{"key": 159, "prompt": "\n\ndef eat(number, need, remaining, friends_need):\n    \"\"\"\n    You're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals. Moreover, you \n    have rabbit friends who also need to eat.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals,\n                                    the number of carrots left after your friends' meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, \n    but will still be hungry. And if the remaining carrots are not enough for your friends, \n    they will also eat all the remaining carrots and will be hungry.\n    \n    Example:\n    * eat(5, 6, 10, 7) -> [11, 4, 0]\n    * eat(4, 8, 9, 3) -> [12, 1, 0]\n    * eat(1, 10, 10, 5) -> [11, 0, 0]\n    * eat(2, 11, 5, 8) -> [7, 0, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    @friends_need : integer\n        the number of carrots that your friends need to eat\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n    * 0 <= friends_need <= 1000\n\n    Have fun :)\n    \"\"\"\n", "canonical_solution": "\n\n    if(need <= remaining):\n        if(friends_need <= remaining-need):\n            return [ number + need , remaining-need, remaining-need-friends_need ]\n        else:\n            return [ number + need , remaining-need, 0]\n    else:\n        return [ number + remaining , 0, 0]\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert True, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(5, 6, 10, 7) == [11, 4, 0], \"Error\"\n    assert candidate(4, 8, 9, 3) == [12, 1, 0], \"Error\"\n    assert candidate(1, 10, 10, 5) == [11, 0, 0], \"Error\"\n    assert candidate(2, 11, 5, 8) == [7, 0, 0], \"Error\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n    assert candidate(4, 5, 7, 3) == [9, 2, 0], \"Error\"\n    assert candidate(4, 5, 1, 2) == [5, 0, 0], \"Error\"\n\n", "entry_point": "eat", "question": "Write a function def eat(number, need, remaining, friends_need): to solve the following problem:\nYou're a hungry rabbit, and you already have eaten a certain number of carrots,\n    but now you need to eat more carrots to complete the day's meals. Moreover, you \n    have rabbit friends who also need to eat.\n    you should return an array of [ total number of eaten carrots after your meals,\n                                    the number of carrots left after your meals,\n                                    the number of carrots left after your friends' meals ]\n    if there are not enough remaining carrots, you will eat all remaining carrots, \n    but will still be hungry. And if the remaining carrots are not enough for your friends, \n    they will also eat all the remaining carrots and will be hungry.\n    \n    Example:\n    * eat(5, 6, 10, 7) -> [11, 4, 0]\n    * eat(4, 8, 9, 3) -> [12, 1, 0]\n    * eat(1, 10, 10, 5) -> [11, 0, 0]\n    * eat(2, 11, 5, 8) -> [7, 0, 0]\n    \n    Variables:\n    @number : integer\n        the number of carrots that you have eaten.\n    @need : integer\n        the number of carrots that you need to eat.\n    @remaining : integer\n        the number of remaining carrots thet exist in stock\n    @friends_need : integer\n        the number of carrots that your friends need to eat\n    \n    Constrain:\n    * 0 <= number <= 1000\n    * 0 <= need <= 1000\n    * 0 <= remaining <= 1000\n    * 0 <= friends_need <= 1000\n\n    Have fun :)\n", "context": "def eat(number, need, remaining, friends_need):"}
{"key": 160, "prompt": "\n\n\ndef advanced_algebra(operator, operand, round_digit=None, negative=False):\n    \"\"\"\n    Given three parameters operator, operand, and round_digit. \n    The first parameter (operator) is a list of basic algebra operations, \n    the second parameter (operand) is a list of integers,\n    the third parameter (round_digit) is a integer for rounding, default is None for no rounding. \n    Use the first two parameters to build the algebraic expression and return the evaluation of this expression. \n    If the round_digit parameter provided, round the result to this digit after the decimal point.\n    If the negative parameter provided True, only take into account negative results, if no negative results return \"No negative results\"\n    \n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n    \n    Example 1:\n    operator['+', '*', '-'], operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n     => result = 9\n     \n    Example 2:\n    operator['+', '+', '+' ], operand = [-2, 2, -5]\n    negative = True\n    result = -2 + 2 - 5\n     => result = -5.\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n        round_digit is a positive integer, if provided.\n    \"\"\"\n", "canonical_solution": "\n\n    expression = str(operand[0])\n    for oprt, oprn in zip(operator, operand[1:]):\n        expression += oprt + str(oprn)\n    result = eval(expression)\n    \n    # Special case: if negative parameter provided True, only take into account negative results\n    if negative and result > 0:\n        return \"No negative results\"\n    \n    return round(result, round_digit) if round_digit else result\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5]) == 37\n    assert candidate(['+', '*', '-'], [2, 3, 4, 5]) == 9\n    assert candidate(['//', '*'], [7, 3, 4]) == 8, \"This prints if this assert fails 1 (good for debugging!)\"\n    assert candidate(['**', '*', '+'], [2, 3, 4, 5], 3) == 37.000\n    assert candidate(['+', '+', '+' ], [-2, 2, -5], negative=True) == -5 \n\n    # Check some edge cases that are easy to work out by hand.\n    assert True, \"This prints if this assert fails 2 (also good for debugging!)\"\n\n", "entry_point": "advanced_algebra", "question": "Write a function def advanced_algebra(operator, operand, round_digit=None, negative=False): to solve the following problem:\nGiven three parameters operator, operand, and round_digit. \n    The first parameter (operator) is a list of basic algebra operations, \n    the second parameter (operand) is a list of integers,\n    the third parameter (round_digit) is a integer for rounding, default is None for no rounding. \n    Use the first two parameters to build the algebraic expression and return the evaluation of this expression. \n    If the round_digit parameter provided, round the result to this digit after the decimal point.\n    If the negative parameter provided True, only take into account negative results, if no negative results return \"No negative results\"\n    \n    The basic algebra operations:\n    Addition ( + ) \n    Subtraction ( - ) \n    Multiplication ( * ) \n    Floor division ( // ) \n    Exponentiation ( ** ) \n    \n    Example 1:\n    operator['+', '*', '-'], operand = [2, 3, 4, 5]\n    result = 2 + 3 * 4 - 5\n     => result = 9\n     \n    Example 2:\n    operator['+', '+', '+' ], operand = [-2, 2, -5]\n    negative = True\n    result = -2 + 2 - 5\n     => result = -5.\n\n    Note:\n        The length of operator list is equal to the length of operand list minus one.\n        Operand is a list of of non-negative integers.\n        Operator list has at least one operator, and operand list has at least two operands.\n        round_digit is a positive integer, if provided.\n", "context": "def advanced_algebra(operator, operand, round_digit=None, negative=False):"}
{"key": 161, "prompt": "def solve_hard(s, t):\n    \"\"\"You are given two strings s and t. \n    Perform the following operations:\n    - if the character on the ith position in string s is a letter, \n      switch its case from lower to upper or vise versa, \n      otherwise keep it as it is.\n    - if the character on the ith position in string t is a letter, \n      switch its case from lower to upper or vise versa, \n      otherwise keep it as it is.\n    - If any of the strings contain no letters, reverse that string.\n    The function should return a tuple of both strings in the order (s,t).\n    Examples\n    solve_hard(\"1234\", \"ab\") = (\"4321\", \"AB\")\n    solve_hard(\"ab\", \"#a@C\") = (\"AB\", \"#A@c\")\n    \"\"\"\n", "canonical_solution": "    def switch_case(strng):\n        flg = 0\n        idx = 0\n        new_str = list(strng)\n        for i in strng:\n            if i.isalpha():\n                new_str[idx] = i.swapcase()\n                flg = 1\n            idx += 1\n        strng = \"\".join(new_str)\n        if flg == 0:\n            return strng[::-1]\n        return strng\n    return switch_case(s), switch_case(t)", "test": "def check(candidate):\n\n    assert candidate(\"AsDf\", \"1234\") == (\"aSdF\", \"4321\")\n    assert candidate(\"ab\", \"cd\") == (\"AB\", \"CD\")\n    assert candidate(\"#a@C\", \"ef\") == (\"#A@c\", \"EF\")\n    assert candidate(\"#AsdfW^45\", \"#6@2\") == (\"#aSDFw^45\", \"2@6#\")\n    assert candidate(\"#$a^D\", \"gh\") == (\"#$A^d\", \"GH\")\n    assert candidate(\"#ccc\", \"ij\") == (\"#CCC\", \"IJ\")\n    assert candidate(\"1234\", \"5678\") == (\"4321\", \"8765\")", "entry_point": "solve_hard", "question": "Write a function def solve_hard(s, t): to solve the following problem:\nYou are given two strings s and t. \n    Perform the following operations:\n    - if the character on the ith position in string s is a letter, \n      switch its case from lower to upper or vise versa, \n      otherwise keep it as it is.\n    - if the character on the ith position in string t is a letter, \n      switch its case from lower to upper or vise versa, \n      otherwise keep it as it is.\n    - If any of the strings contain no letters, reverse that string.\n    The function should return a tuple of both strings in the order (s,t).\n    Examples\n    solve_hard(\"1234\", \"ab\") = (\"4321\", \"AB\")\n    solve_hard(\"ab\", \"#a@C\") = (\"AB\", \"#A@c\")\n", "context": "def solve_hard(s, t):"}
{"key": 162, "prompt": "\n\ndef string_to_md5(text):\n    \"\"\"\n    Given a string list 'text', return a dictionary where keys are the strings and values are their md5 hash equivalent strings.\n    If 'text' is an empty list, return an empty dictionary.\n    If 'text' contains any empty string, ignore it and proceed with the rest of the elements.\n\n    >>> string_to_md5(['Hello world', 'password']) == {'Hello world': '3e25960a79dbc69b674cd4ec67a72c62', 'password': '5f4dcc3b5aa765d61d8327deb882cf99'}\n    \"\"\"\n", "canonical_solution": "\n\n    import hashlib\n    return {s:hashlib.md5(s.encode('ascii')).hexdigest() for s in text if s}\n\n", "test": "\n\ndef check(candidate):\n\n    # Check some simple cases\n    result = candidate(['Hello world', ''])\n    assert len(result) == 1 and 'Hello world' in result and result['Hello world'] == '3e25960a79dbc69b674cd4ec67a72c62'\n    \n    result = candidate([''])\n    assert len(result) == 0\n\n    result = candidate(['A B C', 'password'])\n    assert len(result) == 2 and 'A B C' in result and result['A B C'] == '0ef78513b0cb8cef12743f5aeb35f888' and 'password' in result and result['password'] == '5f4dcc3b5aa765d61d8327deb882cf99'\n\n    # Check some edge cases with larger list.\n    assert True\n\n", "entry_point": "string_to_md5", "question": "Write a function def string_to_md5(text): to solve the following problem:\nGiven a string list 'text', return a dictionary where keys are the strings and values are their md5 hash equivalent strings.\n    If 'text' is an empty list, return an empty dictionary.\n    If 'text' contains any empty string, ignore it and proceed with the rest of the elements.\n\n    >>> string_to_md5(['Hello world', 'password']) == {'Hello world': '3e25960a79dbc69b674cd4ec67a72c62', 'password': '5f4dcc3b5aa765d61d8327deb882cf99'}\n", "context": "def string_to_md5(text):"}
{"key": 163, "prompt": "def all_integers(a,b,c):\n    \"\"\"\n    Given three positive integers a, b, and c, return the sum of all digits within the range from a to b (inclusive) that are divisble by c. \n    The integers are returned in ascending order.\n\n    For example:\n    all_int_improved(2, 9, 1) => [2, 3, 4, 5, 6, 7, 8 ,9]\n    all_int_improved(9, 2, 1) => [2, 3, 4, 5, 6, 7, 8 ,9]\n    all_int_improved(2, 10, 2) => [2, 4, 6, 8, 10]\n    all_int_improved(10, 2, 2) => [2, 4, 6, 8, 10]\n    \"\"\"\n", "canonical_solution": "\n    lower = min(a, b)\n    upper = max(a, b)\n\n    return [i for i in range(lower, upper+1) if i % c == 0]\n", "test": "def check(candidate):\n\n    # Check some simple cases\n    assert candidate(2, 10, 1) == [2, 3, 4, 5, 6, 7, 8 ,9 ,10], \"Test 1\"\n    assert candidate(10, 2, 1) == [2, 3, 4, 5, 6, 7, 8 ,9 ,10], \"Test 2\"\n    assert candidate(2, 10, 2) == [2, 4, 6, 8, 10], \"Test 3\"\n    assert candidate(10, 2, 2) == [2, 4, 6, 8, 10], \"Test 4\"\n\n    # Check some edge cases that are easy to work out by hand.\n    assert candidate(2, 11, 3) == [3, 6, 9], \"Test 5\"\n    assert candidate(50, 100, 25) == [50, 75, 100], \"Test 6\"\n", "entry_point": "all_integers", "question": "Write a function def all_integers(a,b,c): to solve the following problem:\nGiven three positive integers a, b, and c, return the sum of all digits within the range from a to b (inclusive) that are divisble by c. \n    The integers are returned in ascending order.\n\n    For example:\n    all_int_improved(2, 9, 1) => [2, 3, 4, 5, 6, 7, 8 ,9]\n    all_int_improved(9, 2, 1) => [2, 3, 4, 5, 6, 7, 8 ,9]\n    all_int_improved(2, 10, 2) => [2, 4, 6, 8, 10]\n    all_int_improved(10, 2, 2) => [2, 4, 6, 8, 10]\n", "context": "def all_integers(a,b,c):"}
